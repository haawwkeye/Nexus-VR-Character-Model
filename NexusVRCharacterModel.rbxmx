<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">NexusVRCharacterModel</string>
      <string name="Source">--[[
TheNexusAvenger

Wraps the Nexus VR Character Model main module for loading.
When required with an id, the main module's source isn't
included, which makes the client see an empty script.
--]]

return require(script:WaitForChild("NexusVRCharacterModel"))</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">NexusVRCharacterModel</string>
        <string name="Source">--[[
TheNexusAvenger

Loads Nexus VR Character Model.
--]]
--!nocheck

--Client should send replication at 30hz.
--A buffer is added in case this rate is exceeded
--briefly, such as an unstable connection.
local REPLICATION_RATE_LIMIT = 35



local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local StarterPlayer = game:GetService("StarterPlayer")

local Settings = require(script:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local RateLimiter = require(script:WaitForChild("State"):WaitForChild("RateLimiter"))

local NexusVRCharacterModel = {}

-- Convert the string into a instance (hopefully works)
function ConvertToInstance(str : string) : Instance | nil
    local inst = nil;
    local success, err = pcall(function()
        local base = game;
        local list = str:split(".");
        for _, v in pairs(list) do
            base = base[v]
        end
        inst = base;
    end)

    return if not success then nil else inst;
end

function setupChar(plr)
	local char = plr.Character;
	local isEnabled = Settings:GetSetting("Appearance.EnableOverheadGui");
	local Parent = ConvertToInstance(Settings:GetSetting("Appearance.OverheadGuiParent"));

	print(isEnabled, typeof(isEnabled), Parent, typeof(Parent));

	if isEnabled and (Parent ~= nil and typeof(Parent) == "Instance" and Parent:IsA("BillboardGui")) then
		-- This should be an BillboardGui unless the developer changed it...
		-- Fixed by adding a Instance type check
		local head = char:WaitForChild("Head");
		if head:FindFirstChild(Parent.Name) == nil then
			local gui : BillboardGui = Parent:Clone();
			
			gui.PlayerToHideFrom = plr;
			gui.Adornee = head;
			gui.Parent = head;
		end
	end
	
	wait(0.1) -- force wait to make sure it's loaded. That and to give the client some time to wait for the event

	ReplicatedStorage:WaitForChild("VREnabled"):FireClient(plr);
end


--[[
Sets the configuration to use. Intended to be
run once by the server.
--]]
function NexusVRCharacterModel:SetConfiguration(Configuration: any): ()
    --Create the value.
    local ConfigurationValue = script:FindFirstChild("Configuration")
    if not ConfigurationValue then
        ConfigurationValue = Instance.new("StringValue")
        ConfigurationValue.Name = "Configuration"
        ConfigurationValue.Parent = script
    end

    --Store the configuration.
    ConfigurationValue.Value = HttpService:JSONEncode(Configuration)
    Settings:SetDefaults(Configuration)
end

--[[
Loads Nexus VR Character Model.
--]]
function NexusVRCharacterModel:Load(): ()
    --Return if a version is already loaded.
    if ReplicatedStorage:FindFirstChild("NexusVRCharacterModel") then
        return
    end

    local VREnabledRemote = Instance.new("RemoteEvent");
    VREnabledRemote.Name = "VREnabled";

    VREnabledRemote.OnServerEvent:Connect(function(plr)
        -- We want to overide the char so wait until it's loaded before you replace it
        local char = plr.Character or plr.CharacterAdded:Wait();
        local oldChar = char;

        -- This should be Humanoid so don't worry about that
        if char:WaitForChild("Humanoid").RigType ~= Enum.HumanoidRigType.R6 then return setupChar(plr) end;

        local charDesc = game.Players:GetHumanoidDescriptionFromUserId(plr.CharacterAppearanceId)
        char = game.Players:CreateHumanoidModelFromDescription(charDesc, Enum.HumanoidRigType.R15)

        -- PrimaryPart shouldn't be nil so no need to worry about that
        char:PivotTo(oldChar.PrimaryPart.CFrame)

        char.Name = plr.Name
        plr.Character = char
        char.Parent = workspace
        oldChar:Destroy()

        setupChar(plr)
    end)

    VREnabledRemote.Parent = ReplicatedStorage;

    --Rename and move the script to ReplicatedStorage.
    script.Name = "NexusVRCharacterModel"
    script:WaitForChild("NexusVRCore").Parent = ReplicatedStorage
    script.Parent = ReplicatedStorage;

    --Output any warnings.
    (require(ReplicatedStorage:WaitForChild("NexusVRCharacterModel"):WaitForChild("Util"):WaitForChild("Warnings")) :: any)()

    --Set up the client scripts.
    local NexusVRCharacterModelClientLoader = script:WaitForChild("NexusVRCharacterModelClientLoader")
    for _,Player in pairs(Players:GetPlayers()) do
        task.spawn(function()
            --Create and store a ScreenGui with the script.
            --This prevents the script disappearing on respawn.
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.ResetOnSpawn = false
            ScreenGui.Name = "NexusVRCharacterModelClientLoader"
            NexusVRCharacterModelClientLoader:Clone().Parent = ScreenGui
            ScreenGui.Parent = Player:WaitForChild("PlayerGui")
        end)
    end
    NexusVRCharacterModelClientLoader:Clone().Parent = StarterPlayer:WaitForChild("StarterPlayerScripts")

    --Set up replication.
    local ReadyPlayers = {}
    local UpdateRateLimiter = RateLimiter.new(REPLICATION_RATE_LIMIT)

    local UpdateInputsEvent = Instance.new("RemoteEvent")
    UpdateInputsEvent.Name = "UpdateInputs"
    UpdateInputsEvent.Parent = script

    local ReplicationReadyEvent = Instance.new("RemoteEvent")
    ReplicationReadyEvent.Name = "ReplicationReady"
    ReplicationReadyEvent.Parent = script

    UpdateInputsEvent.OnServerEvent:Connect(function(Player,HeadCFrame,LeftHandCFrame,RightHandCFrame)
        --Ignore the input if 3 CFrames aren't given.
        if typeof(HeadCFrame) ~= "CFrame" then return end
        if typeof(LeftHandCFrame) ~= "CFrame" then return end
        if typeof(RightHandCFrame) ~= "CFrame" then return end

        --Ignore if the rate limit was reached.
        if UpdateRateLimiter:RateLimitReached(Player) then return end

        --Replicate the CFrames to the other players.
        for _,OtherPlayer in Players:GetPlayers() do
            if Player ~= OtherPlayer and ReadyPlayers[OtherPlayer] then
                UpdateInputsEvent:FireClient(OtherPlayer,Player,HeadCFrame,LeftHandCFrame,RightHandCFrame)
            end
        end
    end)

    ReplicationReadyEvent.OnServerEvent:Connect(function(Player)
        ReadyPlayers[Player] = true
    end)

    Players.PlayerRemoving:Connect(function(Player)
        ReadyPlayers[Player] = nil
    end)

    --Load Nexus VR Backpack.
    if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
        (require(10728805649) :: any)()
    end
end




NexusVRCharacterModel.Api = (require(script:WaitForChild("Api")) :: any)()
return NexusVRCharacterModel</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Api</string>
          <string name="Source">--[[
TheNexusAvenger

Main module for creating the usable API.
--]]
--!strict

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")



return function()
    local NexusVRCharacterModel = script.Parent
    local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))
    local API = {} :: any
    API.Registered = NexusEvent.new()

    --[[
    Stores an API that can be referenced. If the API is already stored,
    an error will be thrown.
    --]]
    function API:Register(ApiName: string, Api: any): ()
        if self[ApiName] ~= nil then
            error("API already registered: "..tostring(ApiName))
        end
        self[ApiName] = Api
        self.Registered:Fire(ApiName)
    end

    --[[
    Waits for an API to be registered and returns the API. If it was
    already registered, it returns the API without waiting. Similar
    to instances, this would be treated like WaitForChild where the
    usage is optional instead of indexing (ex: API:WaitFor("MyApi")
    vs API.MyApi) as long as the consequences of an API not
    being registered are accepted.
    --]]
    function API:WaitFor(ApiName: string): any
        while not self[ApiName] do
            self.Registered:Wait()
        end
        return self[ApiName]
    end

    --[[
    Invokes a callback when an API is registered with a given
    name. If it is already registered, the callback will run
    asynchronously. This is intended for setting up an API
    call without blocking for WaitFor.
    --]]
    function API:OnRegistered(ApiName: string, RegisteredCallback: (any) -> ()): ()
        --Run the callback immediately if the API is loaded.
        if self[ApiName] then
            task.spawn(function()
                RegisteredCallback(self[ApiName])
            end)
            return
        end

        --Connect the registered event.
        self.Registered:Connect(function(RegisteredFunctionName)
            if ApiName ~= RegisteredFunctionName then return end
            RegisteredCallback(self[ApiName])
        end)
    end

    --Create the client API.
    --Done in a task to resolve recurisve requiring.
    if RunService:IsClient() then
        task.defer(function()
            --Build the initial shims for the APIs.
            local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
            local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
            API:Register("Camera", setmetatable({}, {__index=CameraService}))
            API:Register("Controller", setmetatable({}, {__index=ControlService}))
            API:Register("Input", setmetatable({}, {__index=require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()}))
            API:Register("Settings", setmetatable({}, {__index=require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()}))

            --Add the additional API adapters for the shims.
            API.Camera.GetActiveCamera = function()
                return CameraService.ActiveCamera
            end
            API.Controller.GetActiveController = function()
                return ControlService.ActiveController
            end

            --Add the custom APIs for the shims.
            local ActiveControllers = {}
            API.Controller.SetControllerInputEnabled = function(_, Hand: Enum.UserCFrame, Enabled: boolean): ()
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error("The following UserCFrame is invalid and can't be disabled: "..tostring(Hand))
                end
                ActiveControllers[Hand] = (Enabled ~= false)
            end
            API.Controller.EnableControllerInput = function(self, Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, true)
            end
            API.Controller.DisableControllerInput = function(self, Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, false)
            end
            API.Controller.IsControllerInputEnabled = function(_, Hand: Enum.UserCFrame): boolean
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error("The following UserCFrame is invalid and can't be disabled: "..tostring(Hand))
                end
                return ActiveControllers[Hand] ~= false
            end

            --Create the Menu API.
            --The Menu API does not work outside of VR.
            --Release 454 and later has/had a bug that made VREnabled false on start. This mitigates that now and in the future if VR loads dynamically.
            local MenuAPI = {} :: any
            local function GetMainMenu(): any
                if not MenuAPI.Enabled then
                    error("Menu API is not enabled for non-VR players. Check Api.Menu.Enabled before calling.")
                end
                return require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")).GetInstance()
            end
            if UserInputService.VREnabled then
                MenuAPI.Enabled = true
            else
                MenuAPI.Enabled = false
                UserInputService:GetPropertyChangedSignal("VREnabled"):Connect(function()
                    MenuAPI.Enabled = UserInputService.VREnabled
                end)
            end

            MenuAPI.CreateView = function(_, ...)
                return GetMainMenu():CreateView(...)
            end
            MenuAPI.IsOpen = function()
                return GetMainMenu().Enabled
            end
            MenuAPI.Open = function(self)
                if self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            MenuAPI.Close = function(self)
                if not self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            API:Register("Menu", MenuAPI)
        end)
    end

    --Return the APIs.
    return API
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Character</string>
          <string name="Source">--[[
TheNexusAvenger

Manipulates a character model.
--]]
--!strict

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent
local Head = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Head"))
local Torso = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Torso"))
local Appendage = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Appendage"))
local FootPlanter = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("FootPlanter"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: RemoteEvent

local Character = {}
Character.__index = Character

export type Character = {
    new: (CharacterModel: Model) -> Character,

    UpdateFromInputs: (self: Character, HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame) -> (),
}



--[[
Creates a character.
--]]
function Character.new(CharacterModel: Model): Character
    local self = {
        CharacterModel = CharacterModel,
        TweenComponents = true,
    }
    setmetatable(self, Character)

    --Determine if the arms can be disconnected.
    --Checking for the setting to be explicitly false is done in case the setting is undefined (default is true).
    local PreventArmDisconnection = false
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        local Setting = Settings:GetSetting("Appearance.LocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    else
        local Setting = Settings:GetSetting("Appearance.NonLocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    end

    --Store the body parts.
    self.Humanoid = CharacterModel:WaitForChild("Humanoid")
    self.Parts = {
        Head = CharacterModel:WaitForChild("Head"),
        UpperTorso = CharacterModel:WaitForChild("UpperTorso"),
        LowerTorso = CharacterModel:WaitForChild("LowerTorso"),
        HumanoidRootPart = CharacterModel:WaitForChild("HumanoidRootPart"),
        RightUpperArm = CharacterModel:WaitForChild("RightUpperArm"),
        RightLowerArm = CharacterModel:WaitForChild("RightLowerArm"),
        RightHand = CharacterModel:WaitForChild("RightHand"),
        LeftUpperArm = CharacterModel:WaitForChild("LeftUpperArm"),
        LeftLowerArm = CharacterModel:WaitForChild("LeftLowerArm"),
        LeftHand = CharacterModel:WaitForChild("LeftHand"),
        RightUpperLeg = CharacterModel:WaitForChild("RightUpperLeg"),
        RightLowerLeg = CharacterModel:WaitForChild("RightLowerLeg"),
        RightFoot = CharacterModel:WaitForChild("RightFoot"),
        LeftUpperLeg = CharacterModel:WaitForChild("LeftUpperLeg"),
        LeftLowerLeg = CharacterModel:WaitForChild("LeftLowerLeg"),
        LeftFoot = CharacterModel:WaitForChild("LeftFoot"),
    }
    self.Motors = {
        Neck = self.Parts.Head:WaitForChild("Neck"),
        Waist = self.Parts.UpperTorso:WaitForChild("Waist"),
        Root = self.Parts.LowerTorso:WaitForChild("Root"),
        RightShoulder = self.Parts.RightUpperArm:WaitForChild("RightShoulder"),
        RightElbow = self.Parts.RightLowerArm:WaitForChild("RightElbow"),
        RightWrist = self.Parts.RightHand:WaitForChild("RightWrist"),
        LeftShoulder = self.Parts.LeftUpperArm:WaitForChild("LeftShoulder"),
        LeftElbow = self.Parts.LeftLowerArm:WaitForChild("LeftElbow"),
        LeftWrist = self.Parts.LeftHand:WaitForChild("LeftWrist"),
        RightHip = self.Parts.RightUpperLeg:WaitForChild("RightHip"),
        RightKnee = self.Parts.RightLowerLeg:WaitForChild("RightKnee"),
        RightAnkle = self.Parts.RightFoot:WaitForChild("RightAnkle"),
        LeftHip = self.Parts.LeftUpperLeg:WaitForChild("LeftHip"),
        LeftKnee = self.Parts.LeftLowerLeg:WaitForChild("LeftKnee"),
        LeftAnkle = self.Parts.LeftFoot:WaitForChild("LeftAnkle"),
    }
    self.Attachments = {
        Head = {
            NeckRigAttachment = self.Parts.Head:WaitForChild("NeckRigAttachment"),
        },
        UpperTorso = {
            NeckRigAttachment = self.Parts.UpperTorso:WaitForChild("NeckRigAttachment"),
            LeftShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("LeftShoulderRigAttachment"),
            RightShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("RightShoulderRigAttachment"),
            WaistRigAttachment = self.Parts.UpperTorso:WaitForChild("WaistRigAttachment"),
        },
        LowerTorso = {
            WaistRigAttachment = self.Parts.LowerTorso:WaitForChild("WaistRigAttachment"),
            LeftHipRigAttachment = self.Parts.LowerTorso:WaitForChild("LeftHipRigAttachment"),
            RightHipRigAttachment = self.Parts.LowerTorso:WaitForChild("RightHipRigAttachment"),
            RootRigAttachment = self.Parts.LowerTorso:WaitForChild("RootRigAttachment"),
        },
        HumanoidRootPart = {
            RootRigAttachment = self.Parts.HumanoidRootPart:WaitForChild("RootRigAttachment"),
        },
        RightUpperArm = {
            RightShoulderRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightShoulderRigAttachment"),
            RightElbowRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightElbowRigAttachment"),
        },
        RightLowerArm = {
            RightElbowRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightElbowRigAttachment"),
            RightWristRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightWristRigAttachment"),
        },
        RightHand = {
            RightWristRigAttachment = self.Parts.RightHand:WaitForChild("RightWristRigAttachment"),
        },
        LeftUpperArm = {
            LeftShoulderRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftShoulderRigAttachment"),
            LeftElbowRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftElbowRigAttachment"),
        },
        LeftLowerArm = {
            LeftElbowRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftElbowRigAttachment"),
            LeftWristRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftWristRigAttachment"),
        },
        LeftHand = {
            LeftWristRigAttachment = self.Parts.LeftHand:WaitForChild("LeftWristRigAttachment"),
        },
        RightUpperLeg = {
            RightHipRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightHipRigAttachment"),
            RightKneeRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightKneeRigAttachment"),
        },
        RightLowerLeg = {
            RightKneeRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightKneeRigAttachment"),
            RightAnkleRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightAnkleRigAttachment"),
        },
        RightFoot = {
            RightAnkleRigAttachment = self.Parts.RightFoot:WaitForChild("RightAnkleRigAttachment"),
            RightFootAttachment = self.Parts.RightFoot:FindFirstChild("RightFootAttachment"),
        },
        LeftUpperLeg = {
            LeftHipRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftHipRigAttachment"),
            LeftKneeRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftKneeRigAttachment"),
        },
        LeftLowerLeg = {
            LeftKneeRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftKneeRigAttachment"),
            LeftAnkleRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftAnkleRigAttachment"),
        },
        LeftFoot = {
            LeftAnkleRigAttachment = self.Parts.LeftFoot:WaitForChild("LeftAnkleRigAttachment"),
            LeftFootAttachment = self.Parts.LeftFoot:FindFirstChild("LeftFootAttachment"),
        },
    }
    self.ScaleValues = {
        BodyDepthScale = self.Humanoid:WaitForChild("BodyDepthScale"),
        BodyWidthScale = self.Humanoid:WaitForChild("BodyWidthScale"),
        BodyHeightScale = self.Humanoid:WaitForChild("BodyHeightScale"),
        HeadScale = self.Humanoid:WaitForChild("HeadScale"),
    }

    --Add the missing attachments that not all rigs have.
    if not self.Attachments.RightFoot.RightFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.RightFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "RightFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.RightFoot
        self.Attachments.RightFoot.RightFootAttachment = NewAttachment
    end
    if not self.Attachments.LeftFoot.LeftFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.LeftFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "LeftFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.LeftFoot
        self.Attachments.LeftFoot.LeftFootAttachment = NewAttachment
    end

    --Store the limbs.
    self.Head = Head.new(self.Parts.Head :: BasePart)
    self.Torso = Torso.new(self.Parts.LowerTorso :: BasePart, self.Parts.UpperTorso :: BasePart)
    self.LeftArm = Appendage.new(CharacterModel:WaitForChild("LeftUpperArm") :: BasePart, CharacterModel:WaitForChild("LeftLowerArm") :: BasePart, CharacterModel:WaitForChild("LeftHand") :: BasePart, "LeftShoulderRigAttachment", "LeftElbowRigAttachment", "LeftWristRigAttachment", "LeftGripAttachment", PreventArmDisconnection)
    self.RightArm = Appendage.new(CharacterModel:WaitForChild("RightUpperArm") :: BasePart, CharacterModel:WaitForChild("RightLowerArm") :: BasePart, CharacterModel:WaitForChild("RightHand") :: BasePart, "RightShoulderRigAttachment", "RightElbowRigAttachment", "RightWristRigAttachment", "RightGripAttachment", PreventArmDisconnection)
    self.LeftLeg = Appendage.new(CharacterModel:WaitForChild("LeftUpperLeg") :: BasePart, CharacterModel:WaitForChild("LeftLowerLeg") :: BasePart, CharacterModel:WaitForChild("LeftFoot") :: BasePart, "LeftHipRigAttachment", "LeftKneeRigAttachment", "LeftAnkleRigAttachment", "LeftFootAttachment", true)
    self.LeftLeg.InvertBendDirection = true
    self.RightLeg = Appendage.new(CharacterModel:WaitForChild("RightUpperLeg") :: BasePart, CharacterModel:WaitForChild("RightLowerLeg") :: BasePart, CharacterModel:WaitForChild("RightFoot") :: BasePart, "RightHipRigAttachment", "RightKneeRigAttachment", "RightAnkleRigAttachment", "RightFootAttachment", true)
    self.RightLeg.InvertBendDirection = true
    self.FootPlanter = FootPlanter:CreateSolver(CharacterModel:WaitForChild("LowerTorso"), self.ScaleValues.BodyHeightScale)

    --Stop the character animations.
    local Animator = self.Humanoid:FindFirstChild("Animator") :: Animator
    if Animator then
        if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
            CharacterModel:WaitForChild("Animate"):Destroy()
            for _, Track in Animator:GetPlayingAnimationTracks() do
                Track:AdjustWeight(0, 0)
                Track:Stop(0)
            end
            Animator.AnimationPlayed:Connect(function(Track)
                Track:AdjustWeight(0, 0)
                Track:Stop(0)
            end)
        else
            Animator:Destroy()
        end
    end
    self.Humanoid.ChildAdded:Connect(function(NewAnimator)
        if NewAnimator:IsA("Animator") then
            if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
                CharacterModel:WaitForChild("Animate"):Destroy()
                for _, Track in NewAnimator:GetPlayingAnimationTracks() do
                    Track:AdjustWeight(0, 0)
                    Track:Stop(0)
                end
                NewAnimator.AnimationPlayed:Connect(function(Track)
                    Track:AdjustWeight(0, 0)
                    Track:Stop(0)
                end)
            else
                NewAnimator:Destroy()
            end
        end
    end)

    --Set up replication at 30hz.
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        task.spawn(function()
            while (self.Humanoid :: Humanoid).Health > 0 do
                --Send the new CFrames if the CFrames changed.
                if (self :: any).LastReplicationCFrames ~= (self :: any).ReplicationCFrames then
                    (self :: any).LastReplicationCFrames = (self :: any).ReplicationCFrames
                    UpdateInputs:FireServer(unpack((self :: any).ReplicationCFrames))
                end

                --Wait 1/30th of a second to send the next set of CFrames.
                task.wait(1 / 30)
            end
        end)
    end
    
    return (self :: any) :: Character
end

--[[
Returns the SeatPart of the humanoid.
SeatPart is not replicated to new players, which results in
strange movements of character.
https://devforum.roblox.com/t/seat-occupant-and-humanoid-seatpart-not-replicating-to-new-players-to-a-server/261545
--]]
function Character:GetHumanoidSeatPart(): BasePart?
    --Return nil if the Humanoid is not sitting.
    if not self.Humanoid.Sit then
        return nil
    end

    --Return if the seat part is defined.
    if self.Humanoid.SeatPart then
        return self.Humanoid.SeatPart
    end

    --Iterated through the connected parts and return if a seat exists.
    --While SeatPart may not be set, a SeatWeld does exist.
    for _, ConnectedPart in self.Parts.HumanoidRootPart:GetConnectedParts() do
        if ConnectedPart:IsA("Seat") or ConnectedPart:IsA("VehicleSeat") then
            return ConnectedPart
        end
    end
    return nil
end
--[[
Sets a property. The property will either be
set instantly or tweened depending on how
it is configured.
--]]
function Character:SetCFrameProperty(Object: Instance, PropertyName: string, PropertyValue: any): ()
    if self.TweenComponents then
        TweenService:Create(
            Object,
            TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {
                [PropertyName] = PropertyValue,
            }
        ):Play()
    else
        (Object :: any)[PropertyName] = PropertyValue
    end
end

--[[
Sets the transform of a motor.
--]]
function Character:SetTransform(MotorName: string, AttachmentName: string, StartLimbName: string, EndLimbName: string, StartCFrame: CFrame, EndCFrame: CFrame): ()
    self:SetCFrameProperty(self.Motors[MotorName], "Transform", (StartCFrame * self.Attachments[StartLimbName][AttachmentName].CFrame):Inverse() * (EndCFrame * self.Attachments[EndLimbName][AttachmentName].CFrame))
end

--[[
Updates the character from the inputs.
--]]
function Character:UpdateFromInputs(HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health &lt;= 0 then
        return
    end

    --Call the other method if there is a SeatPart.
    --The math below is not used while in seats due to assumptions made while standing.
    --The CFrames will already be in local space from the replication.
    local SeatPart = self:GetHumanoidSeatPart()
    if SeatPart then
        self:UpdateFromInputsSeated(HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame)
        return
    end

    --Get the CFrames.
    local HeadCFrame = self.Head:GetHeadCFrame(HeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(HeadControllerCFrame)
	local LowerTorsoCFrame: CFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
	local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame, UpperTorsoCFrame)
	local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = self.LeftArm:GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
	local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = self.RightArm:GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)

    --Set the character CFrames.
    --HumanoidRootParts must always face up. This makes the math more complicated.
    --Setting the CFrame directly to something not facing directly up will result in the physics
    --attempting to correct that within the next frame, causing the character to appear to move.
    local LeftFoot: CFrame, RightFoot: CFrame = self.FootPlanter:GetFeetCFrames()
    local LeftUpperLegCFrame, LeftLowerLegCFrame, LeftFootCFrame = self.LeftLeg:GetAppendageCFrames(JointCFrames["LeftHip"], LeftFoot * CFrame.Angles(0, math.pi, 0))
    local RightUpperLegCFrame, RightLowerLegCFrame, RightFootCFrame = self.RightLeg:GetAppendageCFrames(JointCFrames["RightHip"], RightFoot * CFrame.Angles(0, math.pi, 0))
    local TargetHumanoidRootPartCFrame = LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame:Inverse()
    local ActualHumanoidRootPartCFrame: CFrame = self.Parts.HumanoidRootPart.CFrame
    local HumanoidRootPartHeightDifference = ActualHumanoidRootPartCFrame.Y - TargetHumanoidRootPartCFrame.Y
    local NewTargetHumanoidRootPartCFrame = CFrame.new(TargetHumanoidRootPartCFrame.Position)
    self:SetCFrameProperty(self.Parts.HumanoidRootPart, "CFrame", CFrame.new(0, HumanoidRootPartHeightDifference, 0) * NewTargetHumanoidRootPartCFrame)
    self:SetCFrameProperty(self.Motors.Root, "Transform", CFrame.new(0, -HumanoidRootPartHeightDifference, 0) * (NewTargetHumanoidRootPartCFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame):Inverse() * LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame)
    self:SetTransform("RightHip", "RightHipRigAttachment", "LowerTorso", "RightUpperLeg", LowerTorsoCFrame, RightUpperLegCFrame)
    self:SetTransform("RightKnee", "RightKneeRigAttachment", "RightUpperLeg", "RightLowerLeg", RightUpperLegCFrame, RightLowerLegCFrame)
    self:SetTransform("RightAnkle", "RightAnkleRigAttachment", "RightLowerLeg", "RightFoot", RightLowerLegCFrame, RightFootCFrame)
    self:SetTransform("LeftHip", "LeftHipRigAttachment", "LowerTorso", "LeftUpperLeg", LowerTorsoCFrame, LeftUpperLegCFrame)
    self:SetTransform("LeftKnee", "LeftKneeRigAttachment", "LeftUpperLeg", "LeftLowerLeg", LeftUpperLegCFrame, LeftLowerLegCFrame)
    self:SetTransform("LeftAnkle", "LeftAnkleRigAttachment", "LeftLowerLeg", "LeftFoot", LeftLowerLegCFrame, LeftFootCFrame)
    self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
    self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
    self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
    self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
    self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
    self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
    self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)

    --Replicate the changes to the server.
    if Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel then
        self.ReplicationCFrames = {HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame}
    end
end

--[[
Updates the character from the inputs while seated.
The CFrames are in the local space instead of global space
since the seat maintains the global space.
--]]
function Character:UpdateFromInputsSeated(HeadControllerCFrame: CFrame, LeftHandControllerCFrame: CFrame, RightHandControllerCFrame: CFrame): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health &lt;= 0 then
        return
    end

    --Get the CFrames.
    local HeadCFrame = self.Head:GetHeadCFrame(HeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(HeadControllerCFrame,0)
	local LowerTorsoCFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
	local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame,UpperTorsoCFrame)
	local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = self.LeftArm:GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
	local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = self.RightArm:GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)
    local EyesOffset = self.Head:GetEyesOffset()
    local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (HeadControllerCFrame * EyesOffset:Inverse())).Y, 0)

    --Set the head, toros, and arm CFrames.
    self:SetCFrameProperty(self.Motors.Root, "Transform", HeightOffset * CFrame.new(0, -LowerTorsoCFrame.Y, 0) * LowerTorsoCFrame)
    self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
    self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
    self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
    self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
    self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
    self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
    self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)

    --Set the legs to be sitting.
    self.Motors.RightHip.Transform = CFrame.Angles(math.pi / 2, 0, math.rad(5))
    self.Motors.LeftHip.Transform = CFrame.Angles(math.pi / 2, 0, math.rad(-5))
    self.Motors.RightKnee.Transform = CFrame.Angles(math.rad(-10), 0, 0)
    self.Motors.LeftKnee.Transform = CFrame.Angles(math.rad(-10), 0, 0)
    self.Motors.RightAnkle.Transform = CFrame.Angles(0, 0, 0)
    self.Motors.LeftAnkle.Transform = CFrame.Angles(0, 0, 0)

    --Replicate the changes to the server.
    if Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel then
        self.ReplicationCFrames = {HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame}
    end
end



return (Character :: any) :: Character</string>
        </Properties>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">Appendage</string>
            <string name="Source"><![CDATA[ --[[
TheNexusAvenger

Stores information about an appendage, such as
an arm or a leg.
--]]

local Limb = require(script.Parent:WaitForChild("Limb"))

local Appendage = {}
Appendage.__index = Appendage
setmetatable(Appendage, Limb)



--[[
Creates an appendage.
--]]
function Appendage.new(UpperLimb: BasePart, LowerLimb: BasePart, LimbEnd: BasePart, StartAttachment: string, LimbJointAttachment: string, LimbEndAttachment: string, LimbHoldAttachment: string, PreventDisconnection: boolean?): any
    local self = Limb.new()
    self.UpperLimb = UpperLimb
    self.LowerLimb = LowerLimb
    self.LimbEnd = LimbEnd
    self.StartAttachment = StartAttachment
    self.LimbJointAttachment = LimbJointAttachment
    self.LimbEndAttachment = LimbEndAttachment
    self.LimbHoldAttachment = LimbHoldAttachment
    self.PreventDisconnection = PreventDisconnection or false
    return setmetatable(self, Appendage)
end

--[[
Attempts to solve a joint. This uses
the "naive" approach for inverse kinematics.
--]]
function Appendage:SolveJoint(OriginCFrame: CFrame, TargetPosition: Vector3, Length1: number, Length2: number): (CFrame, number, number)
    local LocalizedPosition = OriginCFrame:PointToObjectSpace(TargetPosition)
    local LocalizedUnit = LocalizedPosition.unit
    local Hypotenuse = LocalizedPosition.Magnitude

    --Get the axis and correct it if it is 0.
    local Axis = Vector3.new(0, 0, -1):Cross(LocalizedUnit)
    if Axis == Vector3.new(0, 0, 0) then
        if LocalizedPosition.Z < 0 then
            Axis = Vector3.new(0, 0, 0.001)
        else
            Axis = Vector3.new(0, 0, -0.001)
        end
    end

    --Calculate and return the angles.
    local PlaneRotation = math.acos(-LocalizedUnit.Z)
    local PlaneCFrame = OriginCFrame * CFrame.fromAxisAngle(Axis, PlaneRotation)
    if Hypotenuse < math.max(Length2, Length1) - math.min(Length2, Length1) then
        local ShoulderAngle, ElbowAngle = -math.pi / 2, math.pi
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, math.max(Length2, Length1) - math.min(Length2, Length1) - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    elseif Hypotenuse > Length1 + Length2 then
        local ShoulderAngle, ElbowAngle = math.pi / 2, 0
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, Length1 + Length2 - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    else
        local Angle1 = -math.acos((-(Length2 * Length2) + (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length1 * Hypotenuse))
        local Angle2 = math.acos(((Length2  * Length2) - (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length2 * Hypotenuse))
        if self.InvertBendDirection then
            Angle1 = -Angle1
            Angle2 = -Angle2
        end
        return PlaneCFrame , Angle1 + math.pi / 2, Angle2 - Angle1
    end
end

--[[
Returns the rotation offset relative to the Y axis
to an end CFrame.
--]]
function Appendage:RotationTo(StartCFrame: CFrame, EndCFrame: CFrame): CFrame
	local Offset = (StartCFrame:Inverse() * EndCFrame).Position
	return CFrame.Angles(math.atan2(Offset.Z, Offset.Y), 0, -math.atan2(Offset.X, Offset.Y))
end

--[[
Returns the CFrames of the appendage for
the starting and holding CFrames. The implementation
works, but could be improved.
--]]
function Appendage:GetAppendageCFrames(StartCFrame: CFrame, HoldCFrame: CFrame): (CFrame, CFrame, CFrame)
    --Get the attachment CFrames.
    local LimbHoldCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbHoldAttachment)
    local LimbEndCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbEndAttachment)
    local UpperLimbStartCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.StartAttachment)
    local UpperLimbJointCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.LimbJointAttachment)
    local LowerLimbJointCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbJointAttachment)
    local LowerLimbEndCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbEndAttachment)

    --Calculate the appendage lengths.
    local UpperLimbLength = (UpperLimbStartCFrame.Position - UpperLimbJointCFrame.Position).magnitude
    local LowerLimbLength = (LowerLimbJointCFrame.Position - LowerLimbEndCFrame.Position).magnitude

    --Calculate the end point of the limb.
    local AppendageEndJointCFrame = HoldCFrame * LimbHoldCFrame:Inverse() * LimbEndCFrame

    --Solve the join.
    local PlaneCFrame,UpperAngle,CenterAngle = self:SolveJoint(StartCFrame, AppendageEndJointCFrame.Position, UpperLimbLength, LowerLimbLength)

    --Calculate the CFrame of the limb join before and after the center angle.
    local JointUpperCFrame = PlaneCFrame * CFrame.Angles(UpperAngle, 0, 0) * CFrame.new(0, -UpperLimbLength, 0)
    local JointLowerCFrame = JointUpperCFrame * CFrame.Angles(CenterAngle, 0, 0)

    --Calculate the part CFrames.
    --The appendage end is not calculated with hold CFrame directly since it can ignore PreventDisconnection = true.
    local UpperLimbCFrame = JointUpperCFrame * self:RotationTo(UpperLimbJointCFrame, UpperLimbStartCFrame):Inverse() * UpperLimbJointCFrame:Inverse()
    local LowerLimbCFrame = JointLowerCFrame * self:RotationTo(LowerLimbEndCFrame, LowerLimbJointCFrame):Inverse() * LowerLimbJointCFrame:Inverse()
    local AppendageEndCFrame = CFrame.new((LowerLimbCFrame * LowerLimbEndCFrame).Position) * (CFrame.new(-AppendageEndJointCFrame.Position) * AppendageEndJointCFrame) * LimbEndCFrame:Inverse()

    --Return the part CFrames.
    return UpperLimbCFrame, LowerLimbCFrame, AppendageEndCFrame
end



return Appendage]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="5">
          <Properties>
            <string name="Name">Camera</string>
          </Properties>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">DefaultCamera</string>
              <string name="Source"><![CDATA[--[[
TheNexusAvenger

Default camera that follows the character.
--]]
--!strict

local BUMP_DEFAULT_TRANSPARENCY_WORKAROUND = true
local HIDDEN_ACCESSORIES = {
    [Enum.AccessoryType.Hat] = true;
    [Enum.AccessoryType.Hair] = true;
    [Enum.AccessoryType.Face] = true;
    [Enum.AccessoryType.Eyebrow] = true;
    [Enum.AccessoryType.Eyelash] = true;
}

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local DefaultCamera = {}
DefaultCamera.__index = DefaultCamera



--[[
Returns true if the provided part should be hidden in first person.
--]]
function DefaultCamera.ShouldHidePart(Part: BasePart): boolean
    local Parent: Instance? = Part.Parent
    if Parent then
        if Parent:IsA("Accessory") then
            local AccessoryType = Parent.AccessoryType
            return HIDDEN_ACCESSORIES[AccessoryType] or false
        elseif Parent:IsA("Model") then
            return false
        else
            return not Parent:IsA("Tool")
        end
    end

    if Part:FindFirstChildWhichIsA("WrapLayer") then
        return false
    end

    return true
end

--[[
Returns true if the provided part is in a tool.
--]]
function DefaultCamera.IsInTool(Part: Instance): boolean
    while Part do
        if Part:IsA("Tool") then
            return true
        end
        Part = (Part :: any).Parent
    end
    return false
end

--[[
Creates a default camera object.
--]]
function DefaultCamera.new(): any
    return setmetatable({}, DefaultCamera)
end

--[[
Enables the camera.
--]]
function DefaultCamera:Enable(): ()
    self.TransparencyEvents = {}
    if Players.LocalPlayer.Character then
        --Connect children being added.
        local Transparency = Settings:GetSetting("Appearance.LocalCharacterTransparency")
        if BUMP_DEFAULT_TRANSPARENCY_WORKAROUND then
            if Transparency == 0.5 then
                Transparency = 0.501
            elseif Transparency < 0.5 then
                warn("Values of <0.5 with Appearance.LocalCharacterTransparency are currently known to cause black screen issues. This will hopefully be resolved by Roblox in a future update: https://devforum.roblox.com/t/vr-screen-becomes-black-due-to-non-transparent-character/2215099")
            end
        end
        table.insert(self.TransparencyEvents, Players.LocalPlayer.Character.DescendantAdded:Connect(function(Part)
            if Part:IsA("BasePart") then
                local PartTransparency = Transparency
                if DefaultCamera.ShouldHidePart(Part) then
                    PartTransparency = 1
                elseif DefaultCamera.IsInTool(Part) then
                    PartTransparency = 0
                end

                Part.LocalTransparencyModifier = PartTransparency
                table.insert(self.TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                    Part.LocalTransparencyModifier = PartTransparency
                end))
            end
        end))
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                local PartTransparency = Transparency
                if DefaultCamera.ShouldHidePart(Part) then
                    PartTransparency = 1
                elseif DefaultCamera.IsInTool(Part) then
                    PartTransparency = 0
                end
                
                Part.LocalTransparencyModifier = PartTransparency
                table.insert(self.TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                    Part.LocalTransparencyModifier = PartTransparency
                end))
            end
        end
    end

    --Connect the character and local transparency changing.
    table.insert(self.TransparencyEvents, Players.LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
        self:Disable()
        self:Enable()
    end))
    table.insert(self.TransparencyEvents, Settings:GetSettingsChangedSignal("Appearance.LocalCharacterTransparency"):Connect(function()
        self:Disable()
        self:Enable()
    end))
end

--[[
Disables the camera.
--]]
function DefaultCamera:Disable(): ()
    --Disconnect the character events.
    if self.TransparencyEvents then
        for _, Event in self.TransparencyEvents do
            Event:Disconnect()
        end
        self.TransparencyEvents = {}
    end

    --Reset the local transparency modifiers.
    if Players.LocalPlayer.Character then
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                Part.LocalTransparencyModifier = 0
            end
        end
    end
end

--[[
Updates the camera.
--]]
function DefaultCamera:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    Workspace.CurrentCamera.HeadLocked = false
    Workspace.CurrentCamera.CFrame = HeadsetCFrameWorld
end



return DefaultCamera
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="7">
            <Properties>
              <string name="Name">ThirdPersonTrackCamera</string>
              <string name="Source">--[[
TheNexusAvenger

Third person camera that moves with the player.
--]]
--!strict

local THIRD_PERSON_ZOOM = 10



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local ThirdPersonTrackCamera = {}
ThirdPersonTrackCamera.__index = ThirdPersonTrackCamera



--[[
Creates a third-person camera object.
--]]
function ThirdPersonTrackCamera.new(): any
    return setmetatable({}, ThirdPersonTrackCamera)
end

--[[
Enables the camera.
--]]
function ThirdPersonTrackCamera:Enable(): ()
    self.FetchInitialCFrame = true
end

--[[
Disables the camera.
--]]
function ThirdPersonTrackCamera:Disable(): ()
    self.FetchInitialCFrame = nil
end

--[[
Updates the camera.
--]]
function ThirdPersonTrackCamera:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    --Set the initial CFrame to use.
    if self.FetchInitialCFrame then
        self.BaseFaceAngleY = math.atan2(-HeadsetCFrameWorld.LookVector.X, -HeadsetCFrameWorld.LookVector.Z)
        self.BaseCFrame = CFrame.new(HeadsetCFrameWorld.Position) * CFrame.Angles(0, self.BaseFaceAngleY, 0)
        self.FetchInitialCFrame = nil
    end

    --Get the scale.
    local Scale = 1
    local Character = Players.LocalPlayer.Character
    if Character then
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            local BodyHeightScale = Humanoid:FindFirstChild("BodyHeightScale")
            if BodyHeightScale then
                Scale = BodyHeightScale.Value
            end
        end
    end

    --Calculate the third person CFrame.
    local HeadsetRelative = self.BaseCFrame:Inverse() * HeadsetCFrameWorld
    local TargetCFrame = self.BaseCFrame * CFrame.new(0, 0, -THIRD_PERSON_ZOOM * Scale) * CFrame.Angles(0, math.pi, 0) * HeadsetRelative

    --Update the camaera.
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    Workspace.CurrentCamera.HeadLocked = false
    Workspace.CurrentCamera.CFrame = TargetCFrame
end



return ThirdPersonTrackCamera</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="8">
          <Properties>
            <string name="Name">Controller</string>
          </Properties>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">BaseController</string>
              <string name="Source"><![CDATA[ --[[
TheNexusAvenger

Base class for controlling the local character.
--]]
--!strict

local THUMBSTICK_INPUT_START_RADIUS = 0.6
local THUMBSTICK_INPUT_RELEASE_RADIUS = 0.4
local THUMBSTICK_DEADZONE_RADIUS = 0.2

local BLUR_TWEEN_INFO = TweenInfo.new(0.25, Enum.EasingStyle.Quad)

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local CharacterService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local BaseController = {}
BaseController.__index = BaseController



--[[
Returns the Y-axis angle of the given CFrame.
--]]
local function GetAngleToGlobalY(CF: CFrame): number
    return math.atan2(-CF.LookVector.X, -CF.LookVector.Z)
end



--[[
Creates a base controller object.
--]]
function BaseController.new(): any
    return setmetatable({}, BaseController)
end

--[[
Updates the character. Returns if it changed.
--]]
function BaseController:UpdateCharacterReference(): boolean
    local LastCharacter = self.Character
    self.Character = CharacterService:GetCharacter(Players.LocalPlayer)
    if not self.Character then
        return false
    end
    return LastCharacter ~= self.Character
end

--[[
Enables the controller.
--]]
function BaseController:Enable(): ()
    if not self.Connections then self.Connections = {} end

    --Update the character and return if the character is nil.
    self:UpdateCharacterReference()
    if not self.Character then
        return
    end

    --Connect the eye level being set.
    table.insert(self.Connections, VRInputService.EyeLevelSet:Connect(function()
        if self.LastHeadCFrame.Y > 0 then
            self.LastHeadCFrame = CFrame.new(0, -self.LastHeadCFrame.Y, 0) * self.LastHeadCFrame
        end
    end))

    --Connect the character entering a seat.
    table.insert(self.Connections, self.Character.Humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
        local SeatPart = self.Character:GetHumanoidSeatPart()
        if SeatPart then
            self:PlayBlur()
            VRInputService:Recenter()
        end
    end))

    --Disable auto rotate so that the default controls work.
    self.Character.Humanoid.AutoRotate = false

    --Disable the controls.
    --Done in a loop to ensure changed controllers are disabled.
    task.spawn(function()
        local ControlModule = require(Players.LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("ControlModule")) :: any
        local Character = self.Character
        while self.Character == Character and Character.Humanoid.Health > 0 do
            if ControlModule.activeController and ControlModule.activeController.enabled then
                ControlModule:Disable()
                ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
            end
            task.wait()
        end
    end)
end

--[[
Disables the controller.
--]]
function BaseController:Disable(): ()
    self.Character = nil
    self.LastHeadCFrame = nil
    for _, Connection in self.Connections do
        Connection:Disconnect()
    end
    self.Connections = nil
end

--[[
Scales the local-space input CFrame based on
the height multiplier of the character.
--]]
function BaseController:ScaleInput(InputCFrame: CFrame): CFrame
    --Return the original CFrame if there is no character.
    if not self.Character or not InputCFrame then
        return InputCFrame
    end

    --Return the modified CFrame.
    return CFrame.new(InputCFrame.Position * (self.Character.ScaleValues.BodyHeightScale.Value - 1)) * InputCFrame
end

--[[
Updates the provided 'Store' table with the state of its
Thumbstick (Enum.KeyCode.ThumbstickX) field. Returns the
direction state, radius state, and overall state change.
--]]
function BaseController:GetJoystickState(Store: any): (string, string, string)
    local InputPosition = VRInputService:GetThumbstickPosition(Store.Thumbstick)
    local InputRadius = ((InputPosition.X ^ 2) + (InputPosition.Y ^ 2)) ^ 0.5
    local InputAngle = math.atan2(InputPosition.X, InputPosition.Y)

    local DirectionState, RadiusState
    if InputAngle >= math.rad(-135) and InputAngle <= math.rad(-45) then
        DirectionState = "Left"
    elseif InputAngle >= math.rad(-45) and InputAngle <= math.rad(45) then
        DirectionState = "Forward"
    elseif InputAngle >= math.rad(45) and InputAngle <= math.rad(135) then
        DirectionState = "Right"
    end
    if InputRadius >= THUMBSTICK_INPUT_START_RADIUS then
        RadiusState = "Extended"
    elseif InputRadius <= THUMBSTICK_INPUT_RELEASE_RADIUS then
        RadiusState = "Released"
    else
        RadiusState = "InBetween"
    end

    --Update the stored state.
    local StateChange = nil
    if RadiusState == "Released" then
        if Store.RadiusState == "Extended" then
            StateChange = "Released"
        end
        Store.RadiusState = "Released"
        Store.DirectionState = nil
    elseif RadiusState == "Extended" then
        if Store.RadiusState == nil or Store.RadiusState == "Released" then
            if Store.RadiusState ~= "Extended" then
                StateChange = "Extended"
            end
            Store.RadiusState = "Extended"
            Store.DirectionState = DirectionState
        elseif Store.DirectionState ~= DirectionState then
            if Store.RadiusState ~= "Cancelled" then
                StateChange = "Cancel"
            end
            Store.RadiusState = "Cancelled"
            Store.DirectionState = nil
        end
    end

    return DirectionState, RadiusState, StateChange
end

--[[
Plays a temporary blur effect to make
teleports and snap turns less jarring.
]]--
function BaseController:PlayBlur(): ()
    local SnapTeleportBlur = Settings:GetSetting("Movement.SnapTeleportBlur")
    SnapTeleportBlur = (if SnapTeleportBlur == nil then true else SnapTeleportBlur)

    if not SnapTeleportBlur then
        return
    end

    local Blur = Instance.new("BlurEffect")
    Blur.Parent = workspace.CurrentCamera
    Blur.Size = 56

    local BlurTween = TweenService:Create(Blur, BLUR_TWEEN_INFO, { Size = 0 })
    BlurTween:Play()

    BlurTween.Completed:Connect(function()
        Blur:Destroy()
    end)
end

--[[
Updates the reference world CFrame.
--]]
function BaseController:UpdateCharacter(): ()
    --Return if the character is nil.
    local CharacterChanged = self:UpdateCharacterReference()
    if not self.Character then
        return
    end
    if CharacterChanged then
        self:Enable()
    end
    self.Character.TweenComponents = false

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    local VRHeadCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.Head])
    local VRLeftHandCFrame,VRRightHandCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.LeftHand]), self:ScaleInput(VRInputs[Enum.UserCFrame.RightHand])
    local HeadToLeftHandCFrame = VRHeadCFrame:Inverse() * VRLeftHandCFrame
    local HeadToRightHandCFrame = VRHeadCFrame:Inverse() * VRRightHandCFrame

    --Update the character.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    if not SeatPart then
        --Offset the character by the change in the head input.
        if self.LastHeadCFrame then
            --Get the eye CFrame of the current character, except the Y offset from the HumanoidRootPart.
            --The Y position will be added absolutely since doing it relatively will result in floating or short characters.
            local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
            local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * CFrame.new(0, -self.Character.Motors.Root.Transform.Position.Y, 0) * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
            local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
            local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
            local EyesOffset = self.Character.Head:GetEyesOffset()
            local CharacterEyeCFrame = HeadCFrame * EyesOffset

            --Determine the input components.
            local InputDelta = self.LastHeadCFrame:Inverse() * VRHeadCFrame
            if VRHeadCFrame.UpVector.Y < 0 then
                InputDelta = CFrame.Angles(0,math.pi,0) * InputDelta
            end
            local HeadRotationXZ = (CFrame.new(VRHeadCFrame.Position) * CFrame.Angles(0, math.atan2(-VRHeadCFrame.LookVector.X, -VRHeadCFrame.LookVector.Z), 0)):Inverse() * VRHeadCFrame
            local LastHeadAngleY = GetAngleToGlobalY(self.LastHeadCFrame)
            local HeadAngleY = GetAngleToGlobalY(VRHeadCFrame)
            local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (VRHeadCFrame * EyesOffset:Inverse())).Y, 0)

            --Offset the character eyes for the current input.
            local CurrentCharacterAngleY = GetAngleToGlobalY(CharacterEyeCFrame)
            local RotationY = CFrame.Angles(0, CurrentCharacterAngleY + (HeadAngleY - LastHeadAngleY), 0)
            local NewCharacterEyePosition = (HeightOffset *  CFrame.new((RotationY * CFrame.new(InputDelta.X, 0, InputDelta.Z)).Position) * CharacterEyeCFrame).Position
            local NewCharacterEyeCFrame = CFrame.new(NewCharacterEyePosition) * RotationY * HeadRotationXZ

            --Update the character.
            self.Character:UpdateFromInputs(NewCharacterEyeCFrame, NewCharacterEyeCFrame * HeadToLeftHandCFrame,NewCharacterEyeCFrame * HeadToRightHandCFrame)
        end
    else
        --Set the absolute positions of the character.
        self.Character:UpdateFromInputsSeated(VRHeadCFrame, VRHeadCFrame * HeadToLeftHandCFrame,VRHeadCFrame * HeadToRightHandCFrame)
    end
    self.LastHeadCFrame = VRHeadCFrame

    --Update the camera.
    if self.Character.Parts.HumanoidRootPart:IsDescendantOf(Workspace) and self.Character.Humanoid.Health > 0 then
        --Update the camera based on the character.
        --Done based on the HumanoidRootPart instead of the Head because of Motors not updating the same frame, leading to a delay.
        local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
        local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
        local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
        local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
        CameraService:UpdateCamera(HeadCFrame * self.Character.Head:GetEyesOffset())
    else
        --Update the camera based on the last CFrame if the motors can't update (not in Workspace).
        local CurrentCameraCFrame = Workspace.CurrentCamera.CFrame
        local LastHeadCFrame = self.LastHeadCFrame or CFrame.new()
        local HeadCFrame = self:ScaleInput(VRInputService:GetVRInputs()[Enum.UserCFrame.Head])
        Workspace.CurrentCamera.CFrame = CurrentCameraCFrame * LastHeadCFrame:Inverse() * HeadCFrame
        self.LastHeadCFrame = HeadCFrame
    end
end

--[[
Updates the values of the vehicle seat.
--]]
function BaseController:UpdateVehicleSeat(): ()
    --Get the vehicle seat.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    if not SeatPart or not SeatPart:IsA("VehicleSeat") then
        return
    end

    --Get the direction.
    local ThumbstickPosition = VRInputService:GetThumbstickPosition(Enum.KeyCode.Thumbstick1)
    if ThumbstickPosition.Magnitude < THUMBSTICK_DEADZONE_RADIUS then
        ThumbstickPosition = Vector3.zero
    end
    local ForwardDirection = (UserInputService:IsKeyDown(Enum.KeyCode.W) and 1 or 0) + (UserInputService:IsKeyDown(Enum.KeyCode.S) and -1 or 0) + ThumbstickPosition.Y
    local SideDirection = (UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or 0) + (UserInputService:IsKeyDown(Enum.KeyCode.A) and -1 or 0) + ThumbstickPosition.X

    --Update the throttle and steering.
    SeatPart.ThrottleFloat = ForwardDirection
    SeatPart.SteerFloat = SideDirection
end



return BaseController]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">SmoothLocomotionController</string>
              <string name="Source"><![CDATA[ --[[
TheNexusAvenger

Local character controller using teleporting.
--]]
--!strict

local THUMBSTICK_MANUAL_ROTATION_ANGLE = math.rad(45)
local THUMBSTICK_SMOOTH_ROTATION_ANGLE = math.rad(2.5)
local THUMBSTICK_DEADZONE_RADIUS = 0.2



local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local BaseController = require(script.Parent:WaitForChild("BaseController"))
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

function GetUserGameSetting(setting : string) : any
    return UserSettings():GetService("UserGameSettings")[setting];
end

local SmoothLocomotionController = {}
SmoothLocomotionController.__index = SmoothLocomotionController
setmetatable(SmoothLocomotionController, BaseController)



--[[
Creates a smooth locomotion controller object.
--]]
function SmoothLocomotionController.new(): any
    return setmetatable(BaseController.new(), SmoothLocomotionController)
end

--[[
Enables the controller.
--]]
function SmoothLocomotionController:Enable(): ()
    BaseController.Enable(self)
    self.JoystickState = { Thumbstick = Enum.KeyCode.Thumbstick2 }

    --Connect requesting jumping.
    --ButtonA does not work with IsButtonDown.
    self.ButtonADown = false
    table.insert(self.Connections, UserInputService.InputBegan:Connect(function(Input, Processsed)
        if Processsed then return end
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = true
        end
    end))
    table.insert(self.Connections, UserInputService.InputEnded:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = false
        end
    end))
end

--[[
Disables the controller.
--]]
function SmoothLocomotionController:Disable(): ()
    BaseController.Disable(self)
    self.JoystickState = nil
end

--[[
Updates the local character. Must also update the camara.
--]]
function SmoothLocomotionController:UpdateCharacter(): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Determine the direction to move the player.
    local ThumbstickPosition = VRInputService:GetThumbstickPosition(Enum.KeyCode.Thumbstick1)
    local LeftHandInputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(Enum.UserCFrame.LeftHand))
    local RightHandInputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(Enum.UserCFrame.RightHand))
    if ThumbstickPosition.Magnitude < THUMBSTICK_DEADZONE_RADIUS or not LeftHandInputActive then
        ThumbstickPosition = Vector3.zero
    end
    local WDown, SDown = not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.W), not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.S)
    local DDown, ADown = not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.D), not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.A)
    local ForwardDirection = (WDown and 1 or 0) + (SDown and -1 or 0) + ThumbstickPosition.Y
    local SideDirection = (DDown and 1 or 0) + (ADown and -1 or 0) + ThumbstickPosition.X

    --Move the player in that direction.
    Players.LocalPlayer:Move(Vector3.new(SideDirection, 0, -ForwardDirection), true)

    --Snap rotate the character.
    if not self.Character.Humanoid.Sit then
        --Update and fetch the right joystick's state.
        local DirectionState, RadiusState, StateChange = self:GetJoystickState(self.JoystickState)

        local SmoothRotation = GetUserGameSetting("VRSmoothRotationEnabled");
        local State = if SmoothRotation == true then RadiusState else StateChange;
        local MANUAL_ROTATION_ANGLE = if SmoothRotation == true then THUMBSTICK_SMOOTH_ROTATION_ANGLE else THUMBSTICK_MANUAL_ROTATION_ANGLE;

        --Snap rotate the character.
        local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
        if State == "Extended" and RightHandInputActive then
            if DirectionState == "Left" then
                --Turn the player to the left.
                if not SmoothRotation then self:PlayBlur() end
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            elseif DirectionState == "Right" then
                --Turn the player to the right.
                if not SmoothRotation then self:PlayBlur() end
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            end
        end
    end

    --Update the vehicle seat.
    self:UpdateVehicleSeat()

    --Jump the player.
    if (not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.Space)) or self.ButtonADown then
        self.Character.Humanoid.Jump = true
    end
end



return SmoothLocomotionController]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="11">
            <Properties>
              <string name="Name">TeleportController</string>
              <string name="Source"><![CDATA[ --[[
TheNexusAvenger

Local character controller using teleporting.
--]]
--!strict

local IGNORE_RIGHT_INPUT_FORWARD_ON_MENU_OPEN = true
local THUMBSTICK_MANUAL_ROTATION_ANGLE = math.rad(45)
local THUMBSTICK_SMOOTH_ROTATION_ANGLE = math.rad(2.5)



local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local BaseController = require(script.Parent:WaitForChild("BaseController"))
local ArcWithBeacon = require(script.Parent:WaitForChild("Visual"):WaitForChild("ArcWithBeacon"))
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

function GetUserGameSetting(setting : string) : any
    return UserSettings():GetService("UserGameSettings")[setting];
end

local TeleportController = {}
TeleportController.__index = TeleportController
setmetatable(TeleportController, BaseController)



--[[
Creates a teleport controller object.
--]]
function TeleportController.new(): any
    return setmetatable(BaseController.new(), TeleportController)
end

--[[
Enables the controller.
--]]
function TeleportController:Enable(): ()
    BaseController.Enable(self)

    --Create the arcs.
    self.LeftArc = ArcWithBeacon.new()
    self.RightArc = ArcWithBeacon.new()
    self.ArcControls = {
        {
            Thumbstick = Enum.KeyCode.Thumbstick1,
            UserCFrame = Enum.UserCFrame.LeftHand,
            Arc = self.LeftArc,
        },
        {
            Thumbstick = Enum.KeyCode.Thumbstick2,
            UserCFrame = Enum.UserCFrame.RightHand,
            Arc = self.RightArc,
        },
    }

    --Connect requesting jumping.
    --ButtonA does not work with IsButtonDown.
    self.ButtonADown = false
    table.insert(self.Connections, UserInputService.InputBegan:Connect(function(Input, Processsed)
        if Processsed then return end
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = true
        end
    end))
    table.insert(self.Connections, UserInputService.InputEnded:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            self.ButtonADown = false
        end
    end))
end

--[[
Disables the controller.
--]]
function TeleportController:Disable(): ()
    BaseController.Disable(self)

    --Destroy the arcs.
    self.LeftArc:Destroy()
    self.RightArc:Destroy()
end

--[[
Updates the local character. Must also update the camara.
--]]
function TeleportController:UpdateCharacter(): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    for _, InputEnum in Enum.UserCFrame:GetEnumItems() do
        VRInputs[InputEnum] = self:ScaleInput(VRInputs[InputEnum])
    end

    --Update the arcs.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    for _, ArcData in self.ArcControls do
        --Reset the left arc if the player is in a vehicle seat.
        if ArcData.Thumbstick == Enum.KeyCode.Thumbstick1 and SeatPart and SeatPart:IsA("VehicleSeat") then
            ArcData.Arc:Hide()
            continue
        end

        --Update and fetch the current state.
        local InputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(ArcData.UserCFrame))
        local DirectionState, RadiusState, StateChange = self:GetJoystickState(ArcData)
        if not InputActive then
            ArcData.Arc:Hide()
            ArcData.WaitForRelease = false
            ArcData.RadiusState = nil
            continue
        end

        --Cancel the input if it is forward facing, on the right hand, and the menu is visible.
        --This is an optimization for the Valve Index that has pressing the right thumbstick forward for opening the menu.
        --PositionLocked only appears when a user is pointing at the main user interface. This will not work if the player toggles
        --the Roblox UI but doesn't point at it. Ideally, there should be a way to know that this input opens the Roblox UI.
        if IGNORE_RIGHT_INPUT_FORWARD_ON_MENU_OPEN and not ArcData.WaitForRelease and DirectionState == "Forward" and ArcData.Thumbstick == Enum.KeyCode.Thumbstick2 then
            local VRCorePanelParts = Workspace.CurrentCamera:FindFirstChild("VRCorePanelParts")
            if VRCorePanelParts then
                local PositionLocked = VRCorePanelParts:FindFirstChild("PositionLocked")
                if PositionLocked and PositionLocked.Position.Magnitude > 0.001 then
                    ArcData.WaitForRelease = true
                end
            end
        end
        if ArcData.WaitForRelease then
            if RadiusState == "Released" then
                ArcData.WaitForRelease = false
            else
                StateChange = "Cancel"
                ArcData.RadiusState = nil
            end
        end

        --Update from the state.
        local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
        if DirectionState ~= "Forward" or RadiusState == "Released" then
            ArcData.Arc:Hide()
        end

        local SmoothRotation = GetUserGameSetting("VRSmoothRotationEnabled");
        local State = if SmoothRotation == true then RadiusState else StateChange;
        local MANUAL_ROTATION_ANGLE = if SmoothRotation == true then THUMBSTICK_SMOOTH_ROTATION_ANGLE else THUMBSTICK_MANUAL_ROTATION_ANGLE;

        if State == "Extended" then
            if SmoothRotation and DirectionState == "Forward" then
                ArcData.LastHitPart, ArcData.LastHitPosition = ArcData.Arc:Update(Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[ArcData.UserCFrame])
            end

            if not self.Character.Humanoid.Sit then
                if DirectionState == "Left" then
                    --Turn the player to the left.
                    if not SmoothRotation then self:PlayBlur() end
                    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                elseif DirectionState == "Right" then
                    --Turn the player to the right.
                    if not SmoothRotation then self:PlayBlur() end
                    HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -MANUAL_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                end
            end
        elseif StateChange == "Released" then
            ArcData.Arc:Hide()
            if DirectionState == "Forward" then
                --Teleport the player.
                if ArcData.LastHitPart and ArcData.LastHitPosition then
                    --Unsit the player.
                    --The teleport event is set to ignored since the CFrame will be different when the player gets out of the seat.
                    local WasSitting = false
                    self:PlayBlur()

                    if SeatPart then
                        WasSitting = true
                        self.IgnoreNextExternalTeleport = true
                        self.Character.Humanoid.Sit = false
                    end

                    if (ArcData.LastHitPart:IsA("Seat") or ArcData.LastHitPart:IsA("VehicleSeat")) and not ArcData.LastHitPart.Occupant and not ArcData.LastHitPart.Disabled then
                        --Sit in the seat.
                        --Waiting is done if the player was in an existing seat because the player no longer sitting will prevent sitting.
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                ArcData.LastHitPart:Sit(self.Character.Humanoid)
                            end)
                        else
                            ArcData.LastHitPart:Sit(self.Character.Humanoid)
                        end
                    else
                        --Teleport the player.
                        --Waiting is done if the player was in an existing seat because the player will teleport the seat.
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character.ScaleValues.BodyHeightScale.Value, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                            end)
                        else
                            HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character.ScaleValues.BodyHeightScale.Value, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                        end
                    end
                end
            end
        elseif StateChange == "Cancel" then
            ArcData.Arc:Hide()
        elseif DirectionState == "Forward" and RadiusState == "Extended" then
            ArcData.LastHitPart, ArcData.LastHitPosition = ArcData.Arc:Update(Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[ArcData.UserCFrame])
        end
    end

    --Update the vehicle seat.
    self:UpdateVehicleSeat()

    --Jump the player.
    if (not UserInputService:GetFocusedTextBox() and UserInputService:IsKeyDown(Enum.KeyCode.Space)) or self.ButtonADown then
        self.Character.Humanoid.Jump = true
    end
end



return TeleportController]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="12">
            <Properties>
              <string name="Name">Visual</string>
            </Properties>
            <Item class="ModuleScript" referent="13">
              <Properties>
                <string name="Name">Arc</string>
                <string name="Source">--[[
TheNexusAvenger

Visual indicator aiming with an arc.
--]]
--!strict

local MAX_SEGMENTS = 100
local SEGMENT_SEPARATION = 2
local BASE_POINTER_ANGLE = math.rad(60)
local POINTER_PARABOLA_HEIGHT_MULTIPLIER = -0.2



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent.Parent
local FindCollidablePartOnRay = require(NexusVRCharacterModel:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))

local Arc = {}
Arc.__index = Arc

export type Arc = {
    new: () -> (Arc),

    Update: (self: Arc, StartCFrame: CFrame) -> (BasePart?, Vector3?),
    Hide: (self: Arc) -> (),
    Destroy: (self: Arc) -> (),
}



--[[
Creates an arc.
--]]
function Arc.new(): Arc
    local self = setmetatable({
        BeamParts = {},
    }, Arc)
    self:Hide()
    return (self :: any) :: Arc
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function Arc:Update(StartCFrame: CFrame): (BasePart?, Vector3?)
    --Calculate the starting angle.
    local StartPosition = StartCFrame.Position
    local FaceAngle = math.atan2(-StartCFrame.LookVector.X, -StartCFrame.LookVector.Z)
    local StartAngle = math.asin(StartCFrame.LookVector.Y)
    StartAngle = StartAngle + (BASE_POINTER_ANGLE * ((math.pi / 2) - math.abs(StartAngle)) / (math.pi / 2))

    --Calculate the start CFrame and start offset of the parabola.
    --The start is the where the derivative of POINTER_PARABOLA_HEIGHT_MULTIPLIER * x^2 is tan(StartAngle).
    local StartCF = CFrame.new(StartPosition) * CFrame.Angles(0, FaceAngle, 0)
    local StartOffset = math.tan(StartAngle) / (POINTER_PARABOLA_HEIGHT_MULTIPLIER * 2)
    local StartValue = POINTER_PARABOLA_HEIGHT_MULTIPLIER * (StartOffset ^ 2)

    --Create the parts until the limit is reached.
    for i = 0, MAX_SEGMENTS - 1 do
        --Calculate the current and next position.
        local SegmentStartPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * i)).Position
        local SegmentEndPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + 1 + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * (i + 1))).Position

        --Create the parts if they don't exist.
        if not self.BeamParts[i] then
            self.BeamParts[i] = Instance.new("Part")
            self.BeamParts[i].Transparency = 1
            self.BeamParts[i].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i].Anchored = true
            self.BeamParts[i].CanCollide = false
            self.BeamParts[i].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i]
        end
        if not self.BeamParts[i + 1] then
            --Create the part and attachment.
            self.BeamParts[i + 1] = Instance.new("Part")
            self.BeamParts[i + 1].Transparency = 1
            self.BeamParts[i + 1].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i + 1].Anchored = true
            self.BeamParts[i + 1].CanCollide = false
            self.BeamParts[i + 1].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i + 1]

            --Create the beam.
            local Beam = Instance.new("Beam")
            Beam.Name = "Beam"
            Beam.Attachment0 = (self.BeamParts[i] :: any).BeamAttachment
            Beam.Attachment1 = Attachment
            Beam.Segments = 1
            Beam.Width0 = 0.1
            Beam.Width1 = 0.1
            Beam.Parent = self.BeamParts[i + 1]
        end

        --Cast the ray to the end.
        --Return if an end was hit and make the arc blue.
        local HitPart, HitPosition = FindCollidablePartOnRay(SegmentStartPosition, SegmentEndPosition - SegmentStartPosition, Players.LocalPlayer and Players.LocalPlayer.Character,Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart"))
        self.BeamParts[i].CFrame = CFrame.new(SegmentStartPosition) * CFrame.Angles(0, FaceAngle, 0);
        (self.BeamParts[i + 1] :: any).Beam.Enabled = true
        if HitPart then
            self.BeamParts[i + 1].CFrame = CFrame.new(HitPosition)
            for j = 0, i do
                (self.BeamParts[j + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(0, 170, 255))
            end
            for j = i + 1, #self.BeamParts - 1 do
                (self.BeamParts[j + 1] :: any).Beam.Enabled = false
            end
            return HitPart, HitPosition
        else
            self.BeamParts[i + 1].CFrame = CFrame.new(SegmentEndPosition)
        end
    end

    --Set the beams to red.
    for i = 0, #self.BeamParts - 1 do
        (self.BeamParts[i + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(200, 0, 0))
    end
    return nil, nil
end

--[[
Hides the arc.
--]]
function Arc:Hide(): ()
    for i = 0, #self.BeamParts - 1 do
        self.BeamParts[i + 1].Beam.Enabled = false
    end
end

--[[
Destroys the arc.
--]]
function Arc:Destroy(): ()
    for _, BeamPart in self.BeamParts do
        BeamPart:Destroy()
    end
    self.BeamParts = {}
end



return (Arc :: any) :: Arc</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="14">
              <Properties>
                <string name="Name">ArcWithBeacon</string>
                <string name="Source">--[[
TheNexusAvenger

Extension of the arc to add a beacon.
--]]
--!strict

local Arc = require(script.Parent:WaitForChild("Arc"))
local Beacon = require(script.Parent:WaitForChild("Beacon"))

local ArcWithBeacon = {}
ArcWithBeacon.__index = ArcWithBeacon
setmetatable(ArcWithBeacon, Arc)

export type ArcWithBeacon = {
    new: () -> (ArcWithBeacon),
} &amp; Arc.Arc



--[[
Creates an arc.
--]]
function ArcWithBeacon.new(): ArcWithBeacon
    local self = Arc.new() :: any
    setmetatable(self, ArcWithBeacon)
    self.Beacon = Beacon.new()
    self:Hide()
    return self :: ArcWithBeacon
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function ArcWithBeacon:Update(StartCFrame: CFrame): (BasePart?, Vector3?)
    --Update the arc.
    local HitPart, HitPosition = Arc.Update(self, StartCFrame)

    --Update the beacon.
    local Beacon = (self :: any).Beacon :: Beacon.Beacon
    if HitPart then
        Beacon:Update(CFrame.new(HitPosition :: Vector3) * CFrame.new(0, 0.001, 0), HitPart)
    else
        Beacon:Hide()
    end

    --Return the arc's returns.
    return HitPart, HitPosition
end

--[[
Hides the arc.
--]]
function ArcWithBeacon:Hide(): ()
    Arc.Hide(self);
    (self :: any).Beacon:Hide()
end

--[[
Destroys the arc.
--]]
function ArcWithBeacon:Destroy(): ()
    Arc.Destroy(self);
    (self :: any).Beacon:Destroy()
end



return (ArcWithBeacon :: any) :: ArcWithBeacon</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="15">
              <Properties>
                <string name="Name">Beacon</string>
                <string name="Source">--[[
TheNexusAvenger

Visual indicator for the end of aiming.
--]]
--!strict

local BEACON_SPEED_MULTIPLIER = 2



local Workspace = game:GetService("Workspace")

local Beacon = {}
Beacon.__index = Beacon

export type Beacon = {
    new: () -> (Beacon),

    Update: (self: Beacon, CenterCFrame: CFrame, HoverPart: BasePart) -> (),
    Hide: (self: Beacon) -> (),
    Destroy: (self: Beacon) -> (),
}



--[[
Creates a beacon.
--]]
function Beacon.new(): Beacon
    --Create the object.
    local self = {}
    setmetatable(self, Beacon)

    --Create the parts.
    self.Sphere = Instance.new("Part")
    self.Sphere.Transparency = 1
    self.Sphere.Material = Enum.Material.Neon
    self.Sphere.Anchored = true
    self.Sphere.CanCollide = false
    self.Sphere.Size = Vector3.new(0.5, 0.5, 0.5)
    self.Sphere.Shape = Enum.PartType.Ball
    self.Sphere.Parent = Workspace.CurrentCamera

    self.ConstantRing = Instance.new("ImageHandleAdornment")
    self.ConstantRing.Adornee = self.Sphere
    self.ConstantRing.Size = Vector2.new(2, 2)
    self.ConstantRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    self.ConstantRing.Visible = false
    self.ConstantRing.Parent = self.Sphere

    self.MovingRing = Instance.new("ImageHandleAdornment")
    self.MovingRing.Adornee = self.Sphere
    self.MovingRing.Size = Vector2.new(2, 2)
    self.MovingRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    self.MovingRing.Visible = false
    self.MovingRing.Parent = self.Sphere

    --Return the object.
    return (self :: any) :: Beacon
end

--[[
Updates the beacon at a given CFrame.
--]]
function Beacon:Update(CenterCFrame: CFrame, HoverPart: BasePart): ()
    --Calculate the size for the current time.
    local Height = 0.4 + (-math.cos(tick() * 2 * BEACON_SPEED_MULTIPLIER) / 8)
    local BeaconSize = 2 * ((tick() * BEACON_SPEED_MULTIPLIER) % math.pi) / math.pi

    --Update the size and position of the beacon.
    self.Sphere.CFrame = CenterCFrame * CFrame.new(0, Height, 0)
    self.ConstantRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.Transparency = BeaconSize / 2
    self.MovingRing.Size = Vector2.new(BeaconSize, BeaconSize)

    --Update the beacon color.
    local BeaconColor = Color3.fromRGB(0, 170, 0)
    if HoverPart then
        local VRBeaconColor = HoverPart:FindFirstChild("VRBeaconColor") :: Color3Value
        if VRBeaconColor then
            BeaconColor = VRBeaconColor.Value
        elseif (HoverPart:IsA("Seat") or HoverPart:IsA("VehicleSeat")) and not HoverPart.Disabled then
            BeaconColor = Color3.fromRGB(0, 170, 255)
        end
    end
    self.Sphere.Color = BeaconColor

    --Show the beacon.
    self.Sphere.Transparency = 0
    self.ConstantRing.Visible = true
    self.MovingRing.Visible = true
end

--[[
Hides the beacon.
--]]
function Beacon:Hide(): ()
    --Hide the beacon.
    self.Sphere.Transparency = 1
    self.ConstantRing.Visible = false
    self.MovingRing.Visible = false
end

--[[
Destroys the beacon.
--]]
function Beacon:Destroy(): ()
    self.Sphere:Destroy()
end



return (Beacon :: any) :: Beacon</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">FootPlanter</string>
            <string name="Source"><![CDATA[--[[
TheNexusAvenger

Attempts to solve footplanting.
This code is heavily "zombified" off of a project by
Stravant, and is taken from Nexus VR Character Model V1
with minimal changes. It really needs to be replaced by
someone who better unstands foot placement. No automated
tests are done on this code.
--]]
--!nocheck

local FootPlanter = {}


local CFnew,CFAngles = CFrame.new,CFrame.Angles
local V3new = Vector3.new
local rad,atan2,acos = math.rad,math.atan2,math.acos
local min,max,abs,log = math.min,math.max,math.abs,math.log



function FootPlanter:CreateSolver(CenterPart,ScaleValue)
	--Heavily modified code from Stravant
	local FootPlanterClass = {}
	
	local ignoreModel = CenterPart.Parent
	
	local LEG_GAP = 1.2
	--
	local STRIDE_FORWARD = 1.7 / 2
	local STRIDE_BACKWARD = 3.3 / 2
	local STRIDE_HEIGHT = 0.6
	local STRIDE_RESTING = 1
	--
	local WALK_SPEED_VR_THRESHOLD = 2
	local FOOT_MAX_SPEED_FACTOR = 2
	--
	local WALK_CYCLE_POWER = 1
	--
	local FOOT_ANGLE = rad(5)
	
	
	
	local function flatten(CF)
		local X,Y,Z = CF.X,CF.Y,CF.Z
		local LX,LZ = CF.lookVector.X,CF.lookVector.Z
		
		return CFnew(X,Y,Z) * CFAngles(0,atan2(LX,LZ),0)
	end
	
	local lastPosition,lastPollTime
	local overrideVelocityWithZero = false
	local function getVelocity(CF)
		if overrideVelocityWithZero then
			overrideVelocityWithZero = true
			
			local curTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
		
		if lastPollTime then
			local curTime = tick()
			local newPosition = CF.p
			
			local velocity = (newPosition - lastPosition) * 1/(curTime - lastPollTime)
			lastPollTime = curTime
			lastPosition = newPosition
			
			return velocity
		else
			lastPollTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
	end
	
	local function getWalkSpeed(velocity)
		return V3new(velocity.x,0,velocity.z).magnitude
	end
	
	local function getWalkDirection(velocity)
		if velocity.magnitude > 0. then
			return velocity.unit
		else
			return V3new(0,0,-1)
		end
	end
	
	local function isWalking(velocity)
		return getWalkSpeed(velocity) > WALK_SPEED_VR_THRESHOLD
	end

	local CurrentScale = 1
	local function getBaseCFrame()
		return CenterPart.CFrame * CFnew(0,-CenterPart.Size.Y/2 - (CurrentScale * 2),0)
	end
	
	local function getBaseRotationY()
		local lookVector = getBaseCFrame().lookVector
		return atan2(lookVector.X,lookVector.Z)
	end
	
	local FindCollidablePartOnRay = require(script.Parent.Parent:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))
	local function FindPartOnRay(ray,ignore)
		return FindCollidablePartOnRay(ray.Origin,ray.Direction,ignore,CenterPart)
	end
	
	
	
	
	-- Leg data
	local mRightLeg, mLeftLeg, mRightArm, mLeftArm;
	local mLegs = {}
	local lastCF
	local function initLegs()
		local cf = flatten(getBaseCFrame())
		lastCF = cf
		mRightLeg = {
			OffsetModifier = CFnew(-LEG_GAP/2, 0, 0);
			Side = -1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mRightLeg.OtherLeg = mLeftLeg
		mLeftLeg.OtherLeg = mRightLeg
		mLegs = {mLeftLeg, mRightLeg}
	end
	
	local LastScale = 1
	local function UpdateScaling()
		local Multiplier = ScaleValue.Value / LastScale
		LastScale = ScaleValue.Value

		LEG_GAP = LEG_GAP * Multiplier
		STRIDE_FORWARD = STRIDE_FORWARD * Multiplier
		STRIDE_BACKWARD = STRIDE_BACKWARD * Multiplier
		STRIDE_HEIGHT = STRIDE_HEIGHT * Multiplier
		STRIDE_RESTING = STRIDE_RESTING * Multiplier

		mRightLeg.OffsetModifier = CFnew(-LEG_GAP/2, 0, 0)
		--[[mRightLeg.FootPosition
		mRightLeg.LastStepTo
		mRightLeg.Takeoff
			 = ;
			Side = -1;
			--
			StepCycle = 0;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = lastCF*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}]]
	end
	ScaleValue.Changed:Connect(function()
		if mRightLeg then
			UpdateScaling()
		end
	end)


	local mAirborneFraction = 0
	local mLandedFraction = 0
	local mCurrentSpeed = 1
	local mStableStanding = false
	
	local function getStrideForward()
		if mCurrentSpeed > 0 then
			return STRIDE_FORWARD + STRIDE_FORWARD*1*mCurrentSpeed
		else
			return STRIDE_FORWARD + STRIDE_FORWARD*0.5*mCurrentSpeed
		end
	end
	
	local function getStrideFull()
		if mCurrentSpeed > 0 then
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*1.5*mCurrentSpeed
		else
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*0.5*mCurrentSpeed
		end
	end

	local function snapDown(pos)
		local orig, dir = (pos + V3new(0, 2, 0)), V3new(0, -500, 0)
		local hit, at = FindPartOnRay(Ray.new(orig, dir), ignoreModel)
		if hit then
			local hit1, at1 = FindPartOnRay(Ray.new(orig + V3new(0,    0,  0.01), dir), ignoreModel)
			local hit2, at2 = FindPartOnRay(Ray.new(orig + V3new(0,    0, -0.01), dir), ignoreModel)				
			local hit3, at3 = FindPartOnRay(Ray.new(orig + V3new(0.01, 0,  0   ), dir), ignoreModel)
			local norm;
			
			if hit1 and hit2 and hit3 then
				norm = (at1 - at2):Cross(at2 - at3).unit
				if norm.Y < 0 then
					norm = -norm
				end					
			end
			
			return at, norm
		else
			return pos, V3new(0, 1, 0)
		end
	end
	
	local function fixFeetPositionsY()
		for _,leg in pairs(mLegs) do
			local targetPos,norm = snapDown(leg.FootPosition)
			leg.FootPosition = targetPos
		end
	end
	
	local lastTime
	function FootPlanterClass:GetFeetCFrames()
		if not mLeftLeg then
			initLegs()
			UpdateScaling()
		end
		
		local curTime = tick()
		if not lastTime then lastTime = curTime end
		local dt = curTime - lastTime
		lastTime = curTime
		
		local velocity = getVelocity(CenterPart.CFrame)
		local speed = getWalkSpeed(velocity)
		local realBaseCF = flatten(CenterPart.CFrame)
		local baseCF = realBaseCF
		local baseAxis = baseCF.lookVector
		local baseAxisPerp = baseAxis:Cross(V3new(0, 1, 0))
		local walkAxis = getWalkDirection(velocity)
		local walkAxisPerp = walkAxis:Cross(V3new(0, 1, 0))
		
		--
		mCurrentSpeed = max(-1, min(1, log(speed/16)/log(2)))
		--
		local leftStepping = mLeftLeg.StepCycle > 0
		local rightStepping = mRightLeg.StepCycle > 0
		--
				
		local function spline(t2, n, p)
			if n == 1 then
				return p[1]
			else
				local t1 = (1 - t2)
				for i = 1, n-1 do
					p[i] = t1*p[i] + t2*p[i+1]
				end
				return spline(t2, n-1, p)
			end
		end
			
		local function positionFootByCycle(leg, stepTarget)
			local baseVector = stepTarget - leg.Takeoff
			local sideVector = walkAxisPerp*leg.Side
			local baseLen = baseVector.magnitude
			local towardsSide = sideVector*(LEG_GAP/2)*0.3
			local towardsTop = V3new(0, 1.3*STRIDE_HEIGHT*(1 / leg.StepSpeedMod), 0)
			local topPoint = leg.Takeoff + baseVector * 1/2 + towardsTop + towardsSide
			local nextPoint = leg.Takeoff + baseVector * 0.9 + towardsTop + towardsSide
			--local a, b, c = leg.Takeoff, topPoint, stepTarget
			--local fb = leg.StepCycle
			--fb = fb^(_G.A or WALK_CYCLE_POWER)
			--local fa = 1-fb
			--
			--local footDesiredPos = fa*fa*a + 2*fa*fb*b + fb*fb*c
			local fb = leg.StepCycle^(_G.A or WALK_CYCLE_POWER)
			local footDesiredPos = spline(fb, 4, {leg.Takeoff, topPoint, nextPoint, stepTarget})
			--makeP(CFnew(footDesiredPos))
			if (footDesiredPos - leg.FootPosition).magnitude > dt*speed*FOOT_MAX_SPEED_FACTOR then
				local forcePos = (1 - leg.StepCycle) * leg.FootPosition + leg.StepCycle * footDesiredPos
				local movePos = leg.FootPosition + (footDesiredPos - leg.FootPosition).unit * dt*speed*FOOT_MAX_SPEED_FACTOR
				if (forcePos - footDesiredPos).magnitude < (movePos - footDesiredPos).magnitude then
					footDesiredPos = forcePos
				else
					footDesiredPos = movePos
				end
			end
			leg.FootPosition = footDesiredPos
			leg.LastStepTo = stepTarget
		end
		--
		local isCharacterWalking = isWalking(velocity)
		if isCharacterWalking then
			mStableStanding = false
		end
		--
		if isCharacterWalking then
			-- Get the desired ahead step
			local centeringMod = walkAxisPerp * (LEG_GAP/2) * 0.5
			local rightDesiredAheadStep = (baseCF * mRightLeg.OffsetModifier + getStrideForward()*walkAxis - mRightLeg.Side*centeringMod).p
			local leftDesiredAheadStep  = (baseCF *  mLeftLeg.OffsetModifier + getStrideForward()*walkAxis - mLeftLeg.Side*centeringMod).p
			local rightNorm, leftNorm;
			rightDesiredAheadStep, rightNorm = snapDown(rightDesiredAheadStep)
			leftDesiredAheadStep, leftNorm = snapDown(leftDesiredAheadStep)
			if not rightStepping or not mRightLeg.AheadStep or (rightDesiredAheadStep - mRightLeg.AheadStep).magnitude < dt*speed then
				mRightLeg.AheadStep = rightDesiredAheadStep
			else
				mRightLeg.AheadStep = mRightLeg.AheadStep + (rightDesiredAheadStep - mRightLeg.AheadStep).unit * dt*speed*2
			end
			mRightLeg.NormalHint = rightNorm
			if not leftStepping or not mLeftLeg.AheadStep or (leftDesiredAheadStep - mLeftLeg.AheadStep).magnitude < dt*speed then
				mLeftLeg.AheadStep = leftDesiredAheadStep
			else
				mLeftLeg.AheadStep = mLeftLeg.AheadStep + (leftDesiredAheadStep - mLeftLeg.AheadStep).unit * dt*speed*2
			end
			mLeftLeg.NormalHint = leftNorm
			
			local strideFactor = 0.9 - 0.3*max(0, mCurrentSpeed)
			local stepSpeed = speed / getStrideFull() * strideFactor
			
			-- Which legs are stepping?
			if not leftStepping and not rightStepping then
				-- Neither leg is stepping pick up the closer leg into the step
				if mAirborneFraction < 0.8 then -- don't pick up feet if we just landed
					if (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude < (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude then
						-- step p1
						local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude / getStrideFull()))
						mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)
						mLeftLeg.StepCycle = dt
						mLeftLeg.Takeoff = mLeftLeg.FootPosition
					else
						-- step p2
						local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude / getStrideFull()))
						mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
						mRightLeg.StepCycle = dt
						mRightLeg.Takeoff = mRightLeg.FootPosition
					end
				end
			elseif leftStepping and rightStepping then
				-- Both legs are stepping
				-- just step both legs
				-- The leg closer to |aheadStep| should step there, and the
				-- other leg should 
				for _, leg in pairs(mLegs) do
					leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
					positionFootByCycle(leg, leg.AheadStep)
					if leg.StepCycle == 1 then
						leg.StepCycle = 0
					end
				end
			else
				-- One leg is stepping.
				-- Step the one leg, and see if the other needs to enter a step
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						-- Step this leg
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
						positionFootByCycle(leg, leg.AheadStep)
						
						-- Check if leg.Other needs to start a step
						if leg.StepCycle > strideFactor then
							leg.OtherLeg.StepSpeedMod = 1
							leg.OtherLeg.StepCycle = dt
							leg.OtherLeg.Takeoff = leg.OtherLeg.FootPosition
							positionFootByCycle(leg.OtherLeg, leg.AheadStep)
						end
						
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
						
						break
					end
				end
			end
		else
			local stepSpeed = 2			
			
			-- Not walking, we need to try to get to a suitable base position
			if leftStepping or rightStepping then
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed)
						local restingPos = (baseCF * leg.OffsetModifier).p
						local toVec = (leg.LastStepTo - restingPos)
						local targetPos;
						if toVec.magnitude > STRIDE_RESTING then
							targetPos = restingPos + (toVec.unit * STRIDE_RESTING)
						else
							targetPos = leg.LastStepTo
						end
						local norm;
						targetPos, norm = snapDown(targetPos)
						leg.AheadStep = targetPos
						leg.NormalHint = norm
						positionFootByCycle(leg, targetPos)
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
					else
						continue
					end
				end
			else
				fixFeetPositionsY()
			end
			
			-- Now, we stepped both legs. If both legs are resting now. See if 
			-- they are on roughly opposite offsets from where they should be.
			if mRightLeg.StepCycle == 0 and mLeftLeg.StepCycle == 0 then
				local rightResting = (baseCF * mRightLeg.OffsetModifier).p
				local leftResting = (baseCF * mLeftLeg.OffsetModifier).p
				local rightSep = mRightLeg.FootPosition - rightResting
				local leftSep = mLeftLeg.FootPosition - leftResting
				--
				local tooFar = abs(rightSep:Dot(baseAxis) - leftSep:Dot(baseAxis)) > 3
				local thetaBetweenFeet = acos(min(1, max(-1, rightSep.unit:Dot(leftSep.unit))))
				local distBetweenFeet = abs(rightSep.magnitude - leftSep.magnitude)
				--
				if rightSep:Dot(baseAxisPerp) > LEG_GAP/4 then
					mStableStanding = false
					mRightLeg.Takeoff = mRightLeg.FootPosition
					mRightLeg.StepCycle = dt
					--mRightLeg.LastStepTo = rightResting - baseAxisPerp*0.5
					local modLeftSep = leftSep.unit * 0.5
					if leftSep.magnitude == 0 then
						modLeftSep = -baseAxisPerp*0.5
					elseif leftSep:Dot(baseAxisPerp) > 0 then
						modLeftSep = (leftSep - 2*baseAxisPerp*leftSep:Dot(baseAxisPerp)).unit*0.5
					end
					mRightLeg.LastStepTo = rightResting + modLeftSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end
					local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.LastStepTo).magnitude / getStrideFull()))
					mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
				elseif leftSep:Dot(baseAxisPerp) < -LEG_GAP/4 then
					mStableStanding = false
					mLeftLeg.Takeoff = mLeftLeg.FootPosition
					mLeftLeg.StepCycle = dt
					--mLeftLeg.LastStepTo = leftResting + baseAxisPerp*0.5	
					local modRightSep = rightSep.unit * 0.5
					if rightSep.magnitude == 0 then
						modRightSep = baseAxisPerp*0.5
					elseif rightSep:Dot(baseAxisPerp) < 0 then
						modRightSep = (rightSep - 2*baseAxisPerp*rightSep:Dot(baseAxisPerp)).unit*0.5
					end
					mLeftLeg.LastStepTo = leftResting + modRightSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end					
					local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.LastStepTo).magnitude / getStrideFull()))
					mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)	
				elseif not mStableStanding and (thetaBetweenFeet < rad(150) or distBetweenFeet > 0.2 or tooFar) and mAirborneFraction < 0.5 then
					mStableStanding = true
					-- Step the foot further from the rest pos
					local furtherLeg, furtherResting, otherSep;
					if rightSep.magnitude > leftSep.magnitude then
						furtherLeg = mRightLeg
						furtherResting = rightResting
						otherSep = leftSep
					else
						furtherLeg = mLeftLeg
						furtherResting = leftResting
						otherSep = rightSep
					end
					--
					furtherLeg.StepCycle = dt
					furtherLeg.Takeoff = furtherLeg.FootPosition
					furtherLeg.StepSpeedMod = 1
					if tooFar then
						furtherLeg.LastStepTo = furtherResting - 0.5*otherSep
					else
						furtherLeg.LastStepTo = furtherResting - otherSep
					end
					if (furtherLeg.Takeoff - furtherLeg.LastStepTo).magnitude < 0.2 then
						furtherLeg.StepCycle = 0
					end
				end
			end
			fixFeetPositionsY()
		end
		
		local leftFootPosition,rightFootPosition = mLeftLeg.FootPosition,mRightLeg.FootPosition
		local footAngle = getBaseRotationY()
		local leftFootRotation = CFAngles(0,FOOT_ANGLE + footAngle,0)
		local rightFootRotation = CFAngles(0,-FOOT_ANGLE + footAngle,0)
		return CFnew(leftFootPosition) * leftFootRotation,CFnew(rightFootPosition) * rightFootRotation
	end
	
	function FootPlanterClass:OffsetFeet(Offset)
		overrideVelocityWithZero = true
		for _,leg in pairs(mLegs) do
			leg.FootPosition = leg.FootPosition + Offset
			leg.LastStepTo = leg.LastStepTo + Offset
			if leg.Takeoff then leg.Takeoff = leg.Takeoff + Offset end
			if leg.AheadStep then leg.AheadStep = leg.AheadStep + Offset end
		end
		overrideVelocityWithZero = true
	end
	
	return FootPlanterClass
end



return FootPlanter
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">Head</string>
            <string name="Source">--[[
TheNexusAvenger

Stores information about the head of a character.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent:WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Head = {}
Head.__index = Head
setmetatable(Head, Limb)



--[[
Creates a head.
--]]
function Head.new(HeadPart: BasePart): any
    local self = Limb.new()
    self.Head = HeadPart
    return setmetatable(self, Head)
end

--[[
Returns the offset from the head to
the location of the eyes.
--]]
function Head:GetEyesOffset(): CFrame
    return (self:GetAttachmentCFrame(self.Head, "FaceFrontAttachment") :: CFrame) * CFrame.new(0, (self.Head :: BasePart).Size.Y / 4, 0)
end

--[[
Returns the head CFrame for the
given VR input in global world space.
--]]
function Head:GetHeadCFrame(VRHeadCFrame: CFrame): CFrame
    return VRHeadCFrame * self:GetEyesOffset():Inverse()
end

--[[
Returns the neck CFrame for the
given VR input in global world space.
--]]
function Head:GetNeckCFrame(VRHeadCFrame: CFrame, TargetAngle: number?): CFrame
    --Get the base neck CFrame and angles.
    local BaseNeckCFrame = (self:GetHeadCFrame(VRHeadCFrame) :: CFrame) * (self:GetAttachmentCFrame(self.Head, "NeckRigAttachment") :: CFrame)
    local BaseNeckLookVector = BaseNeckCFrame.LookVector
    local BaseNeckLook,BaseNeckTilt = math.atan2(BaseNeckLookVector.X, BaseNeckLookVector.Z) + math.pi, math.asin(BaseNeckLookVector.Y)

    --Clamp the new neck tilt.
    local NewNeckTilt = 0
    local MaxNeckTilt = Settings:GetSetting("Appearance.MaxNeckTilt") or math.rad(60)
    if BaseNeckTilt > MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt - MaxNeckTilt
    elseif BaseNeckTilt &lt; -MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt + MaxNeckTilt
    end

    --Clamp the neck rotation if it is turning.
    if TargetAngle then
        --Determine the minimum angle difference.
        --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
        local RotationDifference = (BaseNeckLook - TargetAngle)
        while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
        while RotationDifference &lt; -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

        --Set the angle based on if it is over the limit or not.
        local MaxNeckSeatedRotation = Settings:GetSetting("Appearance.MaxNeckSeatedRotation") or math.rad(60)
        if RotationDifference > MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference - MaxNeckSeatedRotation
        elseif RotationDifference &lt; -MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference + MaxNeckSeatedRotation
        else
            BaseNeckLook = 0
        end
    else
        local MaxNeckRotation = Settings:GetSetting("Appearance.MaxNeckRotation") or math.rad(35)
        if self.LastNeckRotationGlobal then
            --Determine the minimum angle difference.
            --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
            local RotationDifference = (BaseNeckLook - self.LastNeckRotationGlobal)
            while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
            while RotationDifference &lt; -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

            --Set the angle based on if it is over the limit or not.
            --Ignore if there is no previous stored rotation or if the rotation is "big" (like teleporting).
            if math.abs(RotationDifference) &lt; 1.5 * MaxNeckRotation then
                if RotationDifference > MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook - MaxNeckRotation
                elseif RotationDifference &lt; -MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook + MaxNeckRotation
                else
                    BaseNeckLook = self.LastNeckRotationGlobal
                end
            end
        end
    end
    self.LastNeckRotationGlobal = BaseNeckLook

    --Return the new neck CFrame.
    return CFrame.new(BaseNeckCFrame.Position) * CFrame.Angles(0, BaseNeckLook, 0) * CFrame.Angles(NewNeckTilt, 0, 0)
end



return Head</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">Limb</string>
            <string name="Source">--[[
TheNexusAvenger

Base class for a limb.
--]]
--!strict

local Limb = {}
Limb.__index = Limb



--[[
Creates a limb object.
--]]
function Limb.new(): any
    return setmetatable({}, Limb)
end

--[[
Returns the CFrame of an attachment.
Returns an empty CFrame if the attachment
does not exist.
--]]
function Limb:GetAttachmentCFrame(Part: BasePart, AttachmentName: string): CFrame
    local Attachment = Part:FindFirstChild(AttachmentName)
    return Attachment and (Attachment :: Attachment).CFrame or CFrame.new()
end



return Limb</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">Torso</string>
            <string name="Source"><![CDATA[ --[[
TheNexusAvenger

Stores information about the torso of a character.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent:WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Torso = {}
Torso.__index = Torso
setmetatable(Torso, Limb)



--[[
Creates a torso.
--]]
function Torso.new(LowerTorso: BasePart, UpperTorso: BasePart): any
    local self = Limb.new()
    self.LowerTorso = LowerTorso
    self.UpperTorso = UpperTorso
    return setmetatable(self, Torso)
end

--[[
Returns the lower and upper torso CFrames
for the given neck CFrame in global world space.
--]]
function Torso:GetTorsoCFrames(NeckCFrame: CFrame): (CFrame, CFrame)
    --Determine the upper torso CFrame.
    local UpperTorsoCFrame = NeckCFrame * self:GetAttachmentCFrame(self.UpperTorso, "NeckRigAttachment"):Inverse()

    --Determine the center CFrame with bending.
    local MaxTorsoBend = Settings:GetSetting("Appearance.MaxTorsoBend") or math.rad(10)
    local NeckTilt = math.asin(NeckCFrame.LookVector.Y)
    local LowerTorsoAngle = math.sign(NeckTilt) * math.min(math.abs(NeckTilt), MaxTorsoBend)
    local TorsoCenterCFrame = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "WaistRigAttachment") * CFrame.Angles(-LowerTorsoAngle, 0, 0)

    --Return the lower and upper CFrames.
    return TorsoCenterCFrame * self:GetAttachmentCFrame(self.LowerTorso, "WaistRigAttachment"):Inverse(), UpperTorsoCFrame
end

--[[
Returns the CFrames of the joints for
the appendages.
--]]
function Torso:GetAppendageJointCFrames(LowerTorsoCFrame: CFrame, UpperTorsoCFrame: CFrame): {CFrame}
    return {
        RightShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "RightShoulderRigAttachment"),
        LeftShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "LeftShoulderRigAttachment"),
        LeftHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "LeftHipRigAttachment"),
        RightHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "RightHipRigAttachment"),
    }
end



return Torso]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="LocalScript" referent="20">
        <Properties>
          <string name="Name">NexusVRCharacterModelClientLoader</string>
          <string name="Source">--[[
TheNexusAvenger

Loads Nexus VR Character Model on the client.
--]]
--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService");

local NexusVRCharacterModel = ReplicatedStorage:WaitForChild("NexusVRCharacterModel") :: ModuleScript
local CameraService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")) :: any).GetInstance()
local CharacterService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")) :: any).GetInstance()
local ControlService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")) :: any).GetInstance()
local DefaultCursorService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")) :: any).GetInstance()
local Settings = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")) :: any).GetInstance()
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: RemoteEvent
local ReplicationReady = NexusVRCharacterModel:WaitForChild("ReplicationReady") :: RemoteEvent
local VirtualKeyboard;


--Load the settings.
Settings:SetDefaults(HttpService:JSONDecode((NexusVRCharacterModel:WaitForChild("Configuration") :: StringValue).Value))

--Connect replication for other players.
UpdateInputs.OnClientEvent:Connect(function(Player, HeadCFrame, LeftHandCFrame, RightHandCFrame)
    local Character = CharacterService:GetCharacter(Player)
    if Character then
        Character:UpdateFromInputs(HeadCFrame, LeftHandCFrame, RightHandCFrame)
    end
end)
ReplicationReady:FireServer()

--Allow checking if Nexus VR Character Model is loaded without being in VR.
local LoadedPrintStatementPrinted = false
UserInputService.InputBegan:Connect(function(Input)
    if not LoadedPrintStatementPrinted and Input.KeyCode == Enum.KeyCode.F9 and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) and Settings:GetSetting("Output.AllowClientToOutputLoadedMessage") ~= false then
        LoadedPrintStatementPrinted = true
        print("Nexus VR Character Model is loaded.")
    end
end)

--Wait for VR to be enabled.
while not UserInputService.VREnabled do
    UserInputService:GetPropertyChangedSignal("VREnabled"):Wait()
    warn("VR was detected later than when Nexus VR Character Model loaded. This may be a Roblox bug.")
end

--Disable the native VR controller models.
--Done in a pcall in case the SetCore is not registered or is removed.
task.spawn(function()
    for i = 1, 600 do
        local Worked = pcall(function()
            StarterGui:SetCore("VREnableControllerModels", false)
            DefaultCursorService:SetCursorState("Detect")
        end)
        if Worked then break end
        task.wait(0.1)
    end
end)

--Display a message if R6 is used.
local Character = Players.LocalPlayer.Character
while not Character do
    Character = Players.LocalPlayer.CharacterAdded:Wait()
end
if Character:WaitForChild("Humanoid").RigType == Enum.HumanoidRigType.R6 and not Settings:GetSetting("Appearance.ForceR15ForR6") then
    local R6Message = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("R6Message")) :: any).new()
    R6Message:Open()
    return
end

function CharAdded(char)
    Character = char;

    local remote = game:GetService("ReplicatedStorage"):WaitForChild("VREnabled")
    remote:FireServer();
    remote.OnClientEvent:Wait();

    Character = Players.LocalPlayer.Character; -- Make sure it's the correct char since we update on R6
end

Players.LocalPlayer.CharacterAdded:Connect(CharAdded)
CharAdded(Character)

--Set the initial controller and camera.
--Must happen before loading the settings in the main menu.
ControlService:SetActiveController(Settings:GetSetting("Movement.DefaultMovementMethod"))
CameraService:SetActiveCamera(Settings:GetSetting("Camera.DefaultCameraOption"))

--Load the menu.
local MainMenu = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")) :: any).GetInstance()
MainMenu:SetUpOpening()

if Settings:GetSetting("Appearance.FadeOutViewOnCollision") ~= nil then
    VRService.FadeOutViewOnCollision = Settings:GetSetting("Appearance.FadeOutViewOnCollision");
end

--Load the backpack.
if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
    task.defer(function()
        local NexusVRBackpack = require(ReplicatedStorage:WaitForChild("NexusVRBackpack")) :: {Load: (any) -> ()}
        NexusVRBackpack:Load()
    end)
end

-- Setup the keyboard
if Settings:GetSetting("Extra.VirtualKeyboard") ~= false then
    VirtualKeyboard = require(script.VirtualKeyboard);
end

--Start updating the VR character.
RunService:BindToRenderStep("NexusVRCharacterModelUpdate", Enum.RenderPriority.Camera.Value - 1, function()
    ControlService:UpdateCharacter()
end)</string>
        </Properties>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">VirtualKeyboard</string>
            <string name="Source"><![CDATA[--!nonstrict
-- VirtualKeyboard.lua --
-- Written by Kip Turner, copyright ROBLOX 2016 --


local CoreGui = game:GetService('CoreGui')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local GuiService = game:GetService('GuiService')
local HttpService = game:GetService('HttpService')
local ContextActionService = game:GetService('ContextActionService')
local PlayersService = game:GetService('Players')
local SoundService = game:GetService('SoundService')
local TextService = game:GetService('TextService')
local VRService = game:GetService("VRService");

local RobloxGui = PlayersService.LocalPlayer.PlayerGui--CoreGui:WaitForChild("RobloxGui")
local Util = require(script.Utility)

local BACKGROUND_OPACITY = 0.3
local NORMAL_KEY_COLOR = Color3.new(49/255,49/255,49/255)
local HOVER_KEY_COLOR = Color3.new(49/255,49/255,49/255)
local PRESSED_KEY_COLOR = Color3.new(0,162/255,1)
local SET_KEY_COLOR = Color3.new(0,162/255,1)

local KEY_TEXT_COLOR = Color3.new(1,1,1)
---------------------------------------- KEYBOARD LAYOUT --------------------------------------
local MINIMAL_KEYBOARD_LAYOUT = HttpService:JSONDecode([==[
[
  [
    {
      "a": 7,
      "w": 0.8
    },
    "*",
    "Q",
    "W",
    "E",
    "R",
    "T",
    "Y",
    "U",
    "I",
    "O",
    "P",
    {
      "w": 1.8
    },
    "Delete"
  ],
  [
    {
      "w": 1.6
    },
    "Caps",
    "A",
    "S",
    "D",
    "F",
    "G",
    "H",
    "J",
    "K",
    "L",
    "?",
    {
      "h": 2,
      "w2": 2.4,
      "h2": 1,
      "x2": -1.4,
      "y2": 1
    },
    "Enter"
  ],
  [
    {
      "w": 2.2
    },
    "Shift",
    "Z",
    "X",
    "C",
    "V",
    "B",
    "N",
    "M",
    "."
  ],
  [
    {
      "w": 2.2
    },
    "123/sym",
    {
      "w": 8
    },
    "",
    {
      "w": 2.4
    },
    "<Speaker>"
  ]
]
]==])

local MINIMAL_KEYBOARD_LAYOUT_SYMBOLS = HttpService:JSONDecode([==[
[
  [
    {
      "a": 7,
      "w": 0.8
    },
    "*",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    {
      "w": 1.8
    },
    "Delete"
  ],
  [
    {
      "w": 1.6
    },
    "!",
    "@",
    "#",
    "$",
    "%",
    "^",
    "&",
    "(",
    ")",
    "=",
    "?",
    {
      "h": 2,
      "w2": 2.4,
      "h2": 1,
      "x2": -1.4,
      "y2": 1
    },
    "Enter"
  ],
  [
    {
      "w": 1.2
    },
    "/",
    "-",
    "+",
    "_",
    ":",
    ";",
    "'",
    "\"",
    ",",
    "."
  ],
  [
    {
      "w": 2.2
    },
    "abc",
    {
      "w": 8
    },
    "",
    {
      "w": 2.4
    },
    "<Speaker>"
  ]
]
]==])


---------------------------------------- END KEYBOARD LAYOUT --------------------------------------

-- Kinda like a hack to force send a message ig???
local function sendChatMessage(textbox)
	local StarterGui = game:GetService('StarterGui')
	local A = false
	local ChatBar = textbox;
	A = StarterGui:GetCore('ChatActive')
	StarterGui:SetCore('ChatActive', true)
	ChatBar:CaptureFocus()
	ChatBar.Text = textbox.Text;
	ChatBar.TextEditable = false
	task.wait()
	ChatBar:ReleaseFocus(true)
	ChatBar.TextEditable = true
	task.wait()
	StarterGui:SetCore('ChatActive', A)
end


local VOICE_STATUS_CODE_ENUM = {}
do
	local STATUS_CODES =
		{
			'ASR_STATUS_OK',
			'ASR_STATUS_CANCELLED',
			'ASR_STATUS_UNKNOWN',
			'ASR_STATUS_INVALID_ARGUMENTS',
			'ASR_STATUS_DEADLINE_EXCEEDED',
			'ASR_STATUS_NOT_FOUND',
			'ASR_STATUS_ALREADY_EXISTS',
			'ASR_STATUS_PERMISSION_DENIED',
			'ASR_STATUS_UNAUTHENTICATED',
			'ASR_STATUS_RESOURCE_EXHAUSTED',
			'ASR_STATUS_FAILED_PRECONDITION',
			'ASR_STATUS_ABORTED',
			'ASR_STATUS_OUT_OF_RANGE',
			'ASR_STATUS_UNIMPLEMENTED',
			'ASR_STATUS_INTERNAL',
			'ASR_STATUS_UNAVAILABLE',
			'ASR_STATUS_DATA_LOSS',
			-- last official google response

			-- Roblox statuses
			'ASR_STATUS_NOT_ENABLED',
			'ASR_STATUS_LOW_CONFIDENCE',
			'ASR_STATUS_INVALID_JSON'
		};

	for i, code in pairs(STATUS_CODES) do
		VOICE_STATUS_CODE_ENUM[code] = i-1
	end
end

local function tokenizeString(str, tokenChar)
	local words = {}
	for word in string.gmatch(str, '([^' .. tokenChar .. ']+)') do
		table.insert(words, word)
	end
	return words
end

local function ConvertFontSizeEnumToInt(fontSizeEnum)
	local result = string.match(fontSizeEnum.Name, '%d+')
	return (result and tostring(result)) or 12
end


-- RayPlaneIntersection

-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
local function RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit
	-- compute Pn (dot) Rd = Vd and check if Vd == 0 then we know ray is parallel to plane
	local Vd = planeNormal:Dot(ray.Direction)

	-- could fuzzy equals this a little bit to account for imprecision or very close angles to zero
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd

	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

-- No rotation as of yet
local function PointInGuiObject(object, x, y)
	local minPt = object.AbsolutePosition
	local maxPt = object.AbsolutePosition + object.AbsoluteSize
	if minPt.X <= x and maxPt.X >= x and minPt.Y <= y and maxPt.Y >= y then
		return true
	end
	return false
end

local function FindAncestorOfType(object, ancestorType)
	if not object then return nil end

	local parent = object.Parent
	if parent and  parent:IsA(ancestorType) then
		return parent
	end

	return FindAncestorOfType(parent, ancestorType)
end

local function ExtendedInstance(instance)
	local this = {}
	do
		local mt =
			{
				__index = function (t, k)
					return instance[k]
				end;

				__newindex = function (t, k, v)
					instance[k] = v
				end;
			}
		setmetatable(this, mt)
	end
	return this
end

local function CreateVRButton(instance)
	local newButton = ExtendedInstance(instance)

	rawset(newButton, "OnEnter", function(self)
	end)
	rawset(newButton, "OnLeave", function(self)
	end)
	rawset(newButton, "OnDown", function(self)
	end)
	rawset(newButton, "OnUp", function(self)
	end)
	rawset(newButton, "ContainsPoint", function(self, x, y)
		return PointInGuiObject(instance, x, y)
	end)
	rawset(newButton, "Update", function(self)
	end)

	return newButton
end

local selectionRing = Util:Create'ImageLabel'
{
	Name = 'SelectionRing';
	Size = UDim2.new(1, -6, 1, -6);
	Position = UDim2.new(0, 4, 0, 3);
	Image = 'rbxasset://textures/ui/menu/buttonHover.png';
	ScaleType = Enum.ScaleType.Slice;
	SliceCenter = Rect.new(94/2, 94/2, 94/2, 94/2);
	BackgroundTransparency = 1;
}

local KEY_ICONS =
	{
		["<Speaker>"] = {Asset = "rbxasset://textures/ui/Keyboard/mic_icon.png", AspectRatio = 0.615};
	}

local function CreateKeyboardKey(keyboard, layoutData, keyData)
	local isSpecialShapeKey = layoutData['width2'] and layoutData['height2'] and layoutData['x2'] and layoutData['y2']

	local newKeyElement = Util:Create'ImageButton'
	{
		Name = keyData[1];
		Position = UDim2.new(layoutData['x'], 0, layoutData['y'], 0);
		Size = UDim2.new(layoutData['width'], 0, layoutData['height'], 0);
		BorderSizePixel = 0;
		Image = "";
		BackgroundTransparency = 1;
		ZIndex = 1;
	}
	local keyText = Util:Create'TextLabel'
	{
		Name = "KeyText";
		Text = keyData[#keyData];
		Position = UDim2.new(0, -10, 0, -10);
		Size = UDim2.new(1, 0, 1, 0);
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size96;
		TextColor3 = KEY_TEXT_COLOR;
		BackgroundTransparency = 1;
		Selectable = true;
		ZIndex = 2;
		Parent = newKeyElement;
	}
	local backgroundImage = Util:Create'Frame'
	{
		Name = 'KeyBackground';
		Size = UDim2.new(1,-10,1,-10);
		Position = UDim2.new(0,-5,0,-5);
		BackgroundColor3 = NORMAL_KEY_COLOR;
		BackgroundTransparency = BACKGROUND_OPACITY;
		BorderSizePixel = 0;
		Parent = newKeyElement;
	}

	local selectionObject = Util:Create'ImageLabel'
	{
		Name = 'SelectionObject';
		Size = UDim2.new(1,0,1,0);
		BackgroundTransparency = 1;
		Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png";
		ImageTransparency = 0;
		ScaleType = Enum.ScaleType.Slice;
		SliceCenter = Rect.new(12,12,52,52);
		BorderSizePixel = 0;
	}

	newKeyElement.SelectionImageObject = Util:Create'ImageLabel'
	{
		Visible = false;
	}

	-- Special silly enter key nonsense
	local secondBackgroundImage = nil
	local specialSelectionObject, specialSelectionObject2, specialSelectionObject3 = nil, nil, nil
	if isSpecialShapeKey then
		secondBackgroundImage = Util:Create'ImageButton'
		{
			Name = 'KeyBackground';
			Position = UDim2.new(layoutData['x2'] / layoutData['width'], -5, layoutData['y2'] / layoutData['height'], -5);
			Size = UDim2.new(layoutData['width2'] / layoutData['width'], 0, layoutData['height2'] / layoutData['height'], -10);
			BackgroundColor3 = NORMAL_KEY_COLOR;
			BackgroundTransparency = BACKGROUND_OPACITY;
			BorderSizePixel = 0;
			AutoButtonColor = false;
			SelectionImageObject = newKeyElement.SelectionImageObject;
			Parent = newKeyElement;
		}
		if layoutData['x2'] <= 0 then
			keyText.Size = secondBackgroundImage.Size - UDim2.new(0,10,0,0)
			keyText.Position = secondBackgroundImage.Position
			secondBackgroundImage.Size = secondBackgroundImage.Size - UDim2.new(1,0,0,0)
		end

		do
			specialSelectionObject = Util:Create'Frame'
			{
				Name = 'SpecialSelectionObject';
				Size = UDim2.new(1,0,0.5,0);
				Position = UDim2.new(0,0,0.5,0);
				BackgroundTransparency = 1;
				ClipsDescendants = true;
				Util:Create'ImageLabel'
				{
					Name = 'Borders';
					Position = UDim2.new(-1,0,-1,0);
					Size = UDim2.new(2,0,2,0);
					BackgroundTransparency = 1;
					Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png";
					ImageTransparency = 0;
					ScaleType = Enum.ScaleType.Slice;
					SliceCenter = Rect.new(12,12,52,52);
				};
			}
			specialSelectionObject2 = specialSelectionObject:Clone()
			specialSelectionObject2.Size = UDim2.new(1,0,0.5,5)
			specialSelectionObject2.Position = UDim2.new(0,0,0,0)
			specialSelectionObject2.Borders.Size = UDim2.new(1,0,1,30)
			specialSelectionObject2.Borders.Position = UDim2.new(0,0,0,0)

			specialSelectionObject3 = specialSelectionObject:Clone()
			specialSelectionObject3.Size = UDim2.new(1,5,1,0)
			specialSelectionObject3.Position = UDim2.new(0,0,0,0)
			specialSelectionObject3.Borders.Size = UDim2.new(1,30,1,0)
			specialSelectionObject3.Borders.Position = UDim2.new(0,0,0,0)
		end
		-- End of nonsense
	end

	local newKey = CreateVRButton(newKeyElement)

	local hovering = false
	local pressed = false
	local isAlpha = #keyData == 1 and type(keyData[1]) == 'string' and #keyData[1] == 1 and
		string.byte(keyData[1]) >= string.byte("A") and string.byte(keyData[1]) <= string.byte("z")

	local icon = nil
	if keyData[1] and KEY_ICONS[keyData[1]] then
		keyText.Visible = false
		icon = Util:Create'ImageLabel'
		{
			Name = 'KeyIcon';
			Size = UDim2.new(KEY_ICONS[keyData[1]].AspectRatio, -20, 1, -20);
			SizeConstraint = Enum.SizeConstraint.RelativeYY;
			BackgroundTransparency = 1;
			Image = KEY_ICONS[keyData[1]].Asset;
			Parent = backgroundImage;
		}

		local function onChanged(prop)
			if prop == 'AbsoluteSize' then
				icon.Position = UDim2.new(0.5,-icon.AbsoluteSize.X/2,0.5,-icon.AbsoluteSize.Y/2);
			end
		end
		icon.Changed:connect(onChanged)
		onChanged('AbsoluteSize')
	end

	local function onClicked()
		local keyValue = nil
		local currentKeySetting = newKey:GetCurrentKeyValue()

		if currentKeySetting == 'Shift' then
			keyboard:SetShift(not keyboard:GetShift())
		elseif currentKeySetting == 'Caps' then
			keyboard:SetCaps(not keyboard:GetCaps())
		elseif currentKeySetting == 'Enter' then
			keyboard:SubmitText(true, false)
		elseif currentKeySetting == 'Delete' then
			keyboard:BackspaceAtCursor()
		elseif currentKeySetting == "123/sym" then
			keyboard:SetCurrentKeyset(2)
		elseif currentKeySetting == "abc" then
			keyboard:SetCurrentKeyset(1)
		elseif currentKeySetting == "<Speaker>" then
			keyboard:SetVoiceMode(true)
		elseif currentKeySetting == 'Tab' then
			keyValue = '\t'
		else
			keyValue = currentKeySetting
		end

		if keyValue ~= nil then
			keyboard:SubmitCharacter(keyValue, isAlpha)
		end
	end

	local function setKeyColor(newColor, hovering)
		backgroundImage.BackgroundColor3 = newColor
		if secondBackgroundImage then
			secondBackgroundImage.BackgroundColor3 = newColor
		end
		if isSpecialShapeKey then
			specialSelectionObject.Parent = hovering and backgroundImage or nil
			specialSelectionObject2.Parent = hovering and backgroundImage or nil
			specialSelectionObject3.Parent = hovering and secondBackgroundImage or nil
		else
			selectionObject.Parent = hovering and backgroundImage or nil
		end
	end

	local function update()
		local currentKey = newKey:GetCurrentKeyValue()

		if pressed then
			setKeyColor(PRESSED_KEY_COLOR, false)
		elseif hovering then
			setKeyColor(HOVER_KEY_COLOR, true)
		elseif currentKey == 'Caps' and keyboard:GetCaps() then
			setKeyColor(SET_KEY_COLOR, false)
		elseif currentKey == 'Shift' and keyboard:GetShift() then
			setKeyColor(SET_KEY_COLOR, false)
		elseif currentKey == 'abc' then
			setKeyColor(SET_KEY_COLOR, false)
		else
			setKeyColor(NORMAL_KEY_COLOR, false)
		end

		if icon then
			icon.ImageTransparency = 0.5
		end

		keyText.Text = newKey:GetCurrentKeyValue()
	end

	local hoveringGuiElements = {}

	rawset(newKey, "OnEnter", function(self)
		hovering = true
		update()
	end)
	rawset(newKey, "OnLeave", function(self)
		if not next(hoveringGuiElements) then
			hovering = false
			pressed = false
			update()
		end
	end)
	rawset(newKey, "OnDown", function(self)
		if pressed then return end;
		pressed = true
		update()
		-- Fire the onclick when pressing down on the button;
		-- pressing down and up on the same button is difficult
		-- in VR because your head is constantly moving around
		onClicked()
	end)
	rawset(newKey, "OnUp", function(self)
		pressed = false
		update()
	end)
	rawset(newKey, "GetCurrentKeyValue", function(self)
		local shiftEnabled = keyboard:GetShift()
		local capsEnabled = keyboard:GetCaps()

		if isAlpha then
			if capsEnabled and shiftEnabled then
				return string.lower(keyData[#keyData])
			elseif capsEnabled or shiftEnabled then
				return keyData[1]
			else
				return string.lower(keyData[#keyData])
			end
		end

		if shiftEnabled then
			return keyData[1]
		end

		return keyData[#keyData]
	end)
	rawset(newKey, "ContainsPoint", function(self, x, y)
		return PointInGuiObject(backgroundImage, x, y) or
			(secondBackgroundImage and PointInGuiObject(secondBackgroundImage, x, y))
	end)
	rawset(newKey, "Update", function(self)
		update()
	end)
	rawset(newKey, "GetInstance", function(self)
		return newKeyElement
	end)

	newKeyElement.MouseButton1Down:connect(function() newKey:OnDown() end)
	newKeyElement.MouseButton1Up:connect(function() newKey:OnUp() end)
	newKeyElement.SelectionGained:connect(function() hoveringGuiElements[newKeyElement] = true newKey:OnEnter() end)
	newKeyElement.SelectionLost:connect(function() hoveringGuiElements[newKeyElement] = nil newKey:OnLeave() end)
	-- For the time being, we will simulate onClick events in the OnDown() event
	-- newKeyElement.MouseButton1Click:connect(function() onClicked() end)
	if secondBackgroundImage then
		-- For the time being, we will simulate onClick events in the OnDown() event
		-- secondBackgroundImage.MouseButton1Click:connect(onClicked)
		secondBackgroundImage.MouseButton1Down:connect(function() newKey:OnDown() end)
		secondBackgroundImage.MouseButton1Up:connect(function() newKey:OnUp() end)
		secondBackgroundImage.SelectionGained:connect(function()
			hoveringGuiElements[secondBackgroundImage] = true
			newKey:OnEnter()
		end)
		secondBackgroundImage.SelectionLost:connect(function()
			hoveringGuiElements[secondBackgroundImage] = nil
			newKey:OnLeave()
		end)
	end

	update()

	return newKey
end

local function CreateBaseVoiceState()
	local this = {}
	this.Name = "Base"

	function this:TransitionFrom()
	end
	function this:TransitionTo()
	end

	return this
end

local function CreateListeningVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Listening"

	function this:TransitionTo()
		pcall(function() SoundService:BeginRecording() end)
	end

	return this
end

local function CreateProcessingVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Processing"

	local finished = false
	local result = nil

	function this:TransitionTo()
		coroutine.wrap(function()
			pcall(function() result = SoundService:EndRecording() end)
			finished = true
		end)()
	end

	function this:GetResultAsync()
		while not finished do
			wait()
		end
		return result
	end

	return this
end

local function CreateWaitingVoiceState()
	local this = CreateBaseVoiceState()

	this.Name = "Waiting"

	return this
end

local VoiceTransitions = {Listening = {Processing = true}, Processing = {Waiting = true}, Waiting = {Listening = true}}

local VoiceToTextFSM = {}
do
	VoiceToTextFSM.CurrentState = CreateWaitingVoiceState()

	local stateTransitionedSignal = Instance.new('BindableEvent')

	function VoiceToTextFSM:TransitionState(newState)
		-- If it is a new state then lets cleanup and activate it
		if VoiceTransitions[self.CurrentState.Name][newState.Name] then
			self.CurrentState:TransitionFrom()
			self.CurrentState = newState
			self.CurrentState:TransitionTo()
			stateTransitionedSignal:Fire(self.CurrentState)
			return true
		end
		return false
	end

	function VoiceToTextFSM:GetCurrentState()
		return self.CurrentState
	end

	VoiceToTextFSM.StateTransitionedEvent = stateTransitionedSignal.Event
end



local function ConstructKeyboardUI(keyboardLayoutDefinitions)
	--local KeyboardSurface : SurfaceGui = RobloxGui:FindFirstChild("VR_Keyboard");
	--if KeyboardSurface then KeyboardSurface:Destroy() end;
	--KeyboardSurface = Instance.new("SurfaceGui", RobloxGui);
	--KeyboardSurface.Name = "VR_Keyboard";
	--KeyboardSurface.AlwaysOnTop = true;
	--KeyboardSurface.Enabled = false;
	
	local Panel3D = require(script.Panel3D)
	local panel = Panel3D.Get("Keyboard")
	panel:SetVisible(false)
	--KeyboardGui = panel:GetGUI()
	
	--KeyboardSurface.Adornee = panel;
	--KeyboardGui = KeyboardSurface;

	local buttons = {}

	local keyboardContainer = Util:Create'Frame'
	{
		Name = 'VirtualKeyboard';
		Size = UDim2.new(1, 0, 1, 0);
		Position = UDim2.new(0, 0, 0, 0);
		BackgroundTransparency = 1;
		Active = true;
		Visible = false;
	};

	local textEntryBackground = Util:Create'ImageLabel'
	{
		Name = 'TextEntryBackground';
		Size = UDim2.new(0.5,0,0.125,0);
		Position = UDim2.new(0.25,0,0,0);
		Image = "";
		BackgroundTransparency = 0.5;
		BackgroundColor3 = Color3.new(31/255,31/255,31/255);
		BorderSizePixel = 0;
		ClipsDescendants = true;
		Parent = keyboardContainer;
	}
	local textfieldBackground = Util:Create'Frame'
	{
		Name = 'TextfieldBackground';
		Position = UDim2.new(0,2,0,2);
		Size = UDim2.new(1, -4, 1, -4);
		BackgroundTransparency = 0;
		BackgroundColor3 = Color3.new(209/255,216/255,221/255);
		BorderSizePixel = 0;
		Visible = true;
		Parent = textEntryBackground;
	};
	local textEntryField = Util:Create'TextButton'
	{
		Name = "TextEntryField";
		Text = "";
		Position = UDim2.new(0,4,0,4);
		Size = UDim2.new(1, -8, 1, -8);
		Font = Enum.Font.SourceSans;
		FontSize = Enum.FontSize.Size60;
		TextXAlignment = Enum.TextXAlignment.Left;
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		Parent = textfieldBackground;
	}
	local textfieldCursor = Util:Create'Frame'
	{
		Name = 'TextfieldCursor';
		Size = UDim2.new(0, 5, 0.9, 0);
		Position = UDim2.new(0, 0, 0.05, 0);
		BackgroundTransparency = 0;
		BackgroundColor3 = SET_KEY_COLOR;
		BorderSizePixel = 0;
		Visible = true;
		ZIndex = 2;
		Parent = textEntryField;
	};

	local closeButtonElement = Util:Create'ImageButton'
	{
		Name = 'CloseButton';
		Size = UDim2.new(0.075,-10,0.198,-10);
		Position = UDim2.new(0,-5,0,-35);
		Image = "rbxasset://textures/ui/Keyboard/close_button_background.png";
		BackgroundTransparency = 1;
		AutoButtonColor = false;
		Parent = keyboardContainer;
	}
	do
		closeButtonElement.SelectionImageObject = Util:Create'ImageLabel'
		{
			Name = 'Selection';
			Size = UDim2.new(0.9,0,0.9,0);
			Position = UDim2.new(0.05,0,0.05,0);
			Image = "rbxasset://textures/ui/Keyboard/close_button_selection.png";
			BackgroundTransparency = 1;
		}
		Util:Create'ImageLabel'
		{
			Name = 'Icon';
			Size = UDim2.new(0.5,0,0.5,0);
			Position = UDim2.new(0.25,0,0.25,0);
			Image = "rbxasset://textures/ui/Keyboard/close_button_icon.png";
			BackgroundTransparency = 1;
			Parent = closeButtonElement;
		}
	end
	local closeButton = CreateVRButton(closeButtonElement)
	table.insert(buttons, closeButton)

	local voiceRecognitionContainer = Util:Create'Frame'
	{
		Name = 'VoiceRecognitionContainer';
		Size = UDim2.new(1, 0, 0.85, 0);
		Position = UDim2.new(0, 0, 0.15, 0);
		BackgroundTransparency = 1;
		Active = true;
		Visible = false;
		Parent = keyboardContainer;
	};
	do
		local voiceRecognitionBackground1 = Util:Create'Frame'
		{
			Name = 'voiceRecognitionBackground1';
			Size = UDim2.new(1, 0, 0.75, 0);
			Position = UDim2.new(0, 0, 0, 0);
			BackgroundColor3 = NORMAL_KEY_COLOR;
			BackgroundTransparency = BACKGROUND_OPACITY;
			BorderSizePixel = 0;
			Active = true;
			Parent = voiceRecognitionContainer;
		};
		local voiceRecognitionBackground2 = voiceRecognitionBackground1:Clone()
		voiceRecognitionBackground2.Size = UDim2.new(1 - 0.2, 0, 0.25, 0)
		voiceRecognitionBackground2.Position = UDim2.new(0, 0, 0.75, 0)
		voiceRecognitionBackground2.Parent = voiceRecognitionContainer
	end

	local voiceDoneButton = CreateVRButton(Util:Create'TextButton'
		{
			Name = 'DoneButton';
			Size = UDim2.new(0.2, -5, 0.25, -5);
			Position = UDim2.new(1 - 0.2, 5, 0.75, 5);
			Text = "Done";
			BackgroundColor3 = SET_KEY_COLOR;
			Font = Enum.Font.SourceSansBold;
			FontSize = Enum.FontSize.Size96;
			TextColor3 = KEY_TEXT_COLOR;
			BackgroundTransparency = 0;
			AutoButtonColor = false;
			BorderSizePixel = 0;
			Parent = voiceRecognitionContainer;
		})
	table.insert(buttons, voiceDoneButton)

	local voiceProcessingStatus = Util:Create'TextLabel'
	{
		Name = 'VoiceProcessingStatus';
		Size = UDim2.new(0, 0, 0, 0);
		Position = UDim2.new(0.5, 0, 0.33, 0);
		Text = "";
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size96;
		TextColor3 = KEY_TEXT_COLOR;
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		Parent = voiceRecognitionContainer;
	}

	local function CreateVoiceVisualizerWidget()
		local this = {}

		local bars = {}

		local numOfBars = 50
		local numOfWaves = 4
		local waveSpeed = 2.5

		local container = Util:Create'Frame'
		{
			Name = 'VoiceVisualizerContainer';
			Size = UDim2.new(1, 0, 1, 0);
			BackgroundTransparency = 1;
		}
		this.Container = container

		for i = 1, numOfBars do
			local bar = Util:Create'Frame'
			{
				Name = 'Bar';
				Size = UDim2.new(1/numOfBars, -4, 1, 0);
				Position = UDim2.new(i/numOfBars, 0, 0, 0);
				BackgroundTransparency = 0;
				BackgroundColor3 = KEY_TEXT_COLOR;
				Parent = container;
			}
			table.insert(bars, bar)
		end

		function this:StartAnimation()
			RunService:UnbindFromRenderStep("VoiceVisualizerWidget")
			RunService:BindToRenderStep("VoiceVisualizerWidget", Enum.RenderPriority.First.Value,
				function()
					local movementPerBar = (numOfWaves*2*math.pi) / numOfBars
					for i, bar in pairs(bars) do
						local height = math.abs(math.sin(tick() * waveSpeed + i * movementPerBar)) + math.abs(math.cos(tick() * waveSpeed + i * movementPerBar))
						height = ((height / 2) - 0.3) * (1/(1-0.3))
						bar.Size = UDim2.new(1/numOfBars, -4, height, 0)
						bar.Position = UDim2.new(i/numOfBars, 0, (1-height) / 2, 0)
					end
				end)
		end

		function this:StopAnimation()
			RunService:UnbindFromRenderStep("VoiceVisualizerWidget")
		end

		return this
	end

	local voiceVisualizer = CreateVoiceVisualizerWidget()
	voiceVisualizer.Container.Parent = voiceRecognitionContainer
	voiceVisualizer.Container.Size = UDim2.new(0.5,0,0.4,0)
	voiceVisualizer.Container.Position = UDim2.new(0.25,0,0.4,0)

	local newKeyboard = ExtendedInstance(keyboardContainer)

	local keyboardOptions = nil
	local keysets = {}

	local capsLockEnabled = false
	local shiftEnabled = false

	local textfieldCursorPosition = 0

	local openedEvent = Instance.new('BindableEvent')
	local closedEvent = Instance.new('BindableEvent')
	local opened = false

	local function SetTextFieldCursorPosition(newPosition)
		textfieldCursorPosition = Clamp(0, #textEntryField.Text, newPosition)
		if not textEntryField.TextFits then
			textfieldCursorPosition = #textEntryField.Text
		end

		local textSize = TextService:GetTextSize(
			string.sub(textEntryField.Text, 1, textfieldCursorPosition),
			ConvertFontSizeEnumToInt(textEntryField.FontSize),
			textEntryField.Font,
			textEntryField.AbsoluteSize)
		textfieldCursor.Position = UDim2.new(0, textSize.x, textfieldCursor.Position.Y.Scale, textfieldCursor.Position.Y.Offset)
	end

	local function UpdateTextEntryFieldText(newText)
		textEntryField.Text = newText
		SetTextFieldCursorPosition(textfieldCursorPosition)
	end

	local buffer = ""
	local function getBufferText()
		if keyboardOptions and keyboardOptions.TextBox then
			return keyboardOptions.TextBox.Text
		end
		return buffer
	end
	local function setBufferText(newBufferText)
		if keyboardOptions and keyboardOptions.TextBox then
			keyboardOptions.TextBox.Text = newBufferText
		elseif buffer ~= newBufferText then
			buffer = newBufferText
			UpdateTextEntryFieldText(buffer)
		end
	end

	local function calculateTextCursorPosition(x, y)
		x = x - textEntryField.AbsolutePosition.x
		y = y - textEntryField.AbsolutePosition.y

		for i = 1, #textEntryField.Text do
			local textSize = TextService:GetTextSize(
				string.sub(textEntryField.Text, 1, i),
				ConvertFontSizeEnumToInt(textEntryField.FontSize),
				textEntryField.Font,
				textEntryField.AbsoluteSize)
			if textSize.x > x then
				return i - 1
			end
		end

		return #textEntryField.Text
	end

	local currentKeyset = nil

	rawset(newKeyboard, "OpenedEvent",  openedEvent.Event)
	rawset(newKeyboard, "ClosedEvent",  closedEvent.Event)

	rawset(newKeyboard, "GetCurrentKeyset", function(self)
		return keysets[currentKeyset]
	end)

	rawset(newKeyboard, "SetCurrentKeyset", function(self, newKeyset)
		if newKeyset ~= currentKeyset and keysets[newKeyset] ~= nil then
			if keysets[currentKeyset] and keysets[currentKeyset].container then
				keysets[currentKeyset].container.Visible = false
			end

			currentKeyset = newKeyset

			if keysets[currentKeyset] and keysets[currentKeyset].container then
				keysets[currentKeyset].container.Visible = true
			end
		end
	end)

	rawset(newKeyboard, "SetVoiceMode", function(self, inVoiceMode)
		-- current Speech to Text solution is no longer enabled. If we find a new service provider we can hook it up through here
		inVoiceMode = false  

		local currentKeysetObject = self:GetCurrentKeyset()
		if currentKeysetObject and currentKeysetObject.container then
			currentKeysetObject.container.Visible = not inVoiceMode
		end

		voiceRecognitionContainer.Visible = inVoiceMode

		if inVoiceMode then
			VoiceToTextFSM:TransitionState(CreateListeningVoiceState())
		end
	end)

	rawset(newKeyboard, "GetCaps", function(self)
		return capsLockEnabled
	end)

	rawset(newKeyboard, "SetCaps", function(self, newCaps)
		capsLockEnabled = newCaps
		for _, key in pairs(self:GetCurrentKeyset().keys) do
			key:Update()
		end
	end)

	rawset(newKeyboard, "GetShift", function(self)
		return shiftEnabled
	end)

	rawset(newKeyboard, "SetShift", function(self, newShift)
		shiftEnabled = newShift
		for _, key in pairs(self:GetCurrentKeyset().keys) do
			key:Update()
		end
	end)

	local ignoreFocusedLost = false

	local textChangedConn = nil
	local textBoxFocusLostConn = nil
	local panelClosedConn = nil

	local function disconnectKeyboardEvents()
		if textChangedConn then textChangedConn:disconnect() end
		textChangedConn = nil
		if textBoxFocusLostConn then textBoxFocusLostConn:disconnect() end
		textBoxFocusLostConn = nil
		if panelClosedConn then panelClosedConn:disconnect() end
		panelClosedConn = nil
	end

	rawset(newKeyboard, "Open", function(self, options)
		if opened then return end
		opened = true

		keyboardOptions = options

		self:SetCurrentKeyset(1)
		self:SetVoiceMode(false)
		keyboardContainer.Visible = true

		panel:ResizeStuds(5.9, 2.25, 320)

		local localCF = CFrame.new()

		disconnectKeyboardEvents()
		if options.TextBox then
			textChangedConn = options.TextBox.Changed:connect(function(prop)
				if prop == 'Text' then
					UpdateTextEntryFieldText(options.TextBox.Text)
				end
			end)
			textBoxFocusLostConn = options.TextBox.FocusLost:connect(function(submitted)
				--if not ignoreFocusedLost then
				if submitted == true then
					self:Close(submitted)
				end
			end)
			if options.TextBox.ClearTextOnFocus then
				setBufferText("")
			else
				UpdateTextEntryFieldText(options.TextBox.Text)
			end

			-- Find panel for 2d ui?
			local textboxPanel = Panel3D.FindContainerOf(options.TextBox)
			if textboxPanel then
				panelClosedConn = Panel3D.OnPanelClosed.Event:connect(function(closedPanelName)
					if closedPanelName == textboxPanel.name then
						self:Close(false)
					end
				end)

				local textboxPosition = options.TextBox.AbsolutePosition + (Vector2.new(0.5, 1) * options.TextBox.AbsoluteSize)
				local panelCF = textboxPanel:GetCFrameInCameraSpace()
				localCF = panelCF * CFrame.new(textboxPanel:GetGuiPositionInPanelSpace(textboxPosition)) * CFrame.new(0, -panel.height * 0.65, 0.5) * CFrame.Angles(math.rad(-22.5), 0, 0)
			else -- no panel!
				local headForwardCF = Panel3D.GetHeadLookXZ(true)
				localCF = headForwardCF * CFrame.Angles(math.rad(22.5), 0, 0) * CFrame.new(0, -1, -5)
			end
		else
			setBufferText("")
		end
	
		ContextActionService:BindActionAtPriority("VirtualKeyboardControllerInput",
			function(actionName, inputState, inputObject)
				if inputState == Enum.UserInputState.End then
					if inputObject.KeyCode == Enum.KeyCode.ButtonL1 then
						SetTextFieldCursorPosition(textfieldCursorPosition - 1)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonR1 then
						SetTextFieldCursorPosition(textfieldCursorPosition + 1)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonX then
						self:BackspaceAtCursor()
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonY then
						self:SubmitCharacter(" ", false)
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonL2 then
						if currentKeyset then
							-- Go to the next keyset
							self:SetCurrentKeyset((currentKeyset % #keysets) + 1)
						end
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonL3 then
						self:SetCaps(not self:GetCaps())
					elseif inputObject.KeyCode == Enum.KeyCode.ButtonB then
						self:Close(false)
					end
				end
			end,
			false,
			3000,
			Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1, Enum.KeyCode.ButtonL2, Enum.KeyCode.ButtonL3, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonB)

		self.Parent = panel:GetGUI()
		
		panel:SetCanFade(false)
		panel:SetVisible(true, true)
		panel:ForceShowUntilLookedAt()
		
		-- Taken from NexusVRCore BaseScreenGui and ScreenGui3D
		local Easing = 0;--0.15;
		local LastRotation = CFrame.new();
		local Depth = 5;
		
		function panel:PreUpdate(cameraCF : CFrame, cameraRenderCF : CFrame, userHeadCF : CFrame, lookRay : Ray, DeltaTime)
			DeltaTime = DeltaTime or self.Easing
			
			--Update the rotation.
			local TargetCFrame = CFrame.new(Vector3.new(0, 0, -(panel.height * panel.width) * 0.35));
			if Easing == 0 then
				LastRotation = TargetCFrame
			else
				LastRotation = LastRotation:Lerp(TargetCFrame, DeltaTime / Easing)
			end
			
			--Set the CFrame
			panel:SetType(Panel3D.Type.FixedToHead, { CFrame = LastRotation; })
		end

		openedEvent:Fire()
	end)

	rawset(newKeyboard, "Close", function(self, submit)
		submit = (submit == true)

		if not opened then return end
		opened = false
		
		function panel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay, dt)
			
		end
		
		disconnectKeyboardEvents()

		ContextActionService:UnbindAction("VirtualKeyboardControllerInput")
		-- Clean-up
		panel:OnMouseLeave()
		panel:SetVisible(false, true)
		keyboardContainer.Visible = false

		Panel3D.Get("Topbar3D"):SetVisible(true)

		self:SubmitText(submit, false)
		closedEvent:Fire()
	end)

	rawset(newKeyboard, "SubmitText", function(self, submit, keepKeyboardOpen)
		local keyboardTextbox = keyboardOptions and keyboardOptions.TextBox
		if keyboardTextbox then
			if keyboardTextbox.Name == "ChatBar" then sendChatMessage(keyboardTextbox); return; end
			if submit then
				keyboardTextbox.Text = getBufferText()
			end
			-- Only keep text boxes open for coreguis, such as chat
			local textboxPanel = Panel3D.FindContainerOf(keyboardTextbox)
			local reopenKeyboard = keepKeyboardOpen and textboxPanel and textboxPanel.linkedTo == panel

			if reopenKeyboard then
				ignoreFocusedLost = true
			end

			keyboardTextbox:ReleaseFocus(submit)

			if reopenKeyboard then
				keyboardTextbox:CaptureFocus()
				ignoreFocusedLost = false
			end
		end
	end)

	rawset(newKeyboard, "GetCurrentOptions", function(self)
		return keyboardOptions
	end)

	rawset(newKeyboard, "BackspaceAtCursor", function(self)
		if textfieldCursorPosition >= 1 then
			local bufferText = getBufferText()
			local newBufferText = string.sub(bufferText, 1, textfieldCursorPosition - 1) .. string.sub(bufferText, textfieldCursorPosition + 1, #bufferText)
			local newCursorPosition = textfieldCursorPosition - 1
			setBufferText(newBufferText)
			SetTextFieldCursorPosition(newCursorPosition)
		end
	end)

	rawset(newKeyboard, "SubmitCharacter", function(self, character, isAnAlphaKey)
		local bufferText = getBufferText()
		local newBufferText = string.sub(bufferText, 1, textfieldCursorPosition) .. character .. string.sub(bufferText, textfieldCursorPosition + 1, #bufferText)
		setBufferText(newBufferText)
		SetTextFieldCursorPosition(textfieldCursorPosition + #character)
		
		--print(character, isAnAlphaKey, "old:", bufferText, "new:", newBufferText)
		
		if isAnAlphaKey and self:GetShift() then
			self:SetShift(false)
		end
	end)

	do -- Parse input definition
		for _, keyboardKeyset in pairs(keyboardLayoutDefinitions) do
			local keys = {}
			local keyboardSizeConstrainer = Util:Create'Frame'
			{
				Name = 'KeyboardSizeConstrainer';
				Size = UDim2.new(1, 0, 1, -20);
				Position = UDim2.new(0, 0, 0, 20);
				BackgroundTransparency = 1;
				Parent = keyboardContainer;
			};

			local maxWidth = 0
			local maxHeight = 0
			local y = 0
			for rowNum, rowData in pairs(keyboardKeyset) do
				local x = 0
				local width = 1
				local height = 1
				local width2, height2, x2, y2;
				for columnNum, columnData in pairs(rowData) do
					if type(columnData) == 'table' then
						if columnData['w'] then width = columnData['w'] end
						if columnData['h'] then height = columnData['h'] end
						if columnData['x'] then x = x + columnData['x'] end
						if columnData['y'] then y = y + columnData['y'] end
						if columnData['x2'] then x2 = columnData['x2'] end
						if columnData['y2'] then y2 = columnData['y2'] end
						if columnData['w2'] then width2 = columnData['w2'] end
						if columnData['h2'] then height2 = columnData['h2'] end
					elseif type(columnData) == 'string' then
						if columnData == "" then
							columnData = " "
						end
						-- put key
						local key = CreateKeyboardKey(
							newKeyboard,
							{x = x, y = y, width = width, height = height, x2 = x2, y2 = y2, width2 = width2, height2 = height2},
							tokenizeString(columnData, '\n'))
						table.insert(keys, key)

						x = x + width
						maxWidth = math.max(maxWidth, x)
						maxHeight = math.max(maxHeight, y + height)
						-- reset for the next key
						width = 1
						height = 1
						width2, height2, x2, y2 = nil, nil, nil, nil
					end
				end
				y = y + 1
			end

			-- Fix the positions and sizes to fit in our KeyboardContainer
			for _, element in pairs(keys) do
				element.Position = UDim2.new(element.Position.X.Scale / maxWidth, 0, element.Position.Y.Scale / maxHeight, 0)
				element.Size = UDim2.new(element.Size.X.Scale / maxWidth, 0, element.Size.Y.Scale / maxHeight, 0)
				element.Parent = keyboardSizeConstrainer
			end

			keyboardSizeConstrainer.SizeConstraint = Enum.SizeConstraint.RelativeXX
			keyboardSizeConstrainer.Size = UDim2.new(1, 0, -maxHeight / maxWidth, 0)
			keyboardSizeConstrainer.Position = UDim2.new(0, 0, 1, 0)
			keyboardSizeConstrainer.Visible = false

			table.insert(keysets, {keys = keys, container = keyboardSizeConstrainer})
		end
		newKeyboard:SetCurrentKeyset(1)
	end

	textEntryField.MouseButton1Click:connect(function()
		SetTextFieldCursorPosition(calculateTextCursorPosition(panel.lookAtPixel.X, panel.lookAtPixel.Y))
	end)

	closeButton.MouseButton1Click:connect(function()
		newKeyboard:Close(false)
	end)

	voiceDoneButton.MouseButton1Click:connect(function()
		if VoiceToTextFSM:GetCurrentState().Name == "Listening" then
			VoiceToTextFSM:TransitionState(CreateProcessingVoiceState())
		end
	end)

	local function onVoiceProcessingStateChanged(newState)
		if newState.Name == "Listening" then
			voiceProcessingStatus.Text = "Listening..."
		elseif newState.Name == "Processing" then
			voiceProcessingStatus.Text = "Processing..."
		elseif newState.Name == "Waiting" then
			voiceProcessingStatus.Text = "Done"
		end

		-- Get the result and put it into the textfield
		if newState.Name == "Processing" then
			coroutine.wrap(function()
				voiceVisualizer:StopAnimation()
				local result = newState:GetResultAsync()
				if result and result["Status"] == VOICE_STATUS_CODE_ENUM.ASR_STATUS_OK  then
					setBufferText(result["Response"])
				else
					voiceProcessingStatus.Text = "An error occurred, please try again."
					wait(2)
				end
				VoiceToTextFSM:TransitionState(CreateWaitingVoiceState())
			end)()
		elseif newState.Name == "Listening" then
			voiceVisualizer:StartAnimation()
		elseif newState.Name == "Waiting" then
			newKeyboard:SetVoiceMode(false)
		end
	end
	VoiceToTextFSM.StateTransitionedEvent:connect(onVoiceProcessingStateChanged)
	onVoiceProcessingStateChanged(VoiceToTextFSM:GetCurrentState())


	return newKeyboard
end


local Keyboard = nil;
local function GetKeyboard()
	if Keyboard == nil then
		Keyboard = ConstructKeyboardUI({MINIMAL_KEYBOARD_LAYOUT, MINIMAL_KEYBOARD_LAYOUT_SYMBOLS})
	end
	return Keyboard
end



local VirtualKeyboardClass = {}

function VirtualKeyboardClass:CreateVirtualKeyboardOptions(textbox)
	local keyboardOptions = {}

	keyboardOptions.TextBox = textbox

	return keyboardOptions
end

local VirtualKeyboardPlatform = true
function VirtualKeyboardClass:ShowVirtualKeyboard(virtualKeyboardOptions)
	if VirtualKeyboardPlatform and UserInputService.VREnabled then
		GetKeyboard():Open(virtualKeyboardOptions)
		--if (KeyboardGui) then
		--	KeyboardGui.Enabled = true;
		--end
	end
end

function VirtualKeyboardClass:CloseVirtualKeyboard()
	if VirtualKeyboardPlatform and UserInputService.VREnabled then
		local currentKeyboard = GetKeyboard()
		currentKeyboard:Close(false)
		--if (KeyboardGui) then
		--	KeyboardGui.Enabled = false;
		--end
	end
end

VirtualKeyboardClass.OpenedEvent = GetKeyboard().OpenedEvent
VirtualKeyboardClass.ClosedEvent = GetKeyboard().ClosedEvent


if VirtualKeyboardPlatform then
	UserInputService.TextBoxFocused:connect(function(textbox)
		VirtualKeyboardClass:ShowVirtualKeyboard(VirtualKeyboardClass:CreateVirtualKeyboardOptions(textbox))
	end)
	-- Don't have to hook up to TextBoxFocusReleased because we are already listening to that in keyboard
end

return VirtualKeyboardClass
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="22">
            <Properties>
              <string name="Name">Panel3D</string>
              <string name="Source"><![CDATA[--!nonstrict
--Panel3D: 3D GUI panels for VR
--written by 0xBAADF00D
--revised/refactored 5/11/16
--updated 2021/2022 by MetaVars for new VR system

local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")

--local CoreGuiModules = RobloxGui:WaitForChild("Modules")
local Players = game:GetService("Players")
local RobloxGui = Players.LocalPlayer.PlayerGui
local Utility = require(script.Parent.Utility)
local GamepadService = game:GetService("GamepadService")
local VRUtil = require(script.Parent.VRUtil)
local CorePackages = game:GetService("CorePackages")

local EngineFeatureEnableVRUpdate3 = true--game:GetEngineFeature("EnableVRUpdate3")
local FFlagVRLetRaycastsThroughUI = true--require(CoreGuiModules.Flags.FFlagVRLetRaycastsThroughUI)
local GetFFlagUIBloxVRApplyHeadScale = true--require(CorePackages.Workspace.Packages.SharedFlags).UIBlox.GetFFlagUIBloxVRApplyHeadScale

--Panel3D State variables
local renderStepName = "Panel3DRenderStep-" .. game:GetService("HttpService"):GenerateGUID()
local defaultPixelsPerStud = 64
local pointUpCF = CFrame.Angles(math.rad(-90), math.rad(180), 0)
local zeroVector = Vector3.new(0, 0, 0)
local zeroVector2 = Vector2.new(0, 0)
local fullyOpaqueAtPixelsFromEdge = 10
local fullyTransparentAtPixelsFromEdge = 20
local partThickness = 0.2

--The default origin CFrame offset for new panels
local standardOriginCF = CFrame.new(0, -0.5, -5.5)
local newStandardOriginCF = CFrame.new(0, 0, -3)

--Compensates for the thickness of the panel part and rotates it so that
--the front face is pointing back at the camera
local panelAdjustCF = CFrame.new(0, 0, -0.5 * partThickness) * CFrame.Angles(0, math.pi, 0) 

local cursorHidden = false
local cursorHideTime = 2.5
local cursorSize = 3

local lerpSpeed = 4

local currentModal = nil
local lastModal = nil
local currentMaxDist = math.huge
local currentClosest = nil
local currentCursorParent = nil
local currentCursorPos = zeroVector2
local lastClosest = nil
local panels = {}
local floorRotation = CFrame.new()
local cursor = Utility:Create "ImageLabel" {
	Image = "rbxasset://textures/Cursors/Gamepad/Pointer.png",
	ImageColor3 = Color3.new(0, 1, 0),
	BackgroundTransparency = 1,
	ZIndex = 1e9
}
local partFolder = workspace.CurrentCamera:WaitForChild("VRCorePanelParts")
local effectFolder = workspace.CurrentCamera:WaitForChild("VRCoreEffectParts");
partFolder:WaitForChild("Keyboard")
pcall(function()
	GuiService.CoreGuiFolder = partFolder
	GuiService.CoreEffectFolder = effectFolder
end)
--End of Panel3D State variables


--Panel3D Declaration and enumerations
local Panel3D = {}
Panel3D.Type = {
	None = 0,
	Standard = 1,
	Fixed = 2,
	HorizontalFollow = 3,
	FixedToHead = 4,
	NewStandard = 5,
	WristView = 6,
	PositionLocked = 7,
}

Panel3D.OnPanelClosed = Utility:Create 'BindableEvent' {
	Name = 'OnPanelClosed'
}

function Panel3D.GetHeadLookXZ(withTranslation)
	local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
	local headLook = userHeadCF.lookVector
	local headYaw = math.atan2(-headLook.Z, headLook.X) - math.rad(90)
	local cf = CFrame.Angles(0, headYaw, 0)

	if withTranslation then
		cf = cf + userHeadCF.p
	end
	return cf
end

function Panel3D.FindContainerOf(element)
	for _, panel in pairs(panels) do
		if panel.gui and panel.gui:IsAncestorOf(element) then
			return panel
		end
		for _, subpanel in pairs(panel.subpanels) do
			if subpanel.gui and subpanel.gui:IsAncestorOf(element) then
				return panel
			end
		end
	end
	return nil
end

function Panel3D.SetModalPanel(panel)
	if currentModal == panel then
		return
	end
	if currentModal then
		currentModal:OnModalChanged(false)
	end
	if panel then
		panel:OnModalChanged(true)
	end
	lastModal = currentModal
	currentModal = panel
end

function Panel3D.RaycastOntoPanel(part, parentGui, gui, ray)
	local partSize = part.Size
	local partThickness = partSize.Z
	local partWidth = partSize.X
	local partHeight = partSize.Y

	local planeCF = part:GetRenderCFrame()
	local planeNormal = planeCF.lookVector
	local pointOnPlane = planeCF.p + (planeNormal * partThickness * 0.5)

	--Find where the view ray intersects with the plane in world space
	local worldIntersectPoint = Utility:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	if worldIntersectPoint then
		local parentGuiWidth, parentGuiHeight = parentGui.AbsoluteSize.X, parentGui.AbsoluteSize.Y
		--now figure out where that intersection point was in the panel's local space
		--and then flip the X axis because the plane is looking back at you (panel's local +X is to the left of the camera)
		--and then offset it by half of the panel's size in X and -Y to move 0,0 to the upper-left of the panel.
		local localIntersectPoint = planeCF:pointToObjectSpace(worldIntersectPoint) * Vector3.new(-1, 1, 1)
			+ Vector3.new(partWidth / 2, -partHeight / 2, 0)
		--now scale it into the gui space on the panel's surface
		local lookAtPixel = Vector2.new(
			(localIntersectPoint.X / partWidth) * parentGuiWidth,
			(localIntersectPoint.Y / partHeight) * -parentGuiHeight
		)

		--fire mouse enter/leave events if necessary
		local lookX, lookY = lookAtPixel.X, lookAtPixel.Y
		local guiX, guiY = gui.AbsolutePosition.X, gui.AbsolutePosition.Y
		local guiWidth, guiHeight = gui.AbsoluteSize.X, gui.AbsoluteSize.Y
		local isOnGui = false

		if parentGui.Enabled then
			if lookX >= guiX and lookX <= guiX + guiWidth and lookY >= guiY and lookY <= guiY + guiHeight then
				isOnGui = true
			end
		end

		return worldIntersectPoint, localIntersectPoint, lookAtPixel, isOnGui
	else
		return nil, nil, nil, false
	end
end

--End of Panel3D Declaration and enumerations

--Panel class implementation
local Panel = {}
Panel.__index = Panel
function Panel.new(name)
	local self = {}
	self.name = name

	self.part = false
	self.gui = false

	self.width = 1
	self.height = 1

	self.isVisible = false
	self.isEnabled = false
	self.panelType = Panel3D.Type.None
	self.pixelScale = 1
	self.showCursor = true
	self.canFade = true
	self.shouldFindLookAtGuiElement = false
	self.ignoreModal = false
	self.needsPositionUpdate = false
	self.alwaysUpdatePosition = false

	self.linkedTo = false
	self.subpanels = {}

	self.transparency = 0
	self.forceShowUntilLookedAt = false
	self.forceShowUntilTick = 0
	self.isLookedAt = false
	self.isWristHeldUp = false
	self.isOffscreen = true
	self.lookAtPixel = Vector2.new(-1, -1)
	self.cursorPos = Vector2.new(-1, -1)
	self.lookAtDistance = math.huge
	self.lookAtGuiElement = false
	self.isClosest = true

	self.localCF = CFrame.new()
	self.angleFromHorizon = false
	self.angleFromForward = false
	self.distance = 0

	self.lerpTime = 0
	self.lerpInitialCF = nil
	self.lerpScaleSize = Vector2.new(0,0)
	self.lerpInitialSize = Vector2.new(0,0)

	self.FollowView = true
	self.LastFollowCF = nil

	--self.wristLockPosition = false
	self.wristTargetPosition = Vector3.new()

	if panels[name] then
		error("A panel by the name of " .. name .. " already exists.")
	end
	panels[name] = self

	return setmetatable(self, Panel)
end

--Panel accessor methods
function Panel:GetPart()
	if not self.part then
		self.part = Utility:Create("Part")({
			Name = self.name,
			Parent = partFolder,

			Transparency = 1,

			CanCollide = false,
			CanTouch = if FFlagVRLetRaycastsThroughUI then false else nil,
			Anchored = true,

			Size = Vector3.new(1, 1, partThickness),
		})
	end
	return self.part
end

function Panel:GetGUI()
	if not self.gui then
		local part = self:GetPart()
		self.gui = Utility:Create("SurfaceGui")({
			Parent = RobloxGui,
			Name = self.name,
			Archivable = false,
			Adornee = part,
			Active = true,
			ToolPunchThroughDistance = 1000,
			CanvasSize = self.CanvasSize or Vector2.new(1000, 1000),
			Enabled = self.isEnabled,
			AlwaysOnTop = true,
		})
	end
	return self.gui
end

function Panel:FindHoveredGuiElement(elements)
	local x, y = self.lookAtPixel.X, self.lookAtPixel.Y
	for i, v in pairs(elements) do
		local minPt = v.AbsolutePosition
		local maxPt = v.AbsolutePosition + v.AbsoluteSize
		if minPt.X <= x and maxPt.X >= x and minPt.Y <= y and maxPt.Y >= y then
			return v, i
		end
	end
end
--End of panel accessor methods

--Panel update methods
function Panel:SetPartCFrame(cframe)
	self:GetPart().CFrame = cframe * panelAdjustCF
end

function Panel:SetEnabled(enabled)
	if self.isEnabled == enabled then
		return
	end

	self.isEnabled = enabled
	if enabled then
		self:GetPart().Parent = partFolder
		self:GetGUI().Enabled = true
		for i, v in pairs(self.subpanels) do
			v:SetEnabled(v:GetEnabled())
		end
	else
		self:GetPart().Parent = nil
		self:GetGUI().Enabled = false
		for i, v in pairs(self.subpanels) do
			v:SetEnabled(v:GetEnabled())
		end
	end

	self:OnEnabled(enabled)
end

function Panel:StartLerp(scaleSize)
	-- this starts a linear interpolation of the position and size of the panel
	self.lerpInitialCF = self:GetPart().CFrame * CFrame.new(0, -1.5, 0)
	self.lerpTime = 1
	self.lerpInitialSize = Vector2.new(self.width, self.height)
	self.lerpScaleSize = scaleSize and scaleSize or Vector2.new(0,0)
end

function Panel:EvaluatePositioning(cameraCF, cameraRenderCF, userHeadCF, dt)
	if self.panelType == Panel3D.Type.Fixed then
		--Places the panel in the camera's local space, but doesn't follow the user's head.
		--Useful if you know what you're doing. localCF can be updated in PreUpdate for animation.
		local cf = self.localCF - self.localCF.p
		cf = cf + (self.localCF.p * (workspace.CurrentCamera :: Camera).HeadScale)
		self:SetPartCFrame(cameraCF * cf)
	elseif self.panelType == Panel3D.Type.HorizontalFollow then
		local headLook = userHeadCF.lookVector
		local headForwardCF = CFrame.new(userHeadCF.p, userHeadCF.p + (headLook * Vector3.new(1, 0, 1)))
		local localCF = (headForwardCF * self.angleFromForward) * --Rotate about Y (left-right)
			self.angleFromHorizon * --Rotate about X (up-down)
			CFrame.new(0, 0, (workspace.CurrentCamera :: Camera).HeadScale * -self.distance)
		self:SetPartCFrame(cameraCF * localCF)
	elseif self.panelType == Panel3D.Type.FixedToHead then
		--Places the panel in the user's head local space. localCF can be updated in PreUpdate for animation.
		local cf = self.localCF - self.localCF.p
		cf = cf + (self.localCF.p * (workspace.CurrentCamera :: Camera).HeadScale)
		self:SetPartCFrame(cameraRenderCF * cf)
	elseif self.panelType == Panel3D.Type.Standard then
		if self.needsPositionUpdate or self.alwaysUpdatePosition then
			self.needsPositionUpdate = false
			local headLookXZ = Panel3D.GetHeadLookXZ(true)
			local offset = standardOriginCF.Position * (workspace.CurrentCamera :: Camera).HeadScale
			self.originCF = headLookXZ * CFrame.new(offset)
		end

		self:SetPartCFrame(cameraCF * self.originCF * self.localCF)
	elseif self.panelType == Panel3D.Type.NewStandard then
		if self.needsPositionUpdate or self.alwaysUpdatePosition then
			self.needsPositionUpdate = false
			local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			local screenOffset = newStandardOriginCF.Position * (workspace.CurrentCamera :: Camera).HeadScale
			self.originCF = userHeadCF * CFrame.new(screenOffset)
		end

		self:SetPartCFrame(cameraCF * self.originCF * self.localCF)	
	elseif self.panelType == Panel3D.Type.WristView then
		if VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand) then
			if self.needsPositionUpdate or self.alwaysUpdatePosition then
				self.needsPositionUpdate = false
				local userLeftCF = VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
				local scaledPosition = userLeftCF.Position * (workspace.CurrentCamera :: Camera).HeadScale
				self.originCF = CFrame.new(scaledPosition)
			end

			local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			local userHeadCameraCF = cameraCF * userHeadCF

			-- make sure the panel sits at a good distance
			local wristCF = cameraCF * self.originCF
			local finalPosition = wristCF.Position
			if self.distance > 0 then
				-- hack : bring it up to head height when at a distance
				finalPosition = Vector3.new(finalPosition.x, userHeadCameraCF.Position.y - 0.33, finalPosition.z)

				local finalDistance = math.clamp((finalPosition - userHeadCameraCF.Position).Magnitude, self.distance - 0.5, self.distance + 0.5)
				local offsetPos = (finalPosition - userHeadCameraCF.Position).Unit * finalDistance
				finalPosition = userHeadCameraCF.Position + offsetPos
			end

			-- don't angle up/down
			local targetPosition = Vector3.new(userHeadCameraCF.Position.x, finalPosition.y, userHeadCameraCF.Position.z)

			-- face the VR camera from the wrist
			local facingCF = CFrame.new(finalPosition, targetPosition)

			self:GetPart().CFrame = facingCF
		else
			local cf = self.localCF - self.localCF.p
			cf = cf + (self.localCF.p * (workspace.CurrentCamera :: Camera).HeadScale)
			self:SetPartCFrame(cameraCF * cf)
		end
	elseif self.panelType == Panel3D.Type.PositionLocked then

		local userHeadCameraCF
		if GetFFlagUIBloxVRApplyHeadScale() then
			userHeadCameraCF = VRUtil.GetUserCFrameWorldSpace(Enum.UserCFrame.Head)
		else
			local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			userHeadCameraCF = cameraCF * userHeadCF
		end

		if not self.LastFollowCF then
			self.LastFollowCF = userHeadCameraCF
		end

		if self.LastFollowCF.LookVector:Dot(userHeadCameraCF.LookVector) < 0.85 then
			self.FollowView = true
		else
			if self.LastFollowCF.LookVector:Dot(userHeadCameraCF.LookVector) > 0.99 then
				self.FollowView = false
			end
		end

		if self.FollowView then
			self.LastFollowCF = self.LastFollowCF:Lerp(userHeadCameraCF, 0.1)
		end

		local finalPosition
		if GetFFlagUIBloxVRApplyHeadScale() then
			finalPosition = userHeadCameraCF.Position + self.LastFollowCF.LookVector * (self.distance * (workspace.CurrentCamera :: Camera).HeadScale + partThickness * 0.5)
			finalPosition = Vector3.new(finalPosition.X, userHeadCameraCF.Position.Y - 0.5 * (workspace.CurrentCamera :: Camera).HeadScale, finalPosition.Z)
		else
			finalPosition = userHeadCameraCF.Position + self.LastFollowCF.LookVector * self.distance * (workspace.CurrentCamera :: Camera).HeadScale
			finalPosition = Vector3.new(finalPosition.X, userHeadCameraCF.Position.Y - 0.5, finalPosition.Z)
		end

		-- don't angle up/down
		local targetPosition = Vector3.new(userHeadCameraCF.Position.x, finalPosition.y, userHeadCameraCF.Position.z)

		-- face the VR camera from the wrist
		local facingCF = CFrame.new(finalPosition, targetPosition)

		self:GetPart().CFrame = facingCF
	end

	-- optional lerp
	if self.lerpInitialCF and self.lerpTime > 0 then
		local targetCF = self:GetPart().CFrame
		local targetLook = targetCF.Position + targetCF.LookVector
		self.lerpTime -= dt * lerpSpeed
		local lerpAmount = math.clamp(1 - self.lerpTime, 0, 1)
		targetCF = self.lerpInitialCF:Lerp(targetCF, lerpAmount)

		self:GetPart().CFrame = targetCF --CFrame.new(targetCF.Position, targetLook)

		if(self.lerpScaleSize.x > 0 or self.lerpScaleSize.y > 0) then
			local newSize = self.lerpInitialSize:Lerp(self.lerpScaleSize, lerpAmount)
			self:ResizeStuds(newSize.x, newSize.y, self.pixelsPerStud)
		end
	end
end

function Panel:SetLookedAt(lookedAt)
	if not self.isLookedAt and lookedAt then
		self.isLookedAt = true
		self:OnMouseEnter(self.lookAtPixel.X, self.lookAtPixel.Y)
		if self.forceShowUntilLookedAt then
			self.forceShowUntilLookedAt = false
		end
	elseif self.isLookedAt and not lookedAt then
		self.isLookedAt = false
		self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
	end
end

function Panel:EvaluateGaze(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay)
	--reset distance data
	self.isClosest = false
	self.lookAtPixel = zeroVector2
	self.lookAtDistance = math.huge

	--check all subpanels first, they're usually in front of the panel.
	local highestSubpanel = nil
	local highestSubpanelDepth = 0
	for guiElement, subpanel in pairs(self.subpanels) do
		if subpanel.part and subpanel.guiElement then
			--note that we're passing subpanel.guiElement and not subpanel.gui
			--this is on purpose so we can fall through to the panels underneath since subpanels will rarely take up the whole
			--panel size.
			local worldIntersectPoint, localIntersectPoint, guiPixelHit, isOnGui = Panel3D.RaycastOntoPanel(
				subpanel.part,
				subpanel.gui,
				subpanel.guiElement,
				pointerRay
			)
			if worldIntersectPoint then
				subpanel.lookAtPixel = guiPixelHit
				subpanel.cursorPos = guiPixelHit

				if isOnGui and subpanel.depthOffset > highestSubpanelDepth then
					highestSubpanel = subpanel
					highestSubpanelDepth = subpanel.depthOffset
				end
			end
		end
	end

	if highestSubpanel and highestSubpanel.depthOffset > 0 then
		currentCursorParent = highestSubpanel.gui
		currentCursorPos = highestSubpanel.cursorPos
		currentClosest = highestSubpanel

		for _, subpanel in pairs(self.subpanels) do
			if subpanel ~= highestSubpanel then
				subpanel:SetLookedAt(false)
			end
		end
		highestSubpanel:SetLookedAt(true)
	end

	if self.panelType == Panel3D.Type.WristView then
		self.isWristHeldUp = false
		local userLeftCF = VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
		local scaledPosition = userLeftCF.Position * (workspace.CurrentCamera :: Camera).HeadScale
		local wristCF = cameraCF * CFrame.new(scaledPosition)

		if self.distance == 0 then
			-- conversely is the wrist where the panel would be ?
			local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			local userHeadCameraCF = cameraCF * userHeadCF
			local finalPosition = wristCF.Position
			finalPosition = Vector3.new(finalPosition.x, userHeadCameraCF.Position.y - 0.33, finalPosition.z)

			local finalDistance = math.clamp((finalPosition - userHeadCameraCF.Position).Magnitude, 0.5, 1.0)
			local offsetPos = (finalPosition - userHeadCameraCF.Position).Unit * finalDistance
			finalPosition = userHeadCameraCF.Position + offsetPos

			local delta = (finalPosition - wristCF.Position).Magnitude
			self.isWristHeldUp = delta < 0.25
		else
			-- keep holding it up while you are aiming at the wrist / bottom bar
			local userRightCF = VRService:GetUserCFrame(Enum.UserCFrame.RightHand)
			local dirRightToLeft = userLeftCF.Position - userRightCF.Position
			local dotDir = userRightCF.LookVector:Dot(dirRightToLeft)
			local projectedPosition = userRightCF.Position + userRightCF.LookVector * dotDir
			local projectedDistance = (userLeftCF.Position - projectedPosition).Magnitude
			if(projectedDistance < 0.5) then -- projected distance from the aim dir
				self.isWristHeldUp = true
			end
		end
	end

	local gui = self:GetGUI()
	local worldIntersectPoint, localIntersectPoint, guiPixelHit, isOnGui = Panel3D.RaycastOntoPanel(
		self:GetPart(),
		gui,
		gui,
		pointerRay
	)

	if worldIntersectPoint then
		self.isOffscreen = false

		--transform worldIntersectPoint to gui space
		self.lookAtPixel = guiPixelHit
		self.cursorPos = guiPixelHit

		--fire mouse enter/leave events if necessary
		self:SetLookedAt(isOnGui)

		--evaluate distance
		self.lookAtDistance = (worldIntersectPoint - cameraRenderCF.p).magnitude
		if self.isLookedAt and self.lookAtDistance < currentMaxDist and self.showCursor then
			currentMaxDist = self.lookAtDistance
			currentClosest = self
			if not highestSubpanel then
				currentCursorParent = self.gui
				currentCursorPos = self.cursorPos
			end
		end
	else
		self.isOffscreen = true

		--Not looking at the plane at all, so fire off mouseleave if necessary.
		if self.lookedAt then
			self.lookedAt = false
			self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
		end
	end
end

function Panel:EvaluateTransparency()
	--Early exit if force shown
	if self.forceShowUntilLookedAt or not self.canFade or self.forceShowUntilTick > tick() then
		self.transparency = 0
		return
	end

	--Early exit if we're looking at the panel (no transparency!)
	if self.isLookedAt then
		self.transparency = 0
		return
	end
	--Similarly, exit if we can't possibly see the panel.
	if self.isOffscreen then
		self.transparency = 1
		return
	end
	--Otherwise, we'll want to calculate the transparency.
	self.transparency = self:CalculateTransparency()
end

function Panel:Update(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay, dt)
	if (self.forceShowUntilLookedAt or self.forceShowUntilTick > tick()) and not self.part then
		self:GetPart()
		self:GetGUI()
	end
	if not self.part then
		return
	end

	local isModal = (currentModal == self)
	if not isModal and self.linkedTo and self.linkedTo == currentModal then
		isModal = true
	end
	if currentModal and not isModal then
		self:SetEnabled(false)
		return
	end

	self:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay, dt)
	if self.isVisible then
		self:EvaluatePositioning(cameraCF, cameraRenderCF, userHeadCF, dt)
		for i, v in pairs(self.subpanels) do
			v:Update()
		end

		self:EvaluateGaze(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay)

		self:EvaluateTransparency(cameraCF, cameraRenderCF)
	else
		if self.alwaysUpdatePosition then
			self:EvaluatePositioning(cameraCF, cameraRenderCF, userHeadCF, dt)
		end
	end
end
--End of Panel update methods

--Panel virtual methods
function Panel:PreUpdate(cameraCF, cameraRenderCF, userHeadCF, lookRay, dt) --virtual: handle positioning here
end

function Panel:OnUpdate(dt) --virtual: handle transparency here
end

function Panel:OnMouseEnter(x, y) --virtual
end

function Panel:OnMouseLeave(x, y) --virtual
end

function Panel:OnEnabled(enabled) --virtual
end

function Panel:OnModalChanged(isModal) --virtual
end

function Panel:OnVisibilityChanged(visible) --virtual
end

function Panel:CalculateTransparency() --virtual
	if not self.canFade then
		return 0
	end

	local guiWidth, guiHeight = self.gui.AbsoluteSize.X, self.gui.AbsoluteSize.Y
	local lookX, lookY = self.lookAtPixel.X, self.lookAtPixel.Y

	--Determine the distance from the edge;
	--if x is negative it's on the left side, meaning the distance is just absolute value
	--if x is positive it's on the right side, meaning the distance is x minus the width
	local xEdgeDist = lookX < 0 and -lookX or (lookX - guiWidth)
	local yEdgeDist = lookY < 0 and -lookY or (lookY - guiHeight)
	if lookX > 0 and lookX < guiWidth then
		xEdgeDist = 0
	end
	if lookY > 0 and lookY < guiHeight then
		yEdgeDist = 0
	end
	local edgeDist = math.sqrt(xEdgeDist ^ 2 + yEdgeDist ^ 2)

	--since transparency is 0-1, we know how many pixels will give us 0 and how many will give us 1.
	local offset = fullyOpaqueAtPixelsFromEdge
	local interval = fullyTransparentAtPixelsFromEdge
	--then we just clamp between 0 and 1.
	return math.max(0, math.min(1, (edgeDist - offset) / interval))
end
--End of Panel virtual methods

--Panel configuration methods
function Panel:ResizeStuds(width, height, pixelsPerStud)
	pixelsPerStud = pixelsPerStud or defaultPixelsPerStud

	self.width = width
	self.height = height

	self.pixelScale = pixelsPerStud / defaultPixelsPerStud

	local part = self:GetPart()
	part.Size = Vector3.new(self.width * (workspace.CurrentCamera :: Camera).HeadScale, self.height * (workspace.CurrentCamera :: Camera).HeadScale, partThickness)
	local gui = self:GetGUI()
	gui.CanvasSize = Vector2.new(pixelsPerStud * self.width, pixelsPerStud * self.height)

	for i, v in pairs(self.subpanels) do
		if v.part then
			v.part.Size = part.Size
		end
		if v.gui then
			v.gui.CanvasSize = gui.CanvasSize
		end
	end
end

function Panel:ResizePixels(width, height, pixelsPerStud)
	pixelsPerStud = pixelsPerStud or defaultPixelsPerStud

	local widthInStuds = width / pixelsPerStud
	local heightInStuds = height / pixelsPerStud
	self:ResizeStuds(widthInStuds, heightInStuds, pixelsPerStud)
end

function Panel:OnHeadScaleChanged()
	local pixelsPerStud = self.pixelScale * defaultPixelsPerStud
	self:ResizeStuds(self.width, self.height, pixelsPerStud)
end

function Panel:SetType(panelType, config)
	self.panelType = panelType

	--clear out old type-specific members

	self.localCF = CFrame.new()

	self.angleFromHorizon = false
	self.angleFromForward = false
	self.distance = 0

	if not config then
		config = {}
	end

	if panelType == Panel3D.Type.None then
		--nothing to do
		return
	elseif panelType == Panel3D.Type.Standard then
		self.localCF = config.CFrame or CFrame.new()
	elseif panelType == Panel3D.Type.Fixed then
		self.localCF = config.CFrame or CFrame.new()
	elseif panelType == Panel3D.Type.HorizontalFollow then
		self.angleFromHorizon = CFrame.Angles(config.angleFromHorizon or 0, 0, 0)
		self.angleFromForward = CFrame.Angles(0, config.angleFromForward or 0, 0)
		self.distance = config.distance or 5
	elseif panelType == Panel3D.Type.FixedToHead then
		self.localCF = config.CFrame or CFrame.new()
	elseif panelType == Panel3D.Type.NewStandard then
		self.localCF = config.CFrame or CFrame.new()
	elseif panelType == Panel3D.Type.WristView then
		self.localCF = config.CFrame or CFrame.new()
		self.distance = 0
	elseif panelType == Panel3D.Type.PositionLocked then
		self.localCF = config.CFrame or CFrame.new()	
	else
		error("Invalid Panel type")
	end
end

function Panel:IsPositionLockedType()
	return self.panelType == Panel3D.Type.PositionLocked
end

function Panel:SetVisible(visible, modal)
	if visible ~= self.isVisible then
		self:OnVisibilityChanged(visible)
		if not visible then
			Panel3D.OnPanelClosed:Fire(self.name)
		else
			self.needsPositionUpdate = true
			if self.panelType == Panel3D.Type.WristView then
				local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
				self.originCF = userHeadCF * newStandardOriginCF
			end
		end
	end

	self.isVisible = visible
	self:SetEnabled(visible)
	if visible and modal then
		Panel3D.SetModalPanel(self)
	end
	if not visible and currentModal == self then
		if modal then
			--restore last modal panel
			Panel3D.SetModalPanel(lastModal)
		else
			Panel3D.SetModalPanel(nil)

			--if the coder explicitly wanted to hide this modal panel,
			--it follows that they don't want it to be restored when the next
			--modal panel is hidden.
			if lastModal == self then
				lastModal = nil
			end
		end
	end

	if not visible and self.forceShowUntilLookedAt then
		self.forceShowUntilLookedAt = false
	end
end

function Panel:IsVisible()
	return self.isVisible
end

function Panel:LinkTo(panelName)
	if type(panelName) == "string" then
		self.linkedTo = Panel3D.Get(panelName)
	else
		self.linkedTo = panelName
	end
end

function Panel:ForceShowUntilLookedAt(makeModal)
	--ensure the part exists
	self:GetPart()
	self:GetGUI()

	self:SetVisible(true, makeModal)
	self:RequestPositionUpdate()
	self.forceShowUntilLookedAt = true
end

function Panel:ForceShowForSeconds(seconds)
	self:GetPart()
	self:GetGUI()

	self:SetVisible(true)
	if self.forceShowUntilTick < tick() then
		self:RequestPositionUpdate()
	end
	self.forceShowUntilTick = tick() + seconds
end

function Panel:SetCanFade(canFade)
	self.canFade = canFade
end

function Panel:RequestPositionUpdate()
	self.needsPositionUpdate = true
end

function Panel:ForcePositionUpdate(forceUpdate)
	self.alwaysUpdatePosition = forceUpdate
end

function Panel:GetGuiPositionInPanelSpace(guiPosition)
	local partSize = Vector2.new(self.part.Size.X, self.part.Size.Y)
	local guiSize = self.gui.AbsoluteSize
	local guiCenter = guiSize / 2

	local guiPositionFraction = (guiPosition - guiCenter) / guiSize
	local positionInPartFace = guiPositionFraction * partSize

	return Vector3.new(positionInPartFace.X, positionInPartFace.Y, partThickness * 0.5)
end

function Panel:GetCFrameInCameraSpace()
	if self.panelType == Panel3D.Type.Standard or self.panelType == Panel3D.Type.NewStandard then
		return self.originCF * self.localCF
	else
		return self.localCF or CFrame.new()
	end
end

--Child class, Subpanel
local Subpanel = {}
Subpanel.__index = Subpanel
function Subpanel.new(parentPanel, guiElement)
	local self = {}
	self.parentPanel = parentPanel
	self.guiElement = guiElement
	self.lastParent = guiElement.Parent
	self.ancestryConn = nil
	self.changedConn = nil

	self.lookAtPixel = Vector2.new(-1, -1)
	self.cursorPos = Vector2.new(-1, -1)
	self.lookedAt = false

	self.isEnabled = true

	self.part = nil
	self.gui = nil
	self.guiSurrogate = nil

	self.depthOffset = 0

	setmetatable(self, Subpanel)

	self:GetGUI()
	self:UpdateSurrogate()
	self:WatchParent(self.lastParent)

	guiElement.Parent = self.guiSurrogate

	local function ancestryCallback(parent, child)
		self:GetGUI().Enabled = self.parentPanel:GetGUI():IsAncestorOf(self.lastParent)
		if not self:GetGUI().Enabled then
			self:GetPart().Parent = nil
		else
			self:GetPart().Parent = workspace.CurrentCamera
		end
		if child == guiElement then
			--disconnect the event because we're going to move this element
			self.ancestryConn:disconnect()

			self.lastParent = guiElement.Parent
			guiElement.Parent = self.guiSurrogate
			self:WatchParent(self.lastParent)

			--reconnect it
			self.ancestryConn = guiElement.AncestryChanged:connect(ancestryCallback)
		end
	end
	self.ancestryConn = guiElement.AncestryChanged:connect(ancestryCallback)

	return self
end

function Subpanel:Cleanup()
	self.guiElement.Parent = self.lastParent
	if self.part then
		self.part:Destroy()
		self.part = nil
	end
	spawn(function()
		wait() --wait so anything that's in the gui that doesn't want to be has time to get out (panel cursor for example)
		if self.gui then
			self.gui:Destroy()
			self.gui = nil
		end
	end)
	if self.ancestryConn then
		self.ancestryConn:disconnect()
		self.ancestryConn = nil
	end
	if self.changedConn then
		self.changedConn:disconnect()
		self.changedConn = nil
	end
	self.lastParent = nil
	self.parentPanel = nil
	self.guiElement = nil
	self.guiSurrogate = nil
end

function Subpanel:OnMouseEnter(x, y) end
function Subpanel:OnMouseLeave(x, y) end

function Subpanel:SetLookedAt(lookedAt)
	if lookedAt and not self.lookedAt then
		self:OnMouseEnter(self.lookAtPixel.X, self.lookAtPixel.Y)
	elseif not lookedAt and self.lookedAt then
		self:OnMouseLeave(self.lookAtPixel.X, self.lookAtPixel.Y)
	end
	self.lookedAt = lookedAt
end

function Subpanel:WatchParent(parent)
	if self.changedConn then
		self.changedConn:disconnect()
	end
	self.changedConn = parent.Changed:connect(function(prop)
		if prop == "AbsolutePosition" or prop == "AbsoluteSize" or prop == "Parent" then
			self:UpdateSurrogate()
		end
	end)
end

function Subpanel:UpdateSurrogate()
	local lastParent = self.lastParent
	self.guiSurrogate.Position = UDim2.new(0, lastParent.AbsolutePosition.X, 0, lastParent.AbsolutePosition.Y)
	self.guiSurrogate.Size = UDim2.new(0, lastParent.AbsoluteSize.X, 0, lastParent.AbsoluteSize.Y)
end

function Subpanel:GetPart()
	if self.part then
		return self.part
	end

	self.part = self.parentPanel:GetPart():Clone()
	self.part.Parent = partFolder
	return self.part
end

function Subpanel:GetGUI()
	if self.gui then
		return self.gui
	end

	self.gui = Utility:Create("SurfaceGui")({
		Parent = RobloxGui,
		Adornee = self:GetPart(),
		Active = true,
		ToolPunchThroughDistance = 1000,
		CanvasSize = self.parentPanel:GetGUI().CanvasSize,
		Enabled = self.parentPanel.isEnabled,
		AlwaysOnTop = true,
	})
	self.guiSurrogate = Utility:Create("Frame")({
		Parent = self.gui,

		Active = false,

		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),

		BackgroundTransparency = 1,
	})
	return self.gui
end

function Subpanel:SetDepthOffset(offset)
	self.depthOffset = offset
end

function Subpanel:Update()
	local part = self:GetPart()
	local parentPart = self.parentPanel:GetPart()

	if part and parentPart then
		part.CFrame = parentPart.CFrame * CFrame.new(0, 0, -self.depthOffset)
	end
end

function Subpanel:SetEnabled(enabled)
	-- Don't change check here, parentPanel may try to refresh our enabled state
	-- alternatively we could listen to an enabled changed event on our parent panel
	self.isEnabled = enabled
	if enabled and self.parentPanel.isEnabled then
		self:GetPart().Parent = partFolder
		self:GetGUI().Enabled = true
	else
		self:GetPart().Parent = nil
		self:GetGUI().Enabled = false
	end
end

function Subpanel:GetEnabled()
	return self.isEnabled
end

function Subpanel:GetPixelScale()
	return self.parentPanel:GetPixelScale()
end
function Panel:GetPixelScale()
	return self.pixelScale
end

function Panel:AddSubpanel(guiElement)
	local subpanel = Subpanel.new(self, guiElement)
	self.subpanels[guiElement] = subpanel
	return subpanel
end

function Panel:RemoveSubpanel(guiElement)
	local subpanel = self.subpanels[guiElement]
	if subpanel then
		subpanel:Cleanup()
	end
	self.subpanels[guiElement] = nil
end

function Panel:SetSubpanelDepth(guiElement, depth)
	local subpanel = self.subpanels[guiElement]

	if depth == 0 then
		if subpanel then
			self:RemoveSubpanel(guiElement)
		end
		return nil
	end

	if not subpanel then
		subpanel = self:AddSubpanel(guiElement)
	end
	subpanel:SetDepthOffset(depth)

	return subpanel
end

--End of Panel configuration methods
--End of Panel class implementation

--Panel3D API
function Panel3D.Get(name)
	local panel = panels[name]
	if not panels[name] then
		panels[name] = Panel.new(name)
		panel = panels[name]
	end
	return panel
end
--End of Panel3D API

--Panel3D Setup
local frameStart = tick()
local function onRenderStep()
	if not VRService.VREnabled then
		return
	end

	local now = tick()
	local dt = now - frameStart
	frameStart = now

	--reset distance info
	currentClosest = nil
	currentMaxDist = math.huge

	--figure out some useful stuff
	local camera = workspace.CurrentCamera :: Camera
	local cameraCF = camera.CFrame
	local cameraRenderCF = camera:GetRenderCFrame()
	local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)
	local lookRay = Ray.new(cameraRenderCF.p, cameraRenderCF.lookVector)

	local inputUserCFrame = VRService.GuiInputUserCFrame
	local inputCF = cameraCF * VRService:GetUserCFrame(inputUserCFrame)
	local pointerRay = Ray.new(inputCF.p, inputCF.lookVector)

	--allow all panels to run their own update code
	for i, v in pairs(panels) do
		v:Update(cameraCF, cameraRenderCF, userHeadCF, lookRay, pointerRay, dt)
	end

	--evaluate linked panels
	local processed = {}
	for i, v in pairs(panels) do
		if not processed[v] and v.linkedTo and v.isVisible and v.linkedTo.isVisible then
			processed[v] = true
			processed[v.linkedTo] = true

			local minTransparency = math.min(v.transparency, v.linkedTo.transparency)
			v.transparency = minTransparency
			v.linkedTo.transparency = minTransparency
		end
	end

	--run post update because the distance information hasn't been
	--finalized until now.
	for i, v in pairs(panels) do
		--If the part is fully transparent, we don't want to keep it around in the workspace.
		if v.part and v.gui then
			--check if this panel is the current modal panel
			local isModal = (currentModal == v)
			--but also check if this panel is linked to the current modal panel
			if not isModal and v.linkedTo and v.linkedTo == currentModal then
				isModal = true
			end

			local show = v.isVisible
			if not isModal and currentModal then
				show = false
			end
			if v.transparency >= 1 then
				show = false
			end

			if v.forceShowUntilLookedAt then
				show = true
			end
			if not v.canFade and v.isVisible then
				show = true
			end

			v:SetEnabled(show)
		end

		v:OnUpdate(dt)
	end

	if currentClosest and EngineFeatureEnableVRUpdate3 then
		local x, y = currentCursorPos.X, currentCursorPos.Y
		local pixelScale = currentClosest:GetPixelScale()
		cursor.Size = UDim2.new(0, cursorSize * pixelScale, 0, cursorSize * pixelScale)
		cursor.Position = UDim2.new(0, x - cursor.AbsoluteSize.x * 0.5, 0, y - cursor.AbsoluteSize.y * 0.5)
	else
		cursor.Parent = nil
	end

	lastClosest = currentClosest
end

local isCameraReady = true
local function putFoldersIn(parent)
	partFolder.Parent = parent
	effectFolder.Parent = parent
end

local headscaleChangedConn = nil
local function onHeadScaleChanged()
	for i, v in pairs(panels) do
		v:OnHeadScaleChanged()
	end
end

local function onCurrentCameraChanged()
	onHeadScaleChanged()
	if headscaleChangedConn then
		headscaleChangedConn:disconnect()
	end
	headscaleChangedConn = (workspace.CurrentCamera :: Camera):GetPropertyChangedSignal("HeadScale"):Connect(onHeadScaleChanged)

	if VRService.VREnabled and isCameraReady then
		putFoldersIn(workspace.CurrentCamera)
	end
end

local currentCameraChangedConn = nil
local renderStepFuncBound = false
local function onVREnabledChanged()
	if VRService.VREnabled then
		while not isCameraReady do
			wait()
		end

		if workspace.CurrentCamera then
			onCurrentCameraChanged()
		end
		currentCameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)

		putFoldersIn(workspace.CurrentCamera)

		if not renderStepFuncBound then
			RunService:BindToRenderStep(renderStepName, Enum.RenderPriority.Last.Value, onRenderStep)
			renderStepFuncBound = true
		end
	else
		if currentCameraChangedConn then
			currentCameraChangedConn:disconnect()
			currentCameraChangedConn = nil
		end
		putFoldersIn(nil)

		if renderStepFuncBound then
			RunService:UnbindFromRenderStep(renderStepName)
			renderStepFuncBound = false
		end
	end
end
VRService:GetPropertyChangedSignal("VREnabled"):connect(onVREnabledChanged)
spawn(onVREnabledChanged)

coroutine.wrap(function()
	while true do
		if workspace.CurrentCamera then
			if (workspace.CurrentCamera :: Camera).CameraSubject ~= nil or (workspace.CurrentCamera :: Camera).CameraType == Enum.CameraType.Scriptable then
				break
			end
			(workspace.CurrentCamera :: Camera).Changed:Wait()
		else
			wait()
		end
	end

	isCameraReady = true
end)()

return Panel3D
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="23">
            <Properties>
              <string name="Name">Utility</string>
              <string name="Source"><![CDATA[--!nonstrict

--[[
		Filename: Utility.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Utility module for CoreScripts
--]]

------------------ CONSTANTS --------------------
local SELECTED_COLOR = Color3.fromRGB(0,162,255)
local NON_SELECTED_COLOR = Color3.fromRGB(78,84,96)

local ARROW_COLOR = Color3.fromRGB(204, 204, 204)
local ARROW_COLOR_HOVER = Color3.fromRGB(255, 255, 255)
local ARROW_COLOR_TOUCH = ARROW_COLOR_HOVER
local ARROW_COLOR_INACTIVE = Color3.fromRGB(150, 150, 150)

local SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
local NON_SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/BarLeft.png"
local SELECTED_RIGHT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
local NON_SELECTED_RIGHT_IMAGE= "rbxasset://textures/ui/Settings/Slider/BarRight.png"

local CONTROLLER_SCROLL_DELTA = 0.2
local CONTROLLER_THUMBSTICK_DEADZONE = 0.8

local DROPDOWN_BG_TRANSPARENCY = 0.2
local DROPDOWN_SUBTITLE_OFFSET = 10

local MILLISECONDS_PER_SECOND = 1000
local MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND
local MILLISECONDS_PER_WEEK = MILLISECONDS_PER_DAY * 7

------------- SERVICES ----------------
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local RobloxGui = game:GetService("Players").LocalPlayer.PlayerGui
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")
local Workspace = game:GetService("Workspace")

--------------- FLAGS ----------------

local success, result = pcall(function() return settings():GetFFlag('UseNotificationsLocalization') end)
local FFlagUseNotificationsLocalization = success and result


------------------ Modules --------------------
--local RobloxTranslator = require(CoreGui.RobloxGui.Modules:WaitForChild("RobloxTranslator"))

------------------ VARIABLES --------------------
local tenFootInterfaceEnabled = GuiService:IsTenFootInterface()--require(RobloxGui.Modules:WaitForChild("TenFootInterface")):IsEnabled()

----------- UTILITIES --------------
local Util = {}
do
	function Util.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			local parent = nil
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				elseif k == 'Parent' then
					parent = v
				else
					obj[k] = v
				end
			end
			if parent then
				obj.Parent = parent
			end
			return obj
		end
	end
end

local onResizedCallbacks = {}
setmetatable(onResizedCallbacks, { __mode = 'k' })

-- used by several guis to show no selection adorn
local noSelectionObject = Util.Create'ImageLabel'
{
	Image = "",
	BackgroundTransparency = 1
};


-- MATH --
function clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

---- TWEENZ ----
local function Linear(t, b, c, d)
	if t >= d then
		return b + c
	end

	return c*t/d + b
end

local function EaseOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	return b - c*t*(t - 2)
end

local function EaseInOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	if t < 1/2 then
		return 2*c*t*t + b
	end
	return b + c*(2*(2 - t)*t - 1)
end

function PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
	local this = {}
	this.StartTime = tick()
	this.EndTime = this.StartTime + duration
	this.Cancelled = false

	local finished = false
	local percentComplete = 0

	local function finalize()
		if instance then
			instance[prop] = easingFunc(1, start, final - start, 1)
		end
		finished = true
		percentComplete = 1
		if cbFunc then
			cbFunc()
		end
	end

	-- Initial set
	instance[prop] = easingFunc(0, start, final - start, duration)
	coroutine.wrap(function()
		local now = tick()
		while now < this.EndTime and instance do
			if this.Cancelled then
				return
			end
			instance[prop] = easingFunc(now - this.StartTime, start, final - start, duration)
			percentComplete = clamp(0, 1, (now - this.StartTime) / duration)
			RunService.RenderStepped:Wait()
			now = tick()
		end
		if this.Cancelled == false and instance then
			finalize()
		end
	end)()

	function this:GetFinal()
		return final
	end

	function this:GetPercentComplete()
		return percentComplete
	end

	function this:IsFinished()
		return finished
	end

	function this:Finish()
		if not finished then
			self:Cancel()
			finalize()
		end
	end

	function this:Cancel()
		this.Cancelled = true
	end

	return this
end

----------- CLASS DECLARATION --------------

local function CreateSignal()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:Connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		if not mArgData then
			error("Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		end
		return unpack(mArgData, 1, mArgDataCount)
	end

	return sig
end

local function getViewportSize()
	if _G.__TESTEZ_RUNNING_TEST__ then
		--Return fake value here for unit tests
		return Vector2.new(1024, 1024)
	end

	while not workspace.CurrentCamera do
		workspace.Changed:Wait()
	end
	assert(workspace.CurrentCamera, "")

	-- ViewportSize is initally set to 1, 1 in Camera.cpp constructor.
	-- Also check against 0, 0 incase this is changed in the future.
	while (workspace.CurrentCamera :: Camera).ViewportSize == Vector2.new(0,0) or
		(workspace.CurrentCamera :: Camera).ViewportSize == Vector2.new(1,1) do
		(workspace.CurrentCamera :: Camera).Changed:Wait()
	end

	return (workspace.CurrentCamera :: Camera).ViewportSize
end

local function isSmallTouchScreen()
	local viewportSize = getViewportSize()
	return UserInputService.TouchEnabled and (viewportSize.Y < 500 or viewportSize.X < 700)
end

local function isPortrait()
	local viewport = getViewportSize()
	return viewport.Y > viewport.X
end

local function isTenFootInterface()
	return tenFootInterfaceEnabled
end

local function usesSelectedObject()
	--VR does not use selected objects (in the same way as gamepad)
	if VRService.VREnabled then return false end
	--Touch does not use selected objects unless there's also a gamepad
	if UserInputService.TouchEnabled and not UserInputService.GamepadEnabled then return false end
	--PC with gamepad, console... does use selected objects
	return true
end

local function addHoverState(button, instance, onNormalButtonState, onHoverButtonState)
	local function onNormalButtonStateCallback()
		if button.Active then
			onNormalButtonState(instance)
		end
	end
	local function onHoverButtonStateCallback()
		if button.Active then
			onHoverButtonState(instance)
		end
	end

	button.MouseEnter:Connect(onHoverButtonStateCallback)
	button.SelectionGained:Connect(onHoverButtonStateCallback)
	button.MouseLeave:Connect(onNormalButtonStateCallback)
	button.SelectionLost:Connect(onNormalButtonStateCallback)

	onNormalButtonState(instance)
end

local function addOnResizedCallback(key, callback)
	onResizedCallbacks[key] = callback
	callback(getViewportSize(), isPortrait())
end

local gamepadSet = {
	[Enum.UserInputType.Gamepad1] = true;
	[Enum.UserInputType.Gamepad2] = true;
	[Enum.UserInputType.Gamepad3] = true;
	[Enum.UserInputType.Gamepad4] = true;
	[Enum.UserInputType.Gamepad5] = true;
	[Enum.UserInputType.Gamepad6] = true;
	[Enum.UserInputType.Gamepad7] = true;
	[Enum.UserInputType.Gamepad8] = true;
}

local function MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)
	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1,
	};

	local button = Util.Create'ImageButton'
	{
		Name = name .. "Button",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Size = size,
		ZIndex = 2,
		SelectionImageObject = SelectionOverrideObject
	};

	local _enabled = Util.Create'BoolValue'
	{
		Name = 'Enabled',
		Parent = button,
		Value = true
	}

	if clickFunc then
		button.MouseButton1Click:Connect(function()
			clickFunc(gamepadSet[UserInputService:GetLastInputType()] or false)
		end)
	end

	local function isPointerInput(inputObject)
		return inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch
	end

	local rowRef = nil
	local function setRowRef(ref)
		rowRef = ref
	end

	local function selectButton()
		local hub = hubRef
		if hub == nil then
			if pageRef then
				hub = pageRef.HubRef
			end
		end

		if (hub and hub.Active) or hub == nil then
			button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButtonSelected.png"

			local scrollTo = button
			if rowRef then
				scrollTo = rowRef
			end
			if hub then
				hub:ScrollToFrame(scrollTo)
			end
		end
	end

	local function deselectButton()
		button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png"
	end

	button.InputBegan:Connect(function(inputObject)
		if button.Selectable and isPointerInput(inputObject) then
			selectButton()
		end
	end)
	button.InputEnded:Connect(function(inputObject)
		if button.Selectable and GuiService.SelectedCoreObject ~= button and isPointerInput(inputObject) then
			deselectButton()
		end
	end)


	button.SelectionGained:Connect(function()
		selectButton()
	end)
	button.SelectionLost:Connect(function()
		deselectButton()
	end)

	local _guiServiceCon = GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end
		if not usesSelectedObject() then return end

		if GuiService.SelectedCoreObject == nil or GuiService.SelectedCoreObject ~= button then
			deselectButton()
			return
		end

		if button.Selectable then
			selectButton()
		end
	end)

	return button, setRowRef
end

local function MakeButton(name, text, size, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local textLabel = Util.Create'TextLabel'
	{
		Name = name .. "TextLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, -8),
		Position = UDim2.new(0,0,0,0),
		TextColor3 = Color3.fromRGB(255,255,255),
		TextYAlignment = Enum.TextYAlignment.Center,
		Font = Enum.Font.SourceSansBold,
		TextSize = 24,
		Text = text,
		TextScaled = true,
		TextWrapped = true,
		ZIndex = 2,
		Parent = button
	};
	local constraint = Instance.new("UITextSizeConstraint",textLabel)

	if isSmallTouchScreen() then
		textLabel.TextSize = 18
	elseif isTenFootInterface() then
		textLabel.TextSize = 36
	end
	constraint.MaxTextSize = textLabel.TextSize

	return button, textLabel, setRowRef
end

local function MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local imageLabel = Util.Create'ImageLabel'
	{
		Name = name .. "ImageLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = imageSize,
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Image = image,
		ZIndex = 2,
		Parent = button
	};

	return button, imageLabel, setRowRef
end

local function AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	local button, textLabel, setRowRef = MakeButton(name, text, size, clickFunc, pageToAddTo, hubRef)
	local row = Util.Create'Frame'
	{
		Name = name .. "Row",
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, size.Y.Scale, size.Y.Offset),
		Parent = pageToAddTo.Page
	}
	button.Parent = row
	button.AnchorPoint = Vector2.new(1, 0)
	button.Position = UDim2.new(1, -20, 0, 0)
	return row, button, textLabel, setRowRef
end

local function CreateDropDown(dropDownStringTable, startPosition, settingsHub)
	-------------------- CONSTANTS ------------------------
	local DROPDOWN_DEFAULT_TEXT_KEY = "Feature.SettingsHub.Label.ChooseOne"
	local SCROLLING_FRAME_PIXEL_OFFSET = 25
	local SELECTION_TEXT_COLOR_NORMAL = Color3.fromRGB(178,178,178)
	local SELECTION_TEXT_COLOR_NORMAL_VR = Color3.fromRGB(229,229,229)
	local SELECTION_TEXT_COLOR_HIGHLIGHTED = Color3.fromRGB(255,255,255)

	-------------------- VARIABLES ------------------------
	local lastSelectedCoreObject = nil

	-------------------- SETUP ------------------------
	local this = {}
	this.CurrentIndex = nil
	this.UpdateDropDownList = nil
	this.DropDownFrame = nil
	this.Selections = nil

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	if type(dropDownStringTable) ~= "table" then
		error("CreateDropDown dropDownStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true
	local guid = HttpService:GenerateGUID(false)
	local dropDownButtonEnabled
	local lastStringTable = dropDownStringTable

	----------------- GUI SETUP ------------------------
	local DropDownFullscreenFrame = Util.Create'ImageButton'
	{
		Name = "DropDownFullscreenFrame",
		BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.fromRGB(0,0,0),
		ZIndex = 10,
		Active = true,
		Visible = false,
		Selectable = false,
		AutoButtonColor = false,
		Parent = CoreGui.RobloxGui
	};

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D) :: any
			DropDownFullscreenFrame.Parent = Panel3D.Get("SettingsMenu"):GetGUI()
			DropDownFullscreenFrame.BackgroundTransparency = 1
		else
			DropDownFullscreenFrame.Parent = CoreGui.RobloxGui
			DropDownFullscreenFrame.BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY
		end

		--Force the gui to update, but only if onVREnabled is fired later on
		if this.UpdateDropDownList then
			this:UpdateDropDownList(lastStringTable)
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	local DropDownSelectionFrame = Util.Create'ImageLabel'
	{
		Name = "DropDownSelectionFrame",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0.9, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		ZIndex = 10,
		Parent = DropDownFullscreenFrame
	};

	local DropDownScrollingFrame = Util.Create'ScrollingFrame'
	{
		Name = "DropDownScrollingFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, -20, 1, -SCROLLING_FRAME_PIXEL_OFFSET),
		Position = UDim2.new(0, 10, 0, 10),
		ZIndex = 10,
		Parent = DropDownSelectionFrame
	};

	local guiServiceChangeCon = nil
	local active = false
	local hideDropDownSelection = function(name, inputState)
		if name ~= nil and inputState ~= Enum.UserInputState.Begin then return end
		this.DropDownFrame.Selectable = interactable

		--Make sure to set the hub to Active again so selecting the
		--dropdown button will highlight it
		settingsHub:SetActive(true)

		if DropDownFullscreenFrame.Visible and usesSelectedObject() then
			GuiService.SelectedCoreObject = lastSelectedCoreObject
		end
		DropDownFullscreenFrame.Visible = false
		if guiServiceChangeCon then guiServiceChangeCon:Disconnect() end
		ContextActionService:UnbindCoreAction(guid .. "Action")
		ContextActionService:UnbindCoreAction(guid .. "FreezeAction")

		dropDownButtonEnabled.Value = interactable
		active = false

		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D) :: any
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0)
		end
	end
	local noOpFunc = function() end

	local DropDownFrameClicked = function()
		if not interactable then return end

		this.DropDownFrame.Selectable = false
		active = true

		DropDownFullscreenFrame.Visible = true
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D) :: any
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0.5)
		end

		lastSelectedCoreObject = this.DropDownFrame
		if this.CurrentIndex and this.CurrentIndex > 0 then
			GuiService.SelectedCoreObject = this.Selections[this.CurrentIndex]
		elseif #this.Selections > 0 then
			GuiService.SelectedCoreObject = this.Selections[1]
		end

		guiServiceChangeCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			for i = 1, #this.Selections do
				if GuiService.SelectedCoreObject == this.Selections[i] then
					this.Selections[i].TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
				else
					this.Selections[i].TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL
				end
			end
		end)

		ContextActionService:BindCoreAction(guid .. "FreezeAction", noOpFunc, false, Enum.UserInputType.Keyboard, Enum.UserInputType.Gamepad1)
		ContextActionService:BindCoreAction(guid .. "Action", hideDropDownSelection, false, Enum.KeyCode.ButtonB, Enum.KeyCode.Escape)

		settingsHub:SetActive(false)

		dropDownButtonEnabled.Value = false
	end

	local dropDownDefaultText = "RobloxTranslatorDefaultText"--RobloxTranslator:FormatByKey(DROPDOWN_DEFAULT_TEXT_KEY)

	local dropDownFrameSize = UDim2.new(0.6, 0, 0, 50)
	this.DropDownFrame = MakeButton("DropDownFrame", dropDownDefaultText,
		dropDownFrameSize, DropDownFrameClicked, nil, settingsHub)
	this.DropDownFrame.Position = UDim2.new(1, 0, 0.5, 0)
	this.DropDownFrame.AnchorPoint = Vector2.new(1, 0.5)

	dropDownButtonEnabled = this.DropDownFrame.Enabled
	local selectedTextLabel = this.DropDownFrame.DropDownFrameTextLabel
	selectedTextLabel.Position = UDim2.new(0, 15, 0, 0)
	selectedTextLabel.Size = UDim2.new(1, -50, 1, -8)
	selectedTextLabel.ClipsDescendants = true
	selectedTextLabel.TextXAlignment = Enum.TextXAlignment.Left
	local dropDownImage = Util.Create'ImageLabel'
	{
		Name = "DropDownImage",
		Image = "rbxasset://textures/ui/Settings/DropDown/DropDown.png",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Size = UDim2.new(0,15,0,10),
		Position = UDim2.new(1,-12,0.5,0),
		ZIndex = 2,
		Parent = this.DropDownFrame
	};
	this.DropDownImage = dropDownImage


	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if i == index then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(index)
		end
	end

	local function setSelectionByValue(value)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if selectionLabel.Text == value then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(this.CurrentIndex)
		end
		return shouldFireChanged
	end

	local function setIsFaded(isFaded)
		if isFaded then
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0.5
			this.DropDownFrame.ImageTransparency = 0.5
			this.DropDownImage.ImageTransparency = 0.5
		else
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0
			this.DropDownFrame.ImageTransparency = 0
			this.DropDownImage.ImageTransparency = 0
		end
	end


	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex)
	end

	function this:SetSelectionByValue(value)
		return setSelectionByValue(value)
	end

	function this:ResetSelectionIndex()
		this.CurrentIndex = nil
		selectedTextLabel.Text = dropDownDefaultText
		hideDropDownSelection()
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		this.DropDownFrame.ZIndex = newZIndex
		dropDownImage.ZIndex = newZIndex
		selectedTextLabel.ZIndex = newZIndex
	end

	function this:SetInteractable(value)
		interactable = value
		this.DropDownFrame.Selectable = interactable

		if not interactable then
			hideDropDownSelection()
			setIsFaded(VRService.VREnabled)
			if not VRService.VREnabled then
				this:SetZIndex(1)
			end
		else
			setIsFaded(false)
			if not VRService.VREnabled then
				this:SetZIndex(2)
			end
		end

		dropDownButtonEnabled.Value = value and not active
	end

	function this:SetAutoLocalize(autoLocalize)
		DropDownFullscreenFrame.AutoLocalize = autoLocalize
	end

	function this:UpdateDropDownList(dropDownStringTable)
		lastStringTable = dropDownStringTable

		if this.Selections then
			for i = 1, #this.Selections do
				this.Selections[i]:Destroy()
			end
		end

		this.Selections = {}
		this.SelectionInfo = {}

		local vrEnabled = VRService.VREnabled
		local font = vrEnabled and Enum.Font.SourceSansBold or Enum.Font.SourceSans
		local textSize = vrEnabled and 36 or 24

		local itemHeight = vrEnabled and 70 or 50
		local itemSpacing = itemHeight + 1

		local dropDownWidth = vrEnabled and 600 or 400
		local subtitleTotalOffset = 0

		for i,v in pairs(dropDownStringTable) do
			local SelectionOverrideObject =	Util.Create'Frame'
			{
				BackgroundTransparency = 0.7,
				BorderSizePixel = 0,
				Size = UDim2.new(1, 0, 1, 0)
			};

			local text = v
			local subtitle = ''
			local UseSubtitle = typeof(v) == 'table'
			if UseSubtitle then
				text = v.title
				subtitle = v.subtitle
				subtitleTotalOffset += DROPDOWN_SUBTITLE_OFFSET
			end

			local nextSelection

			if UseSubtitle then
				nextSelection = Util.Create'TextButton'
				{
					Name = "Selection" .. tostring(i),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false,
					TextYAlignment = Enum.TextYAlignment.Top,
					Size = UDim2.new(1, -28, 0, itemHeight + DROPDOWN_SUBTITLE_OFFSET),
					Position = UDim2.new(0,14,0, (i - 1) * (itemSpacing + DROPDOWN_SUBTITLE_OFFSET)),
					TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
					Font = font,
					TextSize = textSize,
					Text = text,
					ZIndex = 10,
					SelectionImageObject = SelectionOverrideObject,
					Parent = DropDownScrollingFrame
				}

				local subtitleSize = 0.8
				local subtitlePadding = 15
				local _Subtitle = Util.Create'TextLabel'
				{
					Name = "Subtitle" .. tostring(i),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, -28, 0, itemHeight * subtitleSize),
					Position = UDim2.new(0,14,0, subtitlePadding),
					TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
					Font = font,
					TextSize = textSize * subtitleSize,
					Text = subtitle,
					ZIndex = 10,
					Parent = nextSelection
				}
			else
				nextSelection = Util.Create'TextButton'
				{
					Name = "Selection" .. tostring(i),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false,
					Size = UDim2.new(1, -28, 0, itemHeight),
					Position = UDim2.new(0,14,0, (i - 1) * itemSpacing),
					TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
					Font = font,
					TextSize = textSize,
					Text = v,
					ZIndex = 10,
					SelectionImageObject = SelectionOverrideObject,
					Parent = DropDownScrollingFrame
				}
			end

			if i == startPosition then
				this.CurrentIndex = i
				selectedTextLabel.Text = text
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			elseif not startPosition and i == 1 then
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			end

			local clicked = function()
				selectedTextLabel.Text = nextSelection.Text
				hideDropDownSelection()
				this.CurrentIndex = i
				indexChangedEvent:Fire(i)
			end

			nextSelection.MouseButton1Click:Connect(clicked)

			nextSelection.MouseEnter:Connect(function()
				if usesSelectedObject() then
					GuiService.SelectedCoreObject = nextSelection
				end
			end)

			this.Selections[i] = nextSelection
			this.SelectionInfo[nextSelection] = {Clicked = clicked}
		end

		GuiService:RemoveSelectionGroup(guid)
		GuiService:AddSelectionTuple(guid, unpack(this.Selections))

		DropDownScrollingFrame.CanvasSize = UDim2.new(1,-20,0,#dropDownStringTable * itemSpacing + subtitleTotalOffset)

		local function updateDropDownSize()
			if DropDownScrollingFrame.CanvasSize.Y.Offset < (DropDownFullscreenFrame.AbsoluteSize.Y - 10) then
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth,
					0,DropDownScrollingFrame.CanvasSize.Y.Offset + SCROLLING_FRAME_PIXEL_OFFSET)
			else
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth, 0.9, 0)
			end
		end

		DropDownFullscreenFrame.Changed:Connect(function(prop)
			if prop ~= "AbsoluteSize" then return end
			updateDropDownSize()
		end)

		updateDropDownSize()
	end

	----------------------- CONNECTIONS/SETUP --------------------------------
	this:UpdateDropDownList(dropDownStringTable)

	DropDownFullscreenFrame.MouseButton1Click:Connect(hideDropDownSelection)

	settingsHub.PoppedMenu:Connect(function(poppedMenu)
		if poppedMenu == DropDownFullscreenFrame then
			hideDropDownSelection()
		end
	end)

	return this
end


local function CreateSelector(selectionStringTable, startPosition)

	-------------------- VARIABLES ------------------------
	local lastInputDirection = 0
	local TweenTime = 0.15

	-------------------- SETUP ------------------------
	local this = {}
	this.HubRef = nil
	this.SetSelectionIndex = nil

	if type(selectionStringTable) ~= "table" then
		error("CreateSelector selectionStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true

	this.CurrentIndex = 0

	----------------- GUI SETUP ------------------------
	this.SelectorFrame = Util.Create'ImageButton'
	{
		Name = "Selector",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SelectorFrame,
		NextSelectionRight = this.SelectorFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6,0,0,50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	};

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Left.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = leftButton
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Right.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = rightButton
	};
	if not UserInputService.TouchEnabled then
		local applyNormal, applyHover =
			function(instance)
				instance.ImageColor3 = ARROW_COLOR
			end,
			function(instance) 
				instance.ImageColor3 = ARROW_COLOR_HOVER
			end
		addHoverState(leftButton, leftButtonImage, applyNormal, applyHover)
		addHoverState(rightButton, rightButtonImage, applyNormal, applyHover)
	end


	this.Selections = {}
	local isSelectionLabelVisible = {}
	local isAutoSelectButton = {}

	local autoSelectButton = Util.Create'ImageButton'{
		Name = 'AutoSelectButton',
		BackgroundTransparency = 1,
		Image = '',
		Position = UDim2.new(0, leftButton.Size.X.Offset, 0, 0),
		Size = UDim2.new(1, leftButton.Size.X.Offset * -2, 1, 0),
		Parent = this.SelectorFrame,
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	}
	autoSelectButton.MouseButton1Click:Connect(function()
		if not interactable then return end
		if #this.Selections <= 1 then return end
		local newIndex = this.CurrentIndex + 1
		if newIndex > #this.Selections then
			newIndex = 1
		end
		this:SetSelectionIndex(newIndex)
		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end
	end)
	isAutoSelectButton[autoSelectButton] = true

	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index, direction)
		for i, selectionLabel in pairs(this.Selections) do
			local isSelected = (i == index)

			local leftButtonUDim = UDim2.new(0,leftButton.Size.X.Offset,0,0)
			local tweenPos = UDim2.new(0,leftButton.Size.X.Offset * direction * 3,0,0)

			if isSelectionLabelVisible[selectionLabel] then
				tweenPos = UDim2.new(0,leftButton.Size.X.Offset * -direction * 3,0,0)
			end

			if tweenPos.X.Offset < 0 then
				tweenPos = UDim2.new(0,tweenPos.X.Offset + (selectionLabel.AbsoluteSize.X/4),0,0)
			end

			if isSelected then
				isSelectionLabelVisible[selectionLabel] = true
				selectionLabel.Position = tweenPos
				selectionLabel.Visible = true
				PropertyTweener(selectionLabel, "TextTransparency", 1, 0, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(leftButtonUDim, Enum.EasingDirection.In, Enum.EasingStyle.Quad, TweenTime, true)
				else
					selectionLabel.Position = leftButtonUDim
				end
				this.CurrentIndex = i
				indexChangedEvent:Fire(index)
			elseif isSelectionLabelVisible[selectionLabel] then
				isSelectionLabelVisible[selectionLabel] = false
				PropertyTweener(selectionLabel, "TextTransparency", 0, 1, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(tweenPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, TweenTime * 0.9, true)
				else
					selectionLabel.Position = tweenPos
				end
			end
		end
	end

	local function stepFunc(inputObject, step)
		if not interactable then return end

		if inputObject ~= nil and inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad2 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad3 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad4 and
			inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end

		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end

		local newIndex = step + this.CurrentIndex

		local direction = 0
		if newIndex > this.CurrentIndex then
			direction = 1
		else
			direction = -1
		end

		if newIndex > #this.Selections then
			newIndex = 1
		elseif newIndex < 1 then
			newIndex = #this.Selections
		end

		setSelection(newIndex, direction)
	end

	local guiServiceCon = nil
	local function connectToGuiService()
		guiServiceCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			if #this.Selections <= 0 then
				return
			end

			if GuiService.SelectedCoreObject == this.SelectorFrame then
				this.Selections[this.CurrentIndex].TextTransparency = 0
			else
				if GuiService.SelectedCoreObject ~= nil and isAutoSelectButton[GuiService.SelectedCoreObject] then
					if VRService.VREnabled then
						this.Selections[this.CurrentIndex].TextTransparency = 0
					else
						GuiService.SelectedCoreObject = this.SelectorFrame
					end
				else
					this.Selections[this.CurrentIndex].TextTransparency = 0.5
				end
			end
		end)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex, 1)
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Selections do
			this.Selections[i].ZIndex = newZIndex
		end
	end

	function this:SetInteractable(value)
		interactable = value
		this.SelectorFrame.Selectable = interactable

		leftButton.Active = interactable
		rightButton.Active = interactable

		if not interactable then
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(49, 49, 49)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
			rightButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
		else
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR
			rightButtonImage.ImageColor3 = ARROW_COLOR
		end
	end

	function this:UpdateOptions(selectionStringTable)
		for i,v in pairs(this.Selections) do
			v:Destroy()
		end

		isSelectionLabelVisible = {}
		this.Selections = {}

		for i,v in pairs(selectionStringTable) do
			local nextSelection = Util.Create'TextLabel'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.new(1,leftButton.Size.X.Offset * -2, 1, 0),
				Position = UDim2.new(1,0,0,0),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextYAlignment = Enum.TextYAlignment.Center,
				TextTransparency = 0.5,
				Font = Enum.Font.SourceSans,
				TextSize = 24,
				Text = v,
				ZIndex = 2,
				Visible = false,
				Parent = this.SelectorFrame
			};
			if isTenFootInterface() then
				nextSelection.TextSize = 36
			end

			if i == startPosition then
				this.CurrentIndex = i
				nextSelection.Position = UDim2.new(0,leftButton.Size.X.Offset,0,0)
				nextSelection.Visible = true

				isSelectionLabelVisible[nextSelection] = true
			else
				isSelectionLabelVisible[nextSelection] = false
			end

			this.Selections[i] = nextSelection
		end

		local hasMoreThanOneSelection = #this.Selections > 1
		leftButton.Visible = hasMoreThanOneSelection
		rightButton.Visible = hasMoreThanOneSelection
	end

	--------------------- SETUP -----------------------
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		local vrEnabled = VRService.VREnabled
		leftButton.Selectable = vrEnabled
		rightButton.Selectable = vrEnabled
		autoSelectButton.Selectable = vrEnabled
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	leftButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, -1)
		end
	end)
	leftButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, -1)
		end
	end)
	rightButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, 1)
		end
	end)
	rightButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, 1)
		end
	end)

	local isInTree = true
	this:UpdateOptions(selectionStringTable)

	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		if GuiService.SelectedCoreObject ~= this.SelectorFrame then return end

		if inputObject.KeyCode == Enum.KeyCode.DPadLeft or inputObject.KeyCode == Enum.KeyCode.Left or inputObject.KeyCode == Enum.KeyCode.A then
			stepFunc(inputObject, -1)
		elseif inputObject.KeyCode == Enum.KeyCode.DPadRight or inputObject.KeyCode == Enum.KeyCode.Right or inputObject.KeyCode == Enum.KeyCode.D then
			stepFunc(inputObject, 1)
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then
			lastInputDirection = 0
			return
		end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SelectorFrame.Parent) then return end

		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end


		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			stepFunc(inputObject, lastInputDirection)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			stepFunc(inputObject, lastInputDirection)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	this.SelectorFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
		if not isInTree then
			if guiServiceCon then guiServiceCon:Disconnect() end
		else
			connectToGuiService()
		end
	end)

	local function onResized(viewportSize, portrait)
		local textSize = 0
		if portrait then
			textSize = 16
		else
			textSize = isTenFootInterface() and 36 or 24
		end

		for i, selection in pairs(this.Selections) do
			selection.TextSize = textSize
		end
	end
	addOnResizedCallback(this.SelectorFrame, onResized)

	connectToGuiService()

	return this
end

local function ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	local parent = CoreGui.RobloxGui
	if parent:FindFirstChild("AlertViewFullScreen") then return end

	--Declare AlertViewBacking so onVREnabled can take it as an upvalue
	local AlertViewBacking = nil

	--Handle VR toggle while alert is open
	--Future consideration: maybe rebuild gui when VR toggles mid-game; right now only subpaneling is handled rather than visual style
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then return end
		local Panel3D, settingsPanel = nil, nil
		if VRService.VREnabled then
			Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D) :: any
			settingsPanel = Panel3D.Get("SettingsMenu")
			parent = settingsPanel:GetGUI()
		else
			parent = CoreGui.RobloxGui
		end
		if AlertViewBacking and AlertViewBacking.Parent ~= nil then
			AlertViewBacking.Parent = parent
			if VRService.VREnabled then
				settingsPanel:SetSubpanelDepth(AlertViewBacking, 0.5)
			end
		end
	end
	local vrEnabledConn = VRService.Changed:Connect(onVREnabled)

	AlertViewBacking = Util.Create'ImageLabel'
	{
		Name = "AlertViewBacking",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,

		ImageTransparency = 1,
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
		ZIndex = 9,
		Parent = parent
	};
	onVREnabled("VREnabled")
	if hasBackground or VRService.VREnabled then
		AlertViewBacking.ImageTransparency = 0
	else
		AlertViewBacking.Size = UDim2.new(0.8, 0, 0, 350)
		AlertViewBacking.Position = UDim2.new(0.1, 0, 0.1, 0)
	end

	if CoreGui.RobloxGui.AbsoluteSize.Y <= AlertViewBacking.Size.Y.Offset then
		AlertViewBacking.Size = UDim2.new(AlertViewBacking.Size.X.Scale, AlertViewBacking.Size.X.Offset,
			AlertViewBacking.Size.Y.Scale, CoreGui.RobloxGui.AbsoluteSize.Y)
		AlertViewBacking.Position = UDim2.new(AlertViewBacking.Position.X.Scale, -AlertViewBacking.Size.X.Offset/2, 0.5, -AlertViewBacking.Size.Y.Offset/2)
	end

	local _AlertViewText = Util.Create'TextLabel'
	{
		Name = "AlertViewText",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.95, 0, 0.6, 0),
		Position = UDim2.new(0.025, 0, 0.05, 0),
		Font = Enum.Font.SourceSansBold,
		TextSize = 36,
		Text = alertMessage,
		TextWrapped = true,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
		ZIndex = 10,
		Parent = AlertViewBacking
	};

	local _SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1
	};

	local removeId = HttpService:GenerateGUID(false)

	local destroyAlert = function(actionName, inputState)
		if VRService.VREnabled and (inputState == Enum.UserInputState.Begin or inputState == Enum.UserInputState.Cancel) then
			return
		end
		if not AlertViewBacking then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D) :: any
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(AlertViewBacking, 0)
		end
		AlertViewBacking:Destroy()
		AlertViewBacking = nil
		if okPressedFunc then
			okPressedFunc()
		end
		ContextActionService:UnbindCoreAction(removeId)
		GuiService.SelectedCoreObject = nil
		if settingsHub then
			settingsHub:ShowBar()
		end
		if vrEnabledConn then
			vrEnabledConn:Disconnect()
		end
	end

	local AlertViewButtonSize = UDim2.new(1, -20, 0, 60)
	local AlertViewButtonPosition = UDim2.new(0, 10, 0.65, 0)
	if not hasBackground then
		AlertViewButtonSize = UDim2.new(0, 200, 0, 50)
		AlertViewButtonPosition = UDim2.new(0.5, -100, 0.65, 0)
	end

	local AlertViewButton, AlertViewText = MakeButton("AlertViewButton", okButtonText, AlertViewButtonSize, destroyAlert)
	AlertViewButton.Position = AlertViewButtonPosition
	AlertViewButton.NextSelectionLeft = AlertViewButton
	AlertViewButton.NextSelectionRight = AlertViewButton
	AlertViewButton.NextSelectionUp = AlertViewButton
	AlertViewButton.NextSelectionDown = AlertViewButton
	AlertViewButton.ZIndex = 9
	AlertViewText.ZIndex = AlertViewButton.ZIndex
	AlertViewButton.Parent = AlertViewBacking

	if usesSelectedObject() then
		GuiService.SelectedCoreObject = AlertViewButton
	end

	GuiService.SelectedCoreObject = AlertViewButton

	ContextActionService:BindCoreAction(removeId, destroyAlert, false, Enum.KeyCode.Escape, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	if settingsHub and not VRService.VREnabled then
		settingsHub:HideBar()
		settingsHub.Pages.CurrentPage:Hide(1, 1)
	end
end

local function CreateNewSlider(numOfSteps, startStep, minStep)
	-------------------- SETUP ------------------------
	local this = {}

	local spacing = 4
	local steps = tonumber(numOfSteps)
	local currentStep = startStep

	local lastInputDirection = 0
	local timeAtLastInput = nil

	local interactable = true

	local renderStepBindName = HttpService:GenerateGUID(false)

	-- this is done to prevent using these values below (trying to keep the variables consistent)
	numOfSteps = ""
	startStep = ""

	if steps <= 0 then
		error("CreateNewSlider failed because numOfSteps (first arg) is 0 or negative, please supply a positive integer", 2)
		return
	end

	local valueChangedEvent = Instance.new("BindableEvent")
	valueChangedEvent.Name = "ValueChanged"

	----------------- GUI SETUP ------------------------
	this.SliderFrame = Util.Create'ImageButton'
	{
		Name = "Slider",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SliderFrame,
		NextSelectionRight = this.SliderFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0, 50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		SelectionImageObject = noSelectionObject,
		ZIndex = 2
	};

	this.StepsContainer = Util.Create "Frame"
	{
		Name = "StepsContainer",
		Position = UDim2.new(0.5, 0, 0.5, 0),
		Size = UDim2.new(1, -100, 1, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Parent = this.SliderFrame,
	}

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Less.png",
		ZIndex = 4,
		Parent = leftButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/More.png",
		ZIndex = 4,
		Parent = rightButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	if not UserInputService.TouchEnabled then
		local onNormalButtonState, onHoverButtonState =
			function(instance) 
				instance.ImageColor3 = ARROW_COLOR
			end,
			function(instance) 
				instance.ImageColor3 = ARROW_COLOR_HOVER
			end
		addHoverState(leftButton, leftButtonImage, onNormalButtonState, onHoverButtonState)
		addHoverState(rightButton, rightButtonImage, onNormalButtonState, onHoverButtonState)
	end

	this.Steps = {}

	local stepXScale = 1 / steps

	for i = 1, steps do
		local nextStep = Util.Create'ImageButton'
		{
			Name = "Step" .. tostring(i),
			BackgroundColor3 = SELECTED_COLOR,
			BackgroundTransparency = 0.36,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Active = false,
			AnchorPoint = Vector2.new(0, 0.5),
			Position = UDim2.new((i - 1) * stepXScale, spacing / 2, 0.5, 0),
			Size =  UDim2.new(stepXScale,-spacing, 24 / 50, 0),
			Image =  "",
			ZIndex = 3,
			Selectable = false,
			ImageTransparency = 0.36,
			Parent = this.StepsContainer,
			SelectionImageObject = noSelectionObject
		};

		if i > currentStep then
			nextStep.BackgroundColor3 = NON_SELECTED_COLOR
		end

		if i == 1 or i == steps then
			nextStep.BackgroundTransparency = 1
			nextStep.ScaleType = Enum.ScaleType.Slice
			nextStep.SliceCenter = Rect.new(3,3,32,21)

			if i <= currentStep then
				if i == 1 then
					nextStep.Image = SELECTED_LEFT_IMAGE
				else
					nextStep.Image = SELECTED_RIGHT_IMAGE
				end
			else
				if i == 1 then
					nextStep.Image = NON_SELECTED_LEFT_IMAGE
				else
					nextStep.Image = NON_SELECTED_RIGHT_IMAGE
				end
			end
		end

		this.Steps[#this.Steps + 1] = nextStep
	end


	------------------- FUNCTIONS ---------------------
	local function hideSelection()
		for i = 1, steps do
			this.Steps[i].BackgroundColor3 = NON_SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = NON_SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = NON_SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function showSelection()
		for i = 1, steps do
			if i > currentStep then break end
			this.Steps[i].BackgroundColor3 = SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function modifySelection(alpha)
		for i = 1, steps do
			if i == 1 or i == steps then
				this.Steps[i].ImageTransparency = alpha
			else
				this.Steps[i].BackgroundTransparency = alpha
			end
		end
	end

	local function setCurrentStep(newStepPosition)
		if not minStep then minStep = 0 end

		leftButton.Visible = true
		rightButton.Visible = true

		if newStepPosition <= minStep then
			newStepPosition = minStep
			leftButton.Visible = false
		end
		if newStepPosition >= steps then
			newStepPosition = steps
			rightButton.Visible = false
		end

		if currentStep == newStepPosition then return end

		currentStep = newStepPosition

		hideSelection()
		showSelection()

		timeAtLastInput = tick()
		valueChangedEvent:Fire(currentStep)
	end

	local function isActivateEvent(inputObject)
		if not inputObject then return false end
		return inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch or (inputObject.UserInputType == Enum.UserInputType.Gamepad1 and inputObject.KeyCode == Enum.KeyCode.ButtonA)
	end
	local function mouseDownFunc(inputObject, newStepPos, repeatAction)
		if not interactable then return end

		if inputObject == nil then return end

		if not isActivateEvent(inputObject) then return end

		if usesSelectedObject() and not VRService.VREnabled then
			GuiService.SelectedCoreObject = this.SliderFrame
		end

		if not VRService.VREnabled then
			if repeatAction then
				lastInputDirection = newStepPos - currentStep
			else
				lastInputDirection = 0

				local mouseInputMovedCon = nil
				local mouseInputEndedCon = nil

				mouseInputMovedCon = UserInputService.InputChanged:Connect(function(inputObject)
					if inputObject.UserInputType ~= Enum.UserInputType.MouseMovement then return end

					local mousePos = inputObject.Position.X
					for i = 1, steps do
						local stepPosition = this.Steps[i].AbsolutePosition.X
						local stepSize = this.Steps[i].AbsoluteSize.X
						if mousePos >= stepPosition and mousePos <= stepPosition + stepSize then
							setCurrentStep(i)
							break
						elseif i == 1 and mousePos < stepPosition then
							setCurrentStep(0)
							break
						elseif i == steps and mousePos >= stepPosition then
							setCurrentStep(i)
							break
						end
					end
				end)
				mouseInputEndedCon = UserInputService.InputEnded:Connect(function(inputObject)
					if not isActivateEvent(inputObject) then return end

					lastInputDirection = 0
					mouseInputEndedCon:Disconnect()
					mouseInputMovedCon:Disconnect()
				end)
			end
		else
			lastInputDirection = 0
		end

		setCurrentStep(newStepPos)
	end

	local function mouseUpFunc(inputObject)
		if not interactable then return end
		if not isActivateEvent(inputObject) then return end

		lastInputDirection = 0
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.ValueChanged = valueChangedEvent.Event

	function this:SetValue(newValue)
		setCurrentStep(newValue)
	end

	function this:GetValue()
		return currentStep
	end

	function this:SetInteractable(value)
		lastInputDirection = 0
		interactable = value
		this.SliderFrame.Selectable = value
		if not interactable then
			hideSelection()
		else
			showSelection()
		end
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Steps do
			this.Steps[i].ZIndex = newZIndex
		end
	end

	function this:SetMinStep(newMinStep)
		if newMinStep >= 0 and newMinStep <= steps then
			minStep = newMinStep
		end

		if currentStep <= minStep then
			currentStep = minStep
			leftButton.Visible = false
		end
		if currentStep >= steps then
			currentStep = steps
			rightButton.Visible = false
		end
	end

	--------------------- SETUP -----------------------

	leftButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep - 1, true) end)
	leftButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)
	rightButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep + 1, true) end)
	rightButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			leftButton.Selectable = interactable
			rightButton.Selectable = interactable
			this.SliderFrame.Selectable = interactable

			for i = 1, steps do
				this.Steps[i].Selectable = interactable
				this.Steps[i].Active = interactable
			end
		else
			leftButton.Selectable = false
			rightButton.Selectable = false
			this.SliderFrame.Selectable = interactable
			for i = 1, steps do
				this.Steps[i].Selectable = false
				this.Steps[i].Active = false
			end
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	for i = 1, steps do
		this.Steps[i].InputBegan:Connect(function(inputObject)
			mouseDownFunc(inputObject, i)
		end)
		this.Steps[i].InputEnded:Connect(function(inputObject)
			mouseUpFunc(inputObject) end)
	end

	this.SliderFrame.InputBegan:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseDownFunc(inputObject, currentStep)
	end)
	this.SliderFrame.InputEnded:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseUpFunc(inputObject)
	end)


	local stepSliderFunc = function()
		if timeAtLastInput == nil then return end

		local currentTime = tick()
		local timeSinceLastInput = currentTime - timeAtLastInput
		if timeSinceLastInput >= CONTROLLER_SCROLL_DELTA then
			setCurrentStep(currentStep + lastInputDirection)
		end
	end

	local isInTree = true

	local navigateLeft = -1 --these are just for differentiation, the actual value isn't important as long as they coerce to boolean true (all numbers do in Lua)
	local navigateRight = 1
	local navigationKeyCodes = {
		[Enum.KeyCode.Thumbstick1] = true, --thumbstick can be either direction
		[Enum.KeyCode.DPadLeft] = navigateLeft,
		[Enum.KeyCode.DPadRight] = navigateRight,
		[Enum.KeyCode.Left] = navigateLeft,
		[Enum.KeyCode.Right] = navigateRight,
		[Enum.KeyCode.A] = navigateLeft,
		[Enum.KeyCode.D] = navigateRight,
		[Enum.KeyCode.ButtonA] = true --buttonA can be either direction
	}
	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] == navigateLeft then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif navigationKeyCodes[inputObject.KeyCode] == navigateRight then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		end
	end)

	UserInputService.InputEnded:Connect(function(inputObject)
		if not interactable then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] then --detect any keycode considered a navigation key
			lastInputDirection = 0
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then
			lastInputDirection = 0
			return
		end
		if not isInTree then
			lastInputDirection = 0
			return
		end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	local isBound = false
	GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end

		local selected = GuiService.SelectedCoreObject
		local isThisSelected = selected and selected:IsDescendantOf(this.SliderFrame.Parent)
		if isThisSelected then
			modifySelection(0)
			if not isBound then
				isBound = true
				timeAtLastInput = tick()
				RunService:BindToRenderStep(renderStepBindName, Enum.RenderPriority.Input.Value + 1, stepSliderFunc)
			end
		else
			modifySelection(0.36)
			if isBound then
				isBound = false
				RunService:UnbindFromRenderStep(renderStepBindName)
			end
		end
	end)

	this.SliderFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
	end)

	setCurrentStep(currentStep)

	return this
end

local ROW_HEIGHT = 50
if isTenFootInterface() then ROW_HEIGHT = 90 end

local nextPosTable = {}
local function AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	local nextRowPositionY = 0
	local isARealRow = selectionType ~= 'TextBox' -- Textboxes are constructed in this function - they don't have an associated class.

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = nil
	RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(2, 2, 18, 18),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3

	if RowFrame and extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	local RowLabel = nil
	RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};

	local RowLabelTextSizeConstraint = Instance.new("UITextSizeConstraint")
	if FFlagUseNotificationsLocalization then
		RowLabel.Size = UDim2.new(0.35,0,1,0)
		RowLabel.TextScaled = true
		RowLabel.TextWrapped = true
		RowLabelTextSizeConstraint.Parent = RowLabel
		RowLabelTextSizeConstraint.MaxTextSize = 16
	end

	if not isARealRow then
		RowLabel.Text = ''
	end

	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
		RowLabelTextSizeConstraint.MaxTextSize = RowLabel.TextSize
	end
	onResized(getViewportSize(), isPortrait())
	addOnResizedCallback(RowFrame, onResized)

	local ValueChangerSelection = nil
	local ValueChangerInstance = nil
	if selectionType == "Slider" then
		ValueChangerInstance = CreateNewSlider(rowValues, rowDefault)
		ValueChangerInstance.SliderFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SliderFrame
	elseif selectionType == "Selector" then
		ValueChangerInstance = CreateSelector(rowValues, rowDefault)
		ValueChangerInstance.SelectorFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SelectorFrame
	elseif selectionType == "DropDown" then
		ValueChangerInstance = CreateDropDown(rowValues, rowDefault, pageToAddTo.HubRef)
		ValueChangerInstance.DropDownFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.DropDownFrame
	elseif selectionType == "TextBox" then
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.6,0,1,0),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(49, 49, 49),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Top,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
				box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.1

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.5
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						box:CaptureFocus()
					end
				end
			end
		end
		box.MouseEnter:Connect(setRowSelection)

		UserInputService.InputBegan:Connect(processInput)

	elseif selectionType == "TextEntry" then
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.4,-10,0,40),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(178, 178, 178),
			BackgroundTransparency = 1.0,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextXAlignment = Enum.TextXAlignment.Center,
			TextWrapped = false,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
				box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.8

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 1.0
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						box:CaptureFocus()
					end
				end
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		function ValueChangerInstance:SetZIndex(newZIndex)
			box.ZIndex = newZIndex
		end

		function ValueChangerInstance:SetInteractable(interactable)
			box.Selectable = interactable
			if not interactable then
				box.TextColor3 = Color3.fromRGB(49,49,49)
				box.ZIndex = 1
			else
				box.TextColor3 = Color3.fromRGB(178,178,178)
				box.ZIndex = 2
			end
		end

		function ValueChangerInstance:SetValue(value) -- should this do more?
			box.Text = value
		end

		local valueChangedEvent = Instance.new("BindableEvent")
		valueChangedEvent.Name = "ValueChanged"

		box.FocusLost:Connect(function()
			valueChangedEvent:Fire(box.Text)
		end)

		ValueChangerInstance.ValueChanged = valueChangedEvent.Event

		UserInputService.InputBegan:Connect(processInput)
	end

	ValueChangerInstance.Name = rowDisplayName .. "ValueChanger"

	local SetAutoLocalizeBase = ValueChangerInstance.SetAutoLocalize
	ValueChangerInstance.SetAutoLocalize = function(self, autoLocalize)
		RowFrame.AutoLocalize = autoLocalize
		if SetAutoLocalizeBase then
			SetAutoLocalizeBase(self, autoLocalize)
		end
	end

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	if isARealRow then
		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerInstance.SliderFrame
			if not valueFrame then
				valueFrame = ValueChangerInstance.SliderFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.DropDownFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.SelectorFrame
			end

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		--Could this be cleaned up even more?
		local function onVREnabled(prop)
			if prop == "VREnabled" then
				if VRService.VREnabled then
					RowFrame.Selectable = true
					RowFrame.Active = true
					ValueChangerSelection.Active = true
					GuiService.Changed:Connect(function(prop)
						if prop == "SelectedCoreObject" then
							local selected = GuiService.SelectedCoreObject
							if selected and (selected == RowFrame or selected:IsDescendantOf(RowFrame)) then
								RowFrame.ImageTransparency = 0.5
								RowFrame.BackgroundTransparency = 1
							else
								RowFrame.ImageTransparency = 1
								RowFrame.BackgroundTransparency = 1
							end
						end
					end)
				else
					RowFrame.Selectable = false
					RowFrame.Active = false
				end
			end
		end
		VRService.Changed:Connect(onVREnabled)
		onVREnabled("VREnabled")

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				if VRService.VREnabled then
					RowFrame.ImageTransparency = 0.5
					RowFrame.BackgroundTransparency = 1
				else
					RowFrame.ImageTransparency = 1
					RowFrame.BackgroundTransparency = 0.5
				end

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(RowFrame)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				RowFrame.ImageTransparency = 1
				RowFrame.BackgroundTransparency = 1
			end
		end)
	end

	pageToAddTo:AddRow(RowFrame, RowLabel, ValueChangerInstance, extraSpacing, false)

	ValueChangerInstance.Selection = ValueChangerSelection

	return RowFrame, RowLabel, ValueChangerInstance
end

local function AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	local nextRowPositionY = 0

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(10,10,10,10),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3
	RowFrame.SelectionGained:Connect(function()
		RowFrame.BackgroundTransparency = 0.5
	end)
	RowFrame.SelectionLost:Connect(function()
		RowFrame.BackgroundTransparency = 1
	end)

	local RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};
	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
	end
	addOnResizedCallback(RowFrame, onResized)

	if extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	local setRowSelection = function()
		if RowFrame.Visible then
			GuiService.SelectedCoreObject = RowFrame
		end
	end
	RowFrame.MouseEnter:Connect(setRowSelection)

	rowObject.SelectionImageObject = noSelectionObject

	rowObject.SelectionGained:Connect(function()
		if VRService.VREnabled then
			RowFrame.ImageTransparency = 0.5
			RowFrame.BackgroundTransparency = 1
		else
			RowFrame.ImageTransparency = 1
			RowFrame.BackgroundTransparency = 0.5
		end
	end)
	rowObject.SelectionLost:Connect(function()
		RowFrame.ImageTransparency = 1
		RowFrame.BackgroundTransparency = 1
	end)

	rowObject.Parent = RowFrame

	pageToAddTo:AddRow(RowFrame, RowLabel, rowObject, extraSpacing, true)
	return RowFrame
end

-------- public facing API ----------------
local moduleApiTable = {}

function moduleApiTable:Create(instanceType)
	return function(data)
		local obj = Instance.new(instanceType)
		local parent = nil
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			elseif k == 'Parent' then
				parent = v
			else
				obj[k] = v
			end
		end
		if parent then
			obj.Parent = parent
		end
		return obj
	end
end

-- RayPlaneIntersection (shortened)
-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function moduleApiTable:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit

	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function moduleApiTable:GetEaseLinear()
	return Linear
end
function moduleApiTable:GetEaseOutQuad()
	return EaseOutQuad
end
function moduleApiTable:GetEaseInOutQuad()
	return EaseInOutQuad
end

function moduleApiTable:CreateNewSlider(numOfSteps, startStep, minStep)
	return CreateNewSlider(numOfSteps, startStep, minStep)
end

function moduleApiTable:CreateNewSelector(selectionStringTable, startPosition)
	return CreateSelector(selectionStringTable, startPosition)
end

function moduleApiTable:CreateNewDropDown(dropDownStringTable, startPosition)
	return CreateDropDown(dropDownStringTable, startPosition, nil)
end

function moduleApiTable:AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	return AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
end

function moduleApiTable:AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	return AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
end

function moduleApiTable:ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
end

function moduleApiTable:IsSmallTouchScreen()
	return isSmallTouchScreen()
end

function moduleApiTable:IsPortrait()
	return isPortrait()
end

function moduleApiTable:MakeStyledButton(name, text, size, clickFunc, pageRef, hubRef)
	return MakeButton(name, text, size, clickFunc, pageRef, hubRef)
end

function moduleApiTable:MakeStyledImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	return MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
end

function moduleApiTable:AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	return AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
end

function moduleApiTable:CreateSignal()
	return CreateSignal()
end

function  moduleApiTable:UsesSelectedObject()
	return usesSelectedObject()
end

function moduleApiTable:TweenProperty(instance, prop, start, final, duration, easingFunc, cbFunc)
	return PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
end

function moduleApiTable:OnResized(key, callback)
	return addOnResizedCallback(key, callback)
end

function moduleApiTable:FireOnResized()
	local newSize = getViewportSize()
	local portrait = moduleApiTable:IsPortrait()

	for key, callback in pairs(onResizedCallbacks) do
		callback(newSize, portrait)
	end
end

-- Returns an interpolation between position0 and position1.
--	Returns position0 when t = 0, and position1 when t = 1.
function moduleApiTable:Lerp(t, position0, position1)
	return (1 - t) * position0 + t * position1
end

-- Returns a rounded number
function moduleApiTable:Round(n)
	return n % 1 >= 0.5 and math.ceil(n) or math.floor(n)
end

function moduleApiTable:IsExperienceOlderThanOneWeek(gameInfo)
	if gameInfo ~= nil and gameInfo.Created ~= nil then
		local dateTime = DateTime.fromIsoDate(gameInfo.Created)
		local createdDateUnixMillis = dateTime.UnixTimestampMillis
		local currDateUnixMillis = Workspace:GetServerTimeNow() * MILLISECONDS_PER_SECOND

		if currDateUnixMillis - createdDateUnixMillis > MILLISECONDS_PER_WEEK then
			return true
		end
	end

	return false
end


return moduleApiTable
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="24">
            <Properties>
              <string name="Name">VRUtil</string>
              <string name="Source"><![CDATA[--!nonstrict
--Modules/VR/VRUtil.lua

local VRService = game:GetService("VRService")

local VRUtil = {}

function VRUtil.GetUserCFrameWorldSpace(userCFrameType)
	local userCFrame = VRService:GetUserCFrame(userCFrameType)

	if not (workspace.CurrentCamera :: Camera).HeadLocked then
		local headCFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
		userCFrame = headCFrame:Inverse() * userCFrame
	end

	return (workspace.CurrentCamera :: Camera).CFrame * (CFrame.new(userCFrame.p * (workspace.CurrentCamera :: Camera).HeadScale) * (userCFrame - userCFrame.p))
end

return VRUtil
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">State</string>
        </Properties>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">CameraService</string>
            <string name="Source">--[[
TheNexusAvenger

Manages the local camera.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local DefaultCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("DefaultCamera"))
local ThirdPersonTrackCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("ThirdPersonTrackCamera"))

local CameraService = {}
CameraService.__index = CameraService
local StaticInstance = nil

export type CameraService = {
    new: () -> (CameraService),
    GetInstance: () -> (CameraService),

    ActiveCamera: string,
    RegisterCamera: (self: CameraService, Name: string, Camera: CameraInterface) -> (),
    SetActiveCamera: (self: CameraService, Name: string) -> (),
    UpdateCamera: (self: CameraService, HeadsetCFrameWorld: CFrame) -> (),
}

export type CameraInterface = {
    Enable: (self: CameraInterface) -> (),
    Disable: (self: CameraInterface) -> (),
    UpdateCamera: (self: CameraInterface, HeadsetCFrameWorld: CFrame) -> (),
}



--[[
Creates a camera service.
--]]
function CameraService.new(): CameraService
    --Create the object.
    local self = {
        RegisteredCameras = {},
    }
    setmetatable(self, CameraService)

    --Register the default controllers.
    self:RegisterCamera("Default", DefaultCamera.new())
    self:RegisterCamera("ThirdPersonTrack", ThirdPersonTrackCamera.new())

    --Return the object.
    return (self :: any) :: CameraService
end

--[[
Returns a singleton instance of the camera service.
--]]
function CameraService.GetInstance(): CameraService
    if not StaticInstance then
        StaticInstance = CameraService.new()
    end
    return StaticInstance
end

--[[
Registers a camera.
--]]
function CameraService:RegisterCamera(Name: string, Camera: CameraInterface): ()
    self.RegisteredCameras[Name] = Camera
end

--[[
Sets the active camera.
--]]
function CameraService:SetActiveCamera(Name: string): ()
    --Return if the camera didn't change.
    if self.ActiveCamera == Name then return end
    self.ActiveCamera = Name

    --Disable the current camera.
    if self.CurrentCamera then
        self.CurrentCamera:Disable()
    end

    --Enable the new camera.
    self.CurrentCamera = self.RegisteredCameras[Name]
    if self.CurrentCamera then
        self.CurrentCamera:Enable()
    elseif Name ~= nil then
        warn("Nexus VR Character Model camera \""..tostring(Name).."\" is not registered.")
    end
end

--[[
Updates the local camera.
--]]
function CameraService:UpdateCamera(HeadsetCFrameWorld: CFrame): ()
    if self.CurrentCamera then
        self.CurrentCamera:UpdateCamera(HeadsetCFrameWorld)
    end
end



return (CameraService :: any) :: CameraService</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">CharacterService</string>
            <string name="Source">--[[
TheNexusAvenger

Manages VR characters.
--]]
--!strict

local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent
local Character = require(NexusVRCharacterModel:WaitForChild("Character"))

local CharacterService = {}
CharacterService.__index = CharacterService
local StaticInstance = nil

export type CharacterService = {
    new: () -> (CharacterService),
    GetInstance: () -> (CharacterService),

    GetCharacter: (self: CharacterService, Player: Player) -> (Character.Character?),
}



--[[
Creates a character service.
--]]
function CharacterService.new(): CharacterService
    --Create the object.
    local self = {
        Characters = {},
    }
    setmetatable(self, CharacterService)

    --Connect clearing players.
    Players.PlayerRemoving:Connect(function(Player)
        self.Characters[Player] = nil
    end)

    --Return the object.
    return (self :: any) :: CharacterService
end

--[[
Returns a singleton instance of the character service.
--]]
function CharacterService.GetInstance(): CharacterService
    if not StaticInstance then
        StaticInstance = CharacterService.new()
    end
    return StaticInstance
end

--[[
Returns the VR character for a player.
--]]
function CharacterService:GetCharacter(Player: Player): Character.Character?
    --Return if the character is nil.
    if not Player.Character then
        return nil
    end

    --Create the VR character if it isn't valid.
    if not self.Characters[Player] or self.Characters[Player].Character ~= Player.Character then
        self.Characters[Player] = {
            Character = Player.Character,
            VRCharacter = Character.new(Player.Character :: Model),
        }
    end

    --Return the stored character.
    return self.Characters[Player].VRCharacter
end



return (CharacterService :: any) :: CharacterService</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="28">
          <Properties>
            <string name="Name">ControlService</string>
            <string name="Source">--[[
TheNexusAvenger

Manages controlling the local characters.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local BaseController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("BaseController"))
local TeleportController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("TeleportController"))
local SmoothLocomotionController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("SmoothLocomotionController"))

local ControlService = {}
ControlService.__index = ControlService
local StaticInstance = nil

export type ControlService = {
    new: () -> (ControlService),
    GetInstance: () -> (ControlService),

    ActiveController: string,
    RegisterController: (self: ControlService, Name: string, Controller: ControllerInterface) -> (),
    SetActiveController: (self: ControlService, Name: string) -> (),
    UpdateCharacter: (self: ControlService) -> (),
}

export type ControllerInterface = {
    Disable: (self: ControllerInterface) -> (),
    Enable: (self: ControllerInterface) -> (),
    UpdateCharacter: (self: ControllerInterface) -> (),
}



--[[
Creates a control service.
--]]
function ControlService.new(): ControlService
    --Create the object.
    local self = {
        RegisteredControllers = {},
    }
    setmetatable(self, ControlService)

    --Register the default controllers.
    self:RegisterController("None", BaseController.new())
    self:RegisterController("Teleport", TeleportController.new())
    self:RegisterController("SmoothLocomotion", SmoothLocomotionController.new())

    --Return the object.
    return (self :: any) :: ControlService
end

--[[
Returns a singleton instance of the character service.
--]]
function ControlService.GetInstance(): ControlService
    if not StaticInstance then
        StaticInstance = ControlService.new()
    end
    return StaticInstance
end

--[[
Registers a controller.
--]]
function ControlService:RegisterController(Name: string, Controller: any): ()
    self.RegisteredControllers[Name] = Controller
end

--[[
Sets the active controller.
--]]
function ControlService:SetActiveController(Name: string): ()
    --Return if the controller didn't change.
    if self.ActiveController == Name then return end
    self.ActiveController = Name

    --Disable the current controller.
    if self.CurrentController then
        self.CurrentController:Disable()
    end

    --Enable the new controller.
    self.CurrentController = self.RegisteredControllers[Name]
    if self.CurrentController then
        self.CurrentController:Enable()
    elseif Name ~= nil then
        warn("Nexus VR Character Model controller \""..tostring(Name).."\" is not registered.")
    end
end

--[[
Updates the local character.
--]]
function ControlService:UpdateCharacter()
    if self.CurrentController then
        self.CurrentController:UpdateCharacter()
    end
end



return (ControlService :: any) :: ControlService</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="29">
          <Properties>
            <string name="Name">DefaultCursorService</string>
            <string name="Source">--[[
TheNexusAvenger

Manages toggling the default cursor.
Workaround for: https://github.com/TheNexusAvenger/Nexus-VR-Character-Model/issues/10
--]]
--!strict

local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")

local DefaultCursorService = {}
DefaultCursorService.__index = DefaultCursorService
local StaticInstance = nil

export type DefaultCursorService = {
    new: () -> (DefaultCursorService),
    GetInstance: () -> (DefaultCursorService),

    CursorOptionsList: {string},
    CurrentCursorState: string,
    SetCursorState: (self: DefaultCursorService, OptionName: string) -> (),
}



--[[
Creates a default cursor service.
--]]
function DefaultCursorService.new(): DefaultCursorService
    --Create the object.
    local self = {}
    setmetatable(self, DefaultCursorService)

    --Register the default values.
    self.CursorOptionsList = {"Detect", "Enabled", "Disabled"}
    self.CursorOptions = {
        Detect = function()
            --Enable the pointer.
            StarterGui:SetCore("VRLaserPointerMode", "Pointer")

            --Wait until the next frame to register the BindToRenderStep. Otherwise, the order is
            RunService.Stepped:Wait()

            --Enable the workaround for moving the pointer when the cursor isn't active.
            --It must be Last + 1 because the Core Script uses Last.
            RunService:BindToRenderStep("NexusVRCharacterModel_MoveCursorWorkaround", Enum.RenderPriority.Last.Value + 1, function()
                local Camera = Workspace.CurrentCamera
                local VRCoreEffectParts = Camera:FindFirstChild("VRCoreEffectParts")
                if VRCoreEffectParts then
                    local LaserPointerOrigin = VRCoreEffectParts:FindFirstChild("LaserPointerOrigin")
                    local Cursor = VRCoreEffectParts:FindFirstChild("Cursor")
                    if LaserPointerOrigin and Cursor then
                        local CursorSurfaceGui = Cursor:FindFirstChild("CursorSurfaceGui")
                        if CursorSurfaceGui and not CursorSurfaceGui.Enabled then
                            LaserPointerOrigin.CFrame = CFrame.new(0, math.huge, 0)
                        end
                    end
                end
            end)
        end,
        Enabled = function()
            StarterGui:SetCore("VRLaserPointerMode", "Pointer")
        end,
        Disabled = function()
            StarterGui:SetCore("VRLaserPointerMode", "Disabled")
        end,
    }
    self.CursorDisabledOptions = {
        Detect = function()
            RunService:UnbindFromRenderStep("NexusVRCharacterModel_MoveCursorWorkaround")
        end,
    }

    --Return the object.
    return (self :: any) :: DefaultCursorService
end

--[[
Returns a singleton instance of the character service.
--]]
function DefaultCursorService.GetInstance(): DefaultCursorService
    if not StaticInstance then
        StaticInstance = DefaultCursorService.new()
    end
    return StaticInstance
end

--[[
Sets the cursor state.
--]]
function DefaultCursorService:SetCursorState(OptionName: string): ()
    if self.CurrentCursorState == OptionName then return end
    if self.CurrentCursorState and self.CursorDisabledOptions[self.CurrentCursorState] then
        self.CursorDisabledOptions[self.CurrentCursorState]()
    end
    self.CurrentCursorState = OptionName
    task.spawn(self.CursorOptions[OptionName])
end



return DefaultCursorService</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">RateLimiter</string>
            <string name="Source">--[[
TheNexusAvenger

Performs rate limit checks on inputs.
--]]
--!strict

local Players = game:GetService("Players")

local RateLimiter = {}
RateLimiter.__index = RateLimiter

export type RateLimiter = {
    new: (RateLimit: number?, RefrestDuration: number?) -> (RateLimiter),

    RateLimitReached: (self: RateLimiter, Key: any) -> (boolean),
}



--[[
Creates a rate limiter.
The rate limit must be >=1.
--]]
function RateLimiter.new(RateLimit: number?, RefrestDuration: number?): RateLimiter
    --Create the object.
    local self = {
        RateLimit = RateLimit or 1,
        RefrestDuration = RefrestDuration or 1,
        UsedLimits = {}
    }
    setmetatable(self, RateLimiter)

    --Connect removing player keys.
    Players.PlayerRemoving:Connect(function(Player: Player)
        if self.UsedLimits[Player] then
            self.UsedLimits[Player] = nil
        end
    end)

    --Return the object.
    return (self :: any) :: RateLimiter
end

--[[
Returns if the rate limit was reached
for a given key.
--]]
function RateLimiter:RateLimitReached(Key: any): boolean
    --Add the key if it isn't defined.
    if not self.UsedLimits[Key] then
        self.UsedLimits[Key] = {
            StartTime = tick(),
            Count = 0,
        }
    end

    --Reset the key if the refresh time was reached.
    local StoredKey = self.UsedLimits[Key]
    local CurrentTime = tick()
    if CurrentTime > StoredKey.StartTime + self.RefrestDuration then
        StoredKey.StartTime = CurrentTime
        StoredKey.Count = 0
    end

    --Increment the counter and return if the limit was reached.
    StoredKey.Count = StoredKey.Count + 1
    return StoredKey.Count > self.RateLimit
end



return (RateLimiter :: any) :: RateLimiter</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="31">
          <Properties>
            <string name="Name">Settings</string>
            <string name="Source">--[[
TheNexusAvenger

Stores settings.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local Settings ={}
Settings.__index = Settings
local StaticInstance = nil

export type Settings ={
    new: () -> (Settings),
    GetInstance: () -> (Settings),

    GetSetting: (self: Settings, Setting: string) -> (any),
    SetSetting: (self: Settings, Setting: string, Value: any) -> (),
    SetDefaults: (self: Settings, Defaults: {[string]: any}) -> (),
    SetOverrides: (self: Settings, Overrides: {[string]: any}) -> (),
    GetSettingsChangedSignal: (self: Settings, Setting: string) -> (NexusEvent.NexusEvent&lt;>),
    Destroy: (self: Settings) -> (),
}



--[[
Creates a settings object.
--]]
function Settings.new(): Settings
    return (setmetatable({
        Defaults = {},
        Overrides = {},
        SettingsChangeEvents = {},
        SettingsCache = {},
    }, Settings) :: any) :: Settings
end

--[[
Returns a singleton instance of settings.
--]]
function Settings.GetInstance(): Settings
    if not StaticInstance then
        StaticInstance = Settings.new()
    end
    return StaticInstance
end

--[[
Returns the value of a setting.
--]]
function Settings:GetSetting(Setting: string): any
    --Return a cached entry if one exists.
    if self.SettingsCache[Setting] ~= nil then
        return self.SettingsCache[Setting]
    end

    --Get the table containing the setting.
    local Defaults, Overrides = self.Defaults, self.Overrides
    local SplitSettingNames = string.split(Setting, ".")
    for i = 1, #SplitSettingNames - 1 do
        Defaults = Defaults[SplitSettingNames[i]] or {}
        Overrides = Overrides[SplitSettingNames[i]] or {}
    end

    --Return the value.
    local Value = Overrides[SplitSettingNames[#SplitSettingNames]]
    if Value == nil then
        Value = Defaults[SplitSettingNames[#SplitSettingNames]]
    end
    self.SettingsCache[Setting] = Value
    return Value
end

--[[
Sets the value of a setting.
--]]
function Settings:SetSetting(Setting: string, Value: any): ()
    --Set the setting.
    local Overrides = self.Overrides
    local SplitSettingNames = string.split(Setting,".")
    for i = 1, #SplitSettingNames - 1 do
        if not Overrides[SplitSettingNames[i]] then
            Overrides[SplitSettingNames[i]] = {}
        end
        Overrides = Overrides[SplitSettingNames[i]]
    end
    Overrides[SplitSettingNames[#SplitSettingNames]] = Value
    self.SettingsCache[Setting] = Value

    --Fire the changed signal.
    local Event = self.SettingsChangeEvents[string.lower(Setting)]
    if Event then
        Event:Fire()
    end
end

--[[
Sets all the defaults.
--]]
function Settings:SetDefaults(Defaults: {[string]: any}): ()
    --Set the defaults.
    self.Defaults = Defaults
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        Event:Fire()
    end
end

--[[
Sets all the overrides.
--]]
function Settings:SetOverrides(Overrides: {[string]: any}): ()
    --Set the overrides.
    self.Overrides = Overrides
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        Event:Fire()
    end
end

--[[
Returns a changed signal for a setting.
--]]
function Settings:GetSettingsChangedSignal(Overrides: string): NexusEvent.NexusEvent&lt;>
    Overrides = string.lower(Overrides)

    --Create the event if none exists.
    if not self.SettingsChangeEvents[Overrides] then
        self.SettingsChangeEvents[Overrides] = NexusEvent.new()
    end

    --Return the event.
    return self.SettingsChangeEvents[Overrides]
end

--[[
Destroys the settings.
--]]
function Settings:Destroy(): ()
    --Disconnect the settings.
    for _,Event in self.SettingsChangeEvents do
        Event:Disconnect()
    end
    self.SettingsChangeEvents = {}
end



return Settings</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">VRInputService</string>
            <string name="Source">--[[
TheNexusAvenger

Manages VR inputs. This normalizes the inputs from
the headsets as the Y position of the inputs is arbitrary,
meaning it can be the floor, eye level, or random.
--]]
--!strict

local THUMBSTICK_SAMPLES_TO_RESET = 5



local NexusVRCharacterModel = script.Parent.Parent
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local VRInputService = {}
VRInputService.__index = VRInputService
local StaticInstance = nil

export type VRInputService = {
    new: (VRService: VRService?, UserInputService: UserInputService?) -> (VRInputService),
    GetInstance: () -> (VRInputService),

    Recentered: NexusEvent.NexusEvent&lt;>,
    EyeLevelSet: NexusEvent.NexusEvent&lt;>,
    GetVRInputs: (self: VRInputService) -> ({[Enum.UserCFrame]: CFrame}),
    Recenter: (self: VRInputService) -> (),
    SetEyeLevel: (self: VRInputService) -> (),
    GetThumbstickPosition: (self: VRInputService, Thumbsick: Enum.KeyCode) -> (Vector3),
}



--[[
Creates a settings object.
--]]
function VRInputService.new(VRService: VRService?, UserInputService: UserInputService?): VRInputService
    --Create the object.
    local self = {
        RecenterOffset = CFrame.new(),
    }
    setmetatable(self, VRInputService)

    --Store the services for testing.
    self.VRService = VRService or game:GetService("VRService")
    self.UserInputService = UserInputService or game:GetService("UserInputService")

    --Create the events.
    self.Recentered = NexusEvent.new()
    self.EyeLevelSet = NexusEvent.new()

    --Connect updating the thumbsticks.
    self.ThumbstickValues = {
        [Enum.KeyCode.Thumbstick1] = Vector3.new(),
        [Enum.KeyCode.Thumbstick2] = Vector3.new(),
    }
    self.PreviousThumbstickValues = {
        [Enum.KeyCode.Thumbstick1] = {},
        [Enum.KeyCode.Thumbstick2] = {},
    }
    self.CurrentThumbstickPointers = {
        [Enum.KeyCode.Thumbstick1] = 1,
        [Enum.KeyCode.Thumbstick2] = 1,
    }
    self.InputsDown = {
        [Enum.KeyCode.Thumbstick1] = false,
        [Enum.KeyCode.Thumbstick2] = false,
    }
    self.UserInputService.InputBegan:Connect(function(Input)
        if self.InputsDown[Input.KeyCode] ~= nil then
            self.InputsDown[Input.KeyCode] = true
        end
    end)
    self.UserInputService.InputEnded:Connect(function(Input)
        if self.InputsDown[Input.KeyCode] then
            self.InputsDown[Input.KeyCode] = false
        end
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Vector3.new()
        end
    end)
    self.UserInputService.InputChanged:Connect(function(Input)
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Input.Position
        end
    end)

    --Return the object.
    return (self :: any) :: VRInputService
end

--[[
Returns a singleton instance of the VR input service.
--]]
function VRInputService.GetInstance(): VRInputService
    if not StaticInstance then
        StaticInstance = VRInputService.new()
    end
    return StaticInstance
end

--[[
Returns the VR inputs to use. The inputs are normalized
so that 0 is the head height.
--]]
function VRInputService:GetVRInputs(): {[Enum.UserCFrame]: CFrame}
    --Get the head input.
    local VRInputs = {
        [Enum.UserCFrame.Head] = self.VRService:GetUserCFrame(Enum.UserCFrame.Head),
    } :: {[Enum.UserCFrame]: CFrame}

    --Get the hand inputs.
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand) then
        VRInputs[Enum.UserCFrame.LeftHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
    else
        VRInputs[Enum.UserCFrame.LeftHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(-1, -2.5, 0.5)
    end
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) then
        VRInputs[Enum.UserCFrame.RightHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.RightHand)
    else
        VRInputs[Enum.UserCFrame.RightHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(1, -2.5, 0.5)
    end

    --Determine the height offset.
    local HeightOffset = 0
    if self.ManualNormalHeadLevel then
        --Adjust to normalize the height around the set value.
        HeightOffset = -self.ManualNormalHeadLevel
    else
        --Adjust to normalize the height around the highest value.
        --The head CFrame is moved back 0.5 studs for when the headset suddenly goes up (like putting on and taking off).
        local CurrentVRHeadHeight = (VRInputs[Enum.UserCFrame.Head] * CFrame.new(0, 0, 0.5)).Y
        if not self.HighestHeadHeight or CurrentVRHeadHeight > self.HighestHeadHeight then
            self.HighestHeadHeight = CurrentVRHeadHeight
        end
        HeightOffset = -self.HighestHeadHeight
    end

    --Normalize the CFrame heights.
    --A list of enums is used instead of VRInputs because modifying a table stops pairs().
    for _, InputEnum in {Enum.UserCFrame.Head, Enum.UserCFrame.LeftHand, Enum.UserCFrame.RightHand} do
        VRInputs[InputEnum] = CFrame.new(0, HeightOffset, 0) * self.RecenterOffset * VRInputs[InputEnum]
    end

    --Return the CFrames.
    return VRInputs
end

--[[
Recenters the service.
Does not alter the Y axis.
--]]
function VRInputService:Recenter(): ()
    local HeadCFrame = self.VRService:GetUserCFrame(Enum.UserCFrame.Head)
    self.RecenterOffset = CFrame.Angles(0, -math.atan2(-HeadCFrame.LookVector.X, -HeadCFrame.LookVector.Z), 0) * CFrame.new(-HeadCFrame.X, 0, -HeadCFrame.Z)
    self.Recentered:Fire()
end

--[[
Sets the eye level.
--]]
function VRInputService:SetEyeLevel(): ()
    self.ManualNormalHeadLevel = self.VRService:GetUserCFrame(Enum.UserCFrame.Head).Y
    self.EyeLevelSet:Fire()
end

--[[
Returns the current value for a thumbstick.
--]]
function VRInputService:GetThumbstickPosition(Thumbsick: Enum.KeyCode): Vector3
    --Return if the value isn't supported.
    if not self.ThumbstickValues[Thumbsick] then
        return Vector3.zero
    end

    --Store the polled value.
    self.PreviousThumbstickValues[Thumbsick][self.CurrentThumbstickPointers[Thumbsick]] = self.ThumbstickValues[Thumbsick]
    self.CurrentThumbstickPointers[Thumbsick] = (self.CurrentThumbstickPointers[Thumbsick] :: number % THUMBSTICK_SAMPLES_TO_RESET) + 1

    --Determine if the polled values are exactly the same.
    --Closeness is not used as the thumbstick being held in place will register as slightly different values.
    --This happens if the trigger is released (such as a touchpad, which may not automatically reset).
    local ValuesSame = true
    local InitialValue = self.PreviousThumbstickValues[Thumbsick][1]
    for i = 2, THUMBSTICK_SAMPLES_TO_RESET do
        if self.PreviousThumbstickValues[Thumbsick][i] ~= InitialValue then
            ValuesSame = false
            break
        end
    end

    --Return either the stored value or the empty vector if the last polled samples are the same.
    if ValuesSame and not self.InputsDown[Thumbsick] then
        return Vector3.zero
    else
        return self.ThumbstickValues[Thumbsick]
    end
end



return (VRInputService :: any) :: VRInputService</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="33">
        <Properties>
          <string name="Name">UI</string>
        </Properties>
        <Item class="ModuleScript" referent="34">
          <Properties>
            <string name="Name">MainMenu</string>
            <string name="Source">--[[
TheNexusAvenger

Main menu for Nexus VR Character Model.
--]]
--!strict

local MENU_OPEN_TIME_REQUIREMENT = 1
local MENU_OPEN_TIME = 0.25



local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent.Parent
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
local ApiBaseView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ApiBaseView"))
local ChatView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ChatView"))
local SettingsView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("SettingsView"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")
local NexusVRCore = require(ReplicatedStorage:WaitForChild("NexusVRCore")) :: any
local ScreenGui = NexusVRCore:GetResource("Container.ScreenGui")

local MainMenu = {}
MainMenu.__index = MainMenu
local StaticInstance = nil



--[[
Creates the main menu.
--]]
function MainMenu.new(): any
    local self = {}
    setmetatable(self, MainMenu)

    --Set up the ScreenGui.
    local MainMenuScreenGui = ScreenGui.new()
    MainMenuScreenGui.ResetOnSpawn = false
    MainMenuScreenGui.Enabled = false
    MainMenuScreenGui.CanvasSize = Vector2.new(500, 600)
    MainMenuScreenGui.FieldOfView = 0
    MainMenuScreenGui.Easing = 0.25
    self.ScreenGui = MainMenuScreenGui

    --Create the parent frame, display text, and toggle buttons.
    local ViewAdornFrame = Instance.new("Frame")
    ViewAdornFrame.BackgroundTransparency = 1
    ViewAdornFrame.Size = UDim2.new(0, 500, 0, 500)
    ViewAdornFrame.Parent = MainMenuScreenGui:GetContainer()
    self.ViewAdornFrame = ViewAdornFrame

    local LeftButton, LeftText = TextButtonFactory:Create()
    LeftButton.Size = UDim2.new(0, 80, 0, 80)
    LeftButton.Position = UDim2.new(0, 10, 0, 510)
    LeftButton.Parent = MainMenuScreenGui:GetContainer()
    LeftText.Text = "&lt;"
    self.LeftButton = LeftButton

    local RightButton, RightText = TextButtonFactory:Create()
    RightButton.Size = UDim2.new(0, 80, 0, 80)
    RightButton.Position = UDim2.new(0, 410, 0, 510)
    RightButton.Parent = MainMenuScreenGui:GetContainer()
    RightText.Text = ">"
    self.RightButton = RightButton

    local ViewTextLabel = Instance.new("TextLabel")
    ViewTextLabel.BackgroundTransparency = 1
    ViewTextLabel.Size = UDim2.new(0, 300, 0, 60)
    ViewTextLabel.Position = UDim2.new(0, 100, 0, 520)
    ViewTextLabel.Font = Enum.Font.SourceSansBold
    ViewTextLabel.TextScaled = true
    ViewTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ViewTextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    ViewTextLabel.TextStrokeTransparency = 0
    ViewTextLabel.Parent = MainMenuScreenGui:GetContainer()
    self.ViewTextLabel = ViewTextLabel

    --Set up the default views.
    self.CurrentView = 1
    self.Views = {}
    (SettingsView :: any).new(self:CreateView("Settings"));
    (ChatView :: any).new(self:CreateView("Chat"))
    self:UpdateVisibleView()

    --Connect changing views.
    local DB = true
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --De-increment the current view.
        self.CurrentView = self.CurrentView - 1
        if self.CurrentView == 0 then
            self.CurrentView = #self.Views
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --Increment the current view.
        self.CurrentView = self.CurrentView + 1
        if self.CurrentView > #self.Views then
            self.CurrentView = 1
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)

    --Parent the menu.
    MainMenuScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Returns a singleton instance of the character service.
--]]
function MainMenu.GetInstance(): any
    if not StaticInstance then
        StaticInstance = MainMenu.new()
    end
    return StaticInstance
end

--[[
Sets up opening based on the controllers
being rotated upwards.
--]]
function MainMenu:SetUpOpening(): ()
    --Create the animation parts.
    local LeftAdornPart = Instance.new("Part")
    LeftAdornPart.Transparency = 1
    LeftAdornPart.Size = Vector3.new()
    LeftAdornPart.Anchored = true
    LeftAdornPart.CanCollide = false
    LeftAdornPart.CanQuery = false
    LeftAdornPart.Parent = Workspace.CurrentCamera

    local LeftAdorn = Instance.new("BoxHandleAdornment")
    LeftAdorn.Color3 = Color3.fromRGB(0, 170, 255)
    LeftAdorn.AlwaysOnTop = true
    LeftAdorn.ZIndex = 0
    LeftAdorn.Adornee = LeftAdornPart
    LeftAdorn.Parent = LeftAdornPart

    local RightAdornPart = Instance.new("Part")
    RightAdornPart.Transparency = 1
    RightAdornPart.Size = Vector3.new()
    RightAdornPart.Anchored = true
    RightAdornPart.CanCollide = false
    RightAdornPart.CanQuery = false
    RightAdornPart.Parent = Workspace.CurrentCamera

    local RightAdorn = Instance.new("BoxHandleAdornment")
    RightAdorn.Color3 = Color3.fromRGB(0, 170 , 255)
    RightAdorn.AlwaysOnTop = true
    RightAdorn.ZIndex = 0
    RightAdorn.Adornee = RightAdornPart
    RightAdorn.Parent = RightAdornPart

    local LeftMenuToggleHintAdornPart = Instance.new("Part")
    LeftMenuToggleHintAdornPart.Transparency = 1
    LeftMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    LeftMenuToggleHintAdornPart.Anchored = true
    LeftMenuToggleHintAdornPart.CanCollide = false
    LeftMenuToggleHintAdornPart.CanQuery = false
    LeftMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local RightMenuToggleHintAdornPart = Instance.new("Part")
    RightMenuToggleHintAdornPart.Transparency = 1
    RightMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    RightMenuToggleHintAdornPart.Anchored = true
    RightMenuToggleHintAdornPart.CanCollide = false
    RightMenuToggleHintAdornPart.CanQuery = false
    RightMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local LeftMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiFront.Active = false
    LeftMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    LeftMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiFront.LightInfluence = 0
    LeftMenuToggleHintGuiFront.AlwaysOnTop = true
    LeftMenuToggleHintGuiFront.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiFront.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontArrow.ImageTransparency = 1
    LeftMenuToggleHintFrontArrow.BackgroundTransparency = 1
    LeftMenuToggleHintFrontArrow.Rotation = 180
    LeftMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(0,0)
    LeftMenuToggleHintFrontArrow.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintFrontText = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontText.ImageTransparency = 1
    LeftMenuToggleHintFrontText.BackgroundTransparency = 1
    LeftMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontText.ZIndex = 2
    LeftMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintFrontText.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiBack.Active = false
    LeftMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    LeftMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiBack.LightInfluence = 0
    LeftMenuToggleHintGuiBack.AlwaysOnTop = true
    LeftMenuToggleHintGuiBack.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiBack.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintBackArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintBackArrow.ImageTransparency = 1
    LeftMenuToggleHintBackArrow.BackgroundTransparency = 1
    LeftMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(512,0)
    LeftMenuToggleHintBackArrow.Parent = LeftMenuToggleHintGuiBack

    local LeftMenuToggleHintBackText = Instance.new("ImageLabel")
    LeftMenuToggleHintBackText.ImageTransparency = 1
    LeftMenuToggleHintBackText.BackgroundTransparency = 1
    LeftMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackText.ZIndex = 2
    LeftMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintBackText.Parent = LeftMenuToggleHintGuiBack

    local RightMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiFront.Active = false
    RightMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    RightMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiFront.LightInfluence = 0
    RightMenuToggleHintGuiFront.AlwaysOnTop = true
    RightMenuToggleHintGuiFront.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiFront.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    RightMenuToggleHintFrontArrow.ImageTransparency = 1
    RightMenuToggleHintFrontArrow.BackgroundTransparency = 1
    RightMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(512,0)
    RightMenuToggleHintFrontArrow.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintFrontText = Instance.new("ImageLabel")
    RightMenuToggleHintFrontText.ImageTransparency = 1
    RightMenuToggleHintFrontText.BackgroundTransparency = 1
    RightMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontText.ZIndex = 2
    RightMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintFrontText.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiBack.Active = false
    RightMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    RightMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiBack.LightInfluence = 0
    RightMenuToggleHintGuiBack.AlwaysOnTop = true
    RightMenuToggleHintGuiBack.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiBack.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintBackArrow = Instance.new("ImageLabel")
    RightMenuToggleHintBackArrow.ImageTransparency = 1
    RightMenuToggleHintBackArrow.BackgroundTransparency = 1
    RightMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(0,0)
    RightMenuToggleHintBackArrow.Parent = RightMenuToggleHintGuiBack

    local RightMenuToggleHintBackText = Instance.new("ImageLabel")
    RightMenuToggleHintBackText.BackgroundTransparency = 1
    RightMenuToggleHintBackText.Rotation = 180
    RightMenuToggleHintBackText.ImageTransparency = 1
    RightMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackText.ZIndex = 2
    RightMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintBackText.Parent = RightMenuToggleHintGuiBack

    --Connect hiding the hints when the setting changes.
    Settings:GetSettingsChangedSignal("Menu.MenuToggleGestureActive"):Connect(function()
        --Determine if the gesture is active.
        local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
        if MenuToggleGestureActive == nil then
            MenuToggleGestureActive = true
        end

        --Update the visibility of the hints.
        LeftMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        LeftMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
    end)


    --Start checking for the controllers to be upside down.
    --Done in a task since this function is non-yielding.
    local BothControllersUpStartTime
    local MenuToggleReached = false
    task.spawn(function()
        while true do
            --Determine if the gesture is active.
            local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
            if MenuToggleGestureActive == nil then
                MenuToggleGestureActive = true
            end

            --Get the inputs and determine if the hands are both upside down and pointing forward.
            local VRInputs = VRInputService:GetVRInputs()
            local LeftHandCFrameRelative, RightHandCFrameRelative = VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.LeftHand], VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.RightHand]
            local LeftHandFacingUp, RightHandFacingUp = LeftHandCFrameRelative.UpVector.Y &lt; 0, RightHandCFrameRelative.UpVector.Y &lt; 0
            local LeftHandFacingForward, RightHandFacingForward = LeftHandCFrameRelative.LookVector.Z &lt; 0, RightHandCFrameRelative.LookVector.Z &lt; 0
            local LeftHandUp, RightHandUp = LeftHandFacingUp and LeftHandFacingForward, RightHandFacingUp and RightHandFacingForward
            local BothHandsUp = MenuToggleGestureActive and LeftHandUp and RightHandUp
            if BothHandsUp then
                BothControllersUpStartTime = BothControllersUpStartTime or tick()
            else
                BothControllersUpStartTime = nil :: any
                MenuToggleReached = false
            end

            --Update the adorn part CFrames.
            local CameraCenterCFrame = Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse()
            LeftAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand] * CFrame.new(0, -0.25, 0.25)
            RightAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand] * CFrame.new(0, -0.25, 0.25)
            LeftMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand]
            RightMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand]

            --Update the progress bars.
            if BothControllersUpStartTime and not MenuToggleReached then
                local DeltaTimePercent = (tick() - BothControllersUpStartTime) / MENU_OPEN_TIME_REQUIREMENT
                LeftAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                RightAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                LeftAdorn.Visible = true
                RightAdorn.Visible = true

                --Toggle the menu if the time threshold was reached.
                if DeltaTimePercent >= 1 then
                    MenuToggleReached = true
                    task.spawn(function()
                        self:Toggle()
                    end)
                end
            else
                LeftAdorn.Visible = false
                RightAdorn.Visible = false
            end

            --[[
            Updates the given hint parts.
            --]]
            local function UpdateHintParts(Visible,Part,FrontArrow,BackArrow,FrontText,BackText)
                local TweenData = TweenInfo.new(0.25)
                TweenService:Create(Part,TweenData,{
                    Size = Visible and Vector3.new(1, 1, 0) or Vector3.new(1.5, 1.5, 0)
                }):Play()
                TweenService:Create(FrontArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(FrontText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
            end

            --Update the hints.
            local LeftHandHintVisible, RightHandHintVisible = self.ScreenGui.Enabled and not LeftHandUp, self.ScreenGui.Enabled and not RightHandUp
            if self.LeftHandHintVisible ~= LeftHandHintVisible then
                self.LeftHandHintVisible = LeftHandHintVisible
                UpdateHintParts(LeftHandHintVisible, LeftMenuToggleHintAdornPart, LeftMenuToggleHintFrontArrow, LeftMenuToggleHintBackArrow, LeftMenuToggleHintFrontText, LeftMenuToggleHintBackText)
            end
            if self.RightHandHintVisible ~= RightHandHintVisible then
                self.RightHandHintVisible = RightHandHintVisible
                UpdateHintParts(RightHandHintVisible, RightMenuToggleHintAdornPart, RightMenuToggleHintFrontArrow, RightMenuToggleHintBackArrow, RightMenuToggleHintFrontText, RightMenuToggleHintBackText)
            end
            local Rotation = (tick() * 10) % 360
            LeftMenuToggleHintFrontArrow.Rotation = Rotation
            LeftMenuToggleHintBackArrow.Rotation = -Rotation
            RightMenuToggleHintFrontArrow.Rotation = -Rotation
            RightMenuToggleHintBackArrow.Rotation = Rotation

            --Wait to poll again.
            RunService.RenderStepped:Wait()
        end
    end)
end

--[[
Toggles the menu being open.
--]]
function MainMenu:Toggle(): ()
    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (self.ScreenGui.Enabled and math.rad(40) or 0), (self.ScreenGui.Enabled and 0 or math.rad(40))

    --Show the menu if it isn't visible.
    if not self.ScreenGui.Enabled then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime &lt; MENU_OPEN_TIME do
        local Delta = (tick() - StartTime) / MENU_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe menu if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Registers a view.
--]]
function MainMenu:RegisterView(ViewName: string, ViewInstance: any): ()
    warn("MainMenu::RegisterView is deprecated and may be removed in the future. Use MainMenu::CreateView instead.")

    --Set up the view instance.
    ViewInstance.Visible = false
    ViewInstance.Name = ViewName
    ViewInstance.Parent = self.ViewAdornFrame

    --Store the view.
    table.insert(self.Views, ViewInstance)
end

--[[
Creates a menu view.
--]]
function MainMenu:CreateView(InitialViewName: string): any
    --Create and store the view.
    local View = ApiBaseView.new(InitialViewName)
    View.Frame.Parent = (self :: any).ViewAdornFrame
    table.insert(self.Views, View)

    --Connect the events.
    View:GetPropertyChangedSignal("Name"):Connect(function()
        self:UpdateVisibleView()
    end)
    View.Destroyed:Connect(function()
        for i = 1, #self.Views do
            if self.Views[i] == View then
                table.remove(self.Views, i)
                if self.CurrentView > i then
                    self.CurrentView += -1
                end
                break
            end
        end
        self:UpdateVisibleView()
    end)
    return View
end

--[[
Updates the visible view.
--]]
function MainMenu:UpdateVisibleView(): ()
    --Update the button visibility.
    self.LeftButton.Visible = (#self.Views > 1)
    self.RightButton.Visible = (#self.Views > 1)

    --Update the display text.
    self.ViewTextLabel.Text = self.Views[self.CurrentView].Name

    --Update the view visibilites.
    for i, View in self.Views do
        View.Visible = (i == self.CurrentView)
    end
end



return MainMenu</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="35">
          <Properties>
            <string name="Name">R6Message</string>
            <string name="Source">--[[
TheNexusAvenger

Displays a message if R6 is used.
--]]
--!strict

local MESSAGE_OPEN_TIME = 0.25



local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local NexusVRCharacterModel = script.Parent.Parent
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")
local NexusVRCore = require(ReplicatedStorage:WaitForChild("NexusVRCore")) :: any
local ScreenGui = NexusVRCore:GetResource("Container.ScreenGui")

local R6Message = {}
R6Message.__index = R6Message



--[[
Creates the R6 message.
--]]
function R6Message.new(): any
    local self = {}
    setmetatable(self, R6Message)

    --Set up the ScreenGui.
    local MessageScreenGui = ScreenGui.new()
    MessageScreenGui.ResetOnSpawn = false
    MessageScreenGui.Enabled = false
    MessageScreenGui.CanvasSize = Vector2.new(500, 500)
    MessageScreenGui.FieldOfView = 0
    MessageScreenGui.Easing = 0.25
    self.ScreenGui = MessageScreenGui

    --Create the logo and message.
    local Logo = Instance.new("ImageLabel")
    Logo.BackgroundTransparency = 1
    Logo.Size = UDim2.new(0.4, 0, 0.4, 0)
    Logo.Position = UDim2.new(0.3, 0, -0.1, 0)
    Logo.Image = "http://www.roblox.com/asset/?id=1499731139"
    Logo.Parent = MessageScreenGui:GetContainer()

    local UpperText = Instance.new("TextLabel")
    UpperText.BackgroundTransparency = 1
    UpperText.Size = UDim2.new(0.8, 0, 0.1, 0)
    UpperText.Position = UDim2.new(0.1, 0, 0.25, 0)
    UpperText.Font = Enum.Font.SourceSansBold
    UpperText.Text = "R6 Not Supported"
    UpperText.TextScaled = true
    UpperText.TextColor3 = Color3.fromRGB(255, 255, 255)
    UpperText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    UpperText.TextStrokeTransparency = 0
    UpperText.Parent = MessageScreenGui:GetContainer()

    local LowerText = Instance.new("TextLabel")
    LowerText.BackgroundTransparency = 1
    LowerText.Size = UDim2.new(0.8, 0, 0.25, 0)
    LowerText.Position = UDim2.new(0.1, 0, 0.4, 0)
    LowerText.Font = Enum.Font.SourceSansBold
    LowerText.Text = "Nexus VR Character Model does not support using R6. Use R15 instead."
    LowerText.TextScaled = true
    LowerText.TextColor3 = Color3.fromRGB(255, 255, 255)
    LowerText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    LowerText.TextStrokeTransparency = 0
    LowerText.Parent = MessageScreenGui:GetContainer()

    --Create and connect the close button.
    local CloseButton, CloseText = TextButtonFactory:Create()
    CloseButton.Size = UDim2.new(0.3, 0, 0.1, 0)
    CloseButton.Position = UDim2.new(0.35, 0, 0.7, 0)
    CloseButton.Parent = MessageScreenGui:GetContainer()
    CloseText.Text = "Ok"

    CloseButton.MouseButton1Down:Connect(function()
        self:SetOpen(false)
        MessageScreenGui:Destroy()
    end)

    --Parent the message.
    MessageScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Sets the window open or closed.
--]]
function R6Message:SetOpen(Open: boolean): ()
    warn(Open)
    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (Open and 0 or math.rad(40)), (Open and math.rad(40) or 0)

    --Show the message if it isn't visible.
    if Open then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime &lt; MESSAGE_OPEN_TIME do
        local Delta = (tick() - StartTime) / MESSAGE_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe message if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Opens the message.
--]]
function R6Message:Open(): ()
    self:SetOpen(true)
end



return R6Message</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="36">
          <Properties>
            <string name="Name">View</string>
          </Properties>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">ApiBaseView</string>
              <string name="Source">--[[
TheNexusAvenger

Base view for the menu intended to be used with the API.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local NexusEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local ApiBaseView = NexusInstance:Extend()
ApiBaseView:SetClassName("ApiBaseView")

export type ApiBaseView = {
    new: (InitialName: string) -> ApiBaseView,
    Extend: (self: ApiBaseView) -> ApiBaseView,

    Name: string,
    Visible: boolean,
    Destroyed: NexusEvent.NexusEvent&lt;>,
    GetContainer: (self: ApiBaseView) -> (Frame),
} &amp; NexusInstance.NexusInstance



--[[
Creates the view.
--]]
function ApiBaseView:__new(InitialName: string): ()
    NexusInstance.__new(self)
    self.Name = InitialName
    self.Destroyed = NexusEvent.new()

    self.Frame = Instance.new("Frame")
    self.Frame.Name = tostring(self.Name)
    self.Frame.BackgroundTransparency = 1
    self.Frame.Size = UDim2.new(1, 0, 1, 0)
    self.Frame.Visible = false
    self.Frame.SizeConstraint = Enum.SizeConstraint.RelativeXX
    self:GetPropertyChangedSignal("Name"):Connect(function()
        self.Frame.Name = tostring(self.Name)
    end)
    self:GetPropertyChangedSignal("Visible"):Connect(function()
        self.Frame.Visible = self.Visible
    end)
end

--[[
Returns the containing frame.
--]]
function ApiBaseView:GetContainer(): Frame
    return self.Frame
end

--[[
Destroys the view.
--]]
function ApiBaseView:Destroy(): ()
    ApiBaseView.Destroy(self)
    self.Destroyed:Fire()
    self.Destroyed:Disconnect()
end



return (ApiBaseView :: any) :: ApiBaseView</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="38">
            <Properties>
              <string name="Name">ChatView</string>
              <string name="Source">--[[
TheNexusAvenger

View for the chat.
Just moves the chat window. Does not
add any additional functionality.
--]]
--!strict

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local ChatView = NexusInstance:Extend()
ChatView:SetClassName("ChatView")



--[[
Creates the chat view.
--]]
function ChatView:__new(View: any): ()
    NexusInstance.__new(self)

    task.spawn(function()
        --Wait for a request to load the chat.
        --Starting release 544, the chat is loaded automatically.
        local Container = View:GetContainer()
        local LoadChatButton, LoadChatText = TextButtonFactory:Create()
        LoadChatButton.AnchorPoint = Vector2.new(0.5, 0.5)
        LoadChatButton.Size = UDim2.new(0.6, 0, 0.1, 0)
        LoadChatButton.Position = UDim2.new(0.5, 0, 0.5, 0)
        LoadChatButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
        LoadChatButton.Parent = Container
        LoadChatText.Text = "Load Chat"
        LoadChatButton.MouseButton1Down:Wait()
        LoadChatButton:Destroy()

        --Load the chat.
        --Taken from the main script.
        local Chat = require(Players.LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("ChatScript"):WaitForChild("ChatMain")) :: any
        local ClientChatModules = game:GetService("Chat"):WaitForChild("ClientChatModules")
        local ChatSettings = require(ClientChatModules:WaitForChild("ChatSettings")) :: any
        if not Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("Chat") then
            local containerTable = {}
            containerTable.ChatWindow = {}
            containerTable.SetCore = {}
            containerTable.GetCore = {}

            containerTable.ChatWindow.ChatTypes = {}
            containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = ChatSettings.BubbleChatEnabled
            containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = ChatSettings.ClassicChatEnabled

            --// Connection functions
            local function ConnectEvent(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                event.Event:Connect(function(...) Chat[name](Chat, ...) end)
            end

            local function ConnectFunction(name)
                local func = Instance.new("BindableFunction")
                func.Name = name
                containerTable.ChatWindow[name] = func :: any

                func.OnInvoke = function(...) return Chat[name](Chat, ...) end
            end

            local function ReverseConnectEvent(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                Chat[name]:Connect(function(...) event:Fire(...) end)
            end

            local function ConnectSignal(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.ChatWindow[name] = event

                event.Event:Connect(function(...) Chat[name]:fire(...) end)
            end

            local function ConnectSetCore(name)
                local event = Instance.new("BindableEvent")
                event.Name = name
                containerTable.SetCore[name] = event

                event.Event:Connect(function(...) Chat[name.."Event"]:fire(...) end)
            end

            local function ConnectGetCore(name)
                local func = Instance.new("BindableFunction")
                func.Name = name
                containerTable.GetCore[name] = func

                func.OnInvoke = function(...) return Chat["f"..name](...) end
            end

            --// Do connections
            ConnectEvent("ToggleVisibility")
            ConnectEvent("SetVisible")
            ConnectEvent("FocusChatBar")
            ConnectEvent("EnterWhisperState")
            ConnectFunction("GetVisibility")
            ConnectFunction("GetMessageCount")
            ConnectEvent("TopbarEnabledChanged")
            ConnectFunction("IsFocused")

            ReverseConnectEvent("ChatBarFocusChanged")
            ReverseConnectEvent("VisibilityStateChanged")
            ReverseConnectEvent("MessagesChanged")
            ReverseConnectEvent("MessagePosted")

            ConnectSignal("CoreGuiEnabled")

            ConnectSetCore("ChatMakeSystemMessage")
            ConnectSetCore("ChatWindowPosition")
            ConnectSetCore("ChatWindowSize")
            ConnectGetCore("ChatWindowPosition")
            ConnectGetCore("ChatWindowSize")
            ConnectSetCore("ChatBarDisabled")
            ConnectGetCore("ChatBarDisabled")
        end

        --Move the chat GUI to the container.
        local ChatWindow = Players.LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("Chat")
        while #ChatWindow:GetChildren() == 0 do task.wait() end
        local ChatFrame = ChatWindow:FindFirstChildOfClass("Frame")
        ChatFrame.Size = UDim2.new(1, 0, 1, 0)
        ChatFrame.Parent = Container

        --Connect starting chat.
        --For some reason, it is not done when VR is enabled.
        UserInputService.InputBegan:Connect(function(Input,Processed)
            if Processed then return end
            if not UserInputService:GetFocusedTextBox() and Input.KeyCode == Enum.KeyCode.Slash and Container.Visible then
                --Focus the chat bar.
                --Done the next frame so that the slash is not inputted.
                RunService.Stepped:Wait()
                Chat:FocusChatBar()
            end
        end)

        --Force the GUI to always be visible.
        --Bit hacky and relies on checking for the passed value to be not false and not nil instead of checking if it true.
        while true do
            Chat:SetVisible(tick())
            task.wait(0.1)
        end
    end)
end




return ChatView</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="39">
            <Properties>
              <string name="Name">SettingsView</string>
              <string name="Source">--[[
TheNexusAvenger

View for the user settings.
--]]
--!strict

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
local DefaultCursorService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local SettingsView = NexusInstance:Extend()
SettingsView:SetClassName("SettingsView")



--[[
Creates the settings view.
--]]
function SettingsView:__new(View: any): ()
    NexusInstance.__new(self)

    --Create the header.
    local Container = View:GetContainer()
    local HeaderLogo = Instance.new("ImageLabel")
    HeaderLogo.BackgroundTransparency = 1
    HeaderLogo.Size = UDim2.new(0.4, 0, 0.4, 0)
    HeaderLogo.Position = UDim2.new(0.3, 0, -0.1, 0)
    HeaderLogo.Image = "http://www.roblox.com/asset/?id=1499731139"
    HeaderLogo.Parent = Container

    local NameText = Instance.new("TextLabel")
    NameText.BackgroundTransparency = 1
    NameText.Size = UDim2.new(0.8, 0, 0.1, 0)
    NameText.Position = UDim2.new(0.1, 0, 0.2, 0)
    NameText.Font = Enum.Font.SourceSansBold
    NameText.Text = "Nexus VR Character Model"
    NameText.TextScaled = true
    NameText.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    NameText.TextStrokeTransparency = 0
    NameText.Parent = Container

    --Create the settings.
    local CameraSettingFrame = Instance.new("Frame")
    CameraSettingFrame.BackgroundTransparency = 1
    CameraSettingFrame.Size = UDim2.new(0.8, 0,0.11, 0)
    CameraSettingFrame.Position = UDim2.new(0.1, 0, 0.325, 0)
    CameraSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CameraSettingFrame, "View", "Camera.EnabledCameraOptions", function()
        return CameraService.ActiveCamera
    end, function(NewValue)
        CameraService:SetActiveCamera(NewValue)
    end)

    local MovementSettingFrame = Instance.new("Frame")
    MovementSettingFrame.BackgroundTransparency = 1
    MovementSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    MovementSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 1), 0)
    MovementSettingFrame.Parent = Container
    self:PopulateSettingsFrame(MovementSettingFrame, "Control", "Movement.EnabledMovementMethods", function()
        return ControlService.ActiveController
    end, function(NewValue)
        ControlService:SetActiveController(NewValue)
    end)

    local CursorSettingFrame = Instance.new("Frame")
    CursorSettingFrame.BackgroundTransparency = 1
    CursorSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    CursorSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 2), 0)
    CursorSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CursorSettingFrame, "Roblox VR Cursor", function()
        return DefaultCursorService.CursorOptionsList
    end, function()
        return DefaultCursorService.CurrentCursorState
    end, function(NewValue)
        DefaultCursorService:SetCursorState(NewValue)
    end)

    --Create the callibration settings.
    local RecenterButton,RecenterText = TextButtonFactory:Create()
    RecenterButton.Size = UDim2.new(0.4, 0, 0.075, 0)
    RecenterButton.Position = UDim2.new(0.075, 0, 0.85, 0)
    RecenterButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RecenterButton.Parent = Container
    RecenterText.Text = "Recenter"

    RecenterButton.MouseButton1Down:Connect(function()
        VRInputService:Recenter()
    end)

    local SetEyeLevelButton,SetEyeLevelText = TextButtonFactory:Create()
    SetEyeLevelButton.Size = UDim2.new(0.4, 0, 0.075, 0)
    SetEyeLevelButton.Position = UDim2.new(0.525, 0, 0.85, 0)
    SetEyeLevelButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    SetEyeLevelButton.Parent = Container
    SetEyeLevelText.Text = " Set Eye Level "

    SetEyeLevelButton.MouseButton1Down:Connect(function()
        VRInputService:SetEyeLevel()
    end)
end

--[[
Popuulates a setting frame.
--]]
function SettingsView:PopulateSettingsFrame(ContainerFrame: Frame, HeaderName: string, GetOptionsSettings: () -> ({string}), GetValueFunction: () -> (string), SetValueFunction: (string) -> ()?): ()
    --Converrt the GetOptionsSettings callback if it is a string.
    local OptionsSetting = nil
    if typeof(GetOptionsSettings) == "string" then
        OptionsSetting = GetOptionsSettings
        GetOptionsSettings = function()
            return Settings:GetSetting(OptionsSetting) or {}
        end
    end

    --Create the frames.
    local LeftButton,LeftText = TextButtonFactory:Create()
    LeftButton.Size = UDim2.new(1, 0, 1, 0)
    LeftButton.Position = UDim2.new(0, 0, 0, 0)
    LeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    LeftButton.Parent = ContainerFrame
    LeftText.Text = "&lt;"

    local RightButton,RightText = TextButtonFactory:Create()
    RightButton.AnchorPoint = Vector2.new(1, 0)
    RightButton.Size = UDim2.new(1, 0, 1, 0)
    RightButton.Position = UDim2.new(1, 0, 0, 0)
    RightButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RightButton.Parent = ContainerFrame
    RightText.Text = ">"

    local OptionHeaderText = Instance.new("TextLabel")
    OptionHeaderText.BackgroundTransparency = 1
    OptionHeaderText.Size = UDim2.new(0.8, 0, 0.5, 0)
    OptionHeaderText.Position = UDim2.new(0.1, 0, -0.0125, 0)
    OptionHeaderText.Font = Enum.Font.SourceSansBold
    OptionHeaderText.Text = HeaderName
    OptionHeaderText.TextScaled = true
    OptionHeaderText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionHeaderText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionHeaderText.TextStrokeTransparency = 0
    OptionHeaderText.Parent = ContainerFrame

    local OptionText = Instance.new("TextLabel")
    OptionText.BackgroundTransparency = 1
    OptionText.Size = UDim2.new(0.6, 0, 0.7, 0)
    OptionText.Position = UDim2.new(0.2, 0, 0.3, 0)
    OptionText.Font = Enum.Font.SourceSansBold
    OptionText.TextScaled = true
    OptionText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionText.TextStrokeTransparency = 0
    OptionText.Parent = ContainerFrame

    --[[
    Updates the settings.
    --]]
    local function UpdateSettings(Increment: number?): ()
        --Get the current value id.
        local InitialValueName = GetValueFunction()
        local CurrentValue = 1
        local Options = GetOptionsSettings()
        for i,Option in pairs(Options) do
            if Option == InitialValueName then
                CurrentValue = i
                break
            end
        end

        --Increment the value.
        if Increment and Increment ~= 0 then
            CurrentValue = CurrentValue + Increment
            if CurrentValue &lt;= 0 then
                CurrentValue = #Options
            end
            if CurrentValue > #Options then
                CurrentValue = 1
            end
        end

        --Update the button visibility.
        LeftButton.Visible = (#Options > 1)
        RightButton.Visible = (#Options > 1)

        --Update the display text.
        OptionText.Text = Options[CurrentValue] or "(N/A)"

        --Set the new value.
        if Increment and Increment ~= 0 and Options[CurrentValue] then
            (SetValueFunction :: (string) -> ())(Options[CurrentValue])
        end
    end

    --Connect the events.
    local DB = true
    if OptionsSetting then
        Settings:GetSettingsChangedSignal(OptionsSetting):Connect(UpdateSettings)
    end
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(-1)
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(1)
        task.wait()
        DB = true
    end)

    --Update the initial settings.
    UpdateSettings()
end



return SettingsView</string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="40">
        <Properties>
          <string name="Name">Util</string>
        </Properties>
        <Item class="ModuleScript" referent="41">
          <Properties>
            <string name="Name">FindCollidablePartOnRay</string>
            <string name="Source">--[[
TheNexusAvenger

Helper function that ray casts to
find a collidable part.
--]]
--!strict

local Workspace = game:GetService("Workspace")



--[[
Ray casts to find a collidable part.
--]]
local function FindCollidablePartOnRay(StartPosition: Vector3, Direction: Vector3, IgnoreList: Instance | {Instance}?, CollisionGroup: string?): (BasePart?, Vector3)
    --Convert the collision group.
    if typeof(CollisionGroup) == "Instance" and CollisionGroup:IsA("BasePart") then
        CollisionGroup = CollisionGroup.CollisionGroup
    end

    --Create the ignore list.
    local Camera = Workspace.CurrentCamera
    local NewIgnoreList = {Camera}
    if typeof(IgnoreList) == "Instance" then
        table.insert(NewIgnoreList, IgnoreList)
    elseif typeof(IgnoreList) == "table" then
        for _, Entry in IgnoreList do
            if Entry ~= Camera then
                table.insert(NewIgnoreList, Entry)
            end
        end
    end

    --Create the parameters.
    local RaycastParameters = RaycastParams.new()
    RaycastParameters.FilterType = Enum.RaycastFilterType.Blacklist
    RaycastParameters.FilterDescendantsInstances = NewIgnoreList
    RaycastParameters.IgnoreWater = true
    if CollisionGroup then
        RaycastParameters.CollisionGroup = CollisionGroup
    end

    --Raycast and continue if the hit part isn't collidable.
    local RaycastResult = Workspace:Raycast(StartPosition, Direction, RaycastParameters)
    if not RaycastResult then
        return nil, StartPosition + Direction
    end
    local HitPart,EndPosition = RaycastResult.Instance, RaycastResult.Position
    if HitPart and not HitPart.CanCollide and (not HitPart:IsA("Seat") or not HitPart:IsA("VehicleSeat") or HitPart.Disabled) then
        table.insert(NewIgnoreList, HitPart)
        return FindCollidablePartOnRay(EndPosition, Direction + (EndPosition - StartPosition), NewIgnoreList, CollisionGroup)
    end

    --Return the hit result.
    return HitPart, EndPosition
end



return FindCollidablePartOnRay</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="42">
          <Properties>
            <string name="Name">Warnings</string>
            <string name="Source">--[[
TheNexusAvenger

Displays warnings when loading Nexus VR Character Model.
--]]
--!strict

local HttpService = game:GetService("HttpService")



return function(): ()
    --Load the configuration.
    local ConfigurationValue = script.Parent.Parent:WaitForChild("Configuration")
    local Configuration = HttpService:JSONDecode(ConfigurationValue.Value)

    --Determine the suppressed warnings.
    local SupressedWarnings = {}
    if Configuration.Output and Configuration.Output.SuppressWarnings then
        for _, WarningName in Configuration.Output.SuppressWarnings do
            SupressedWarnings[string.lower(WarningName)] = true
        end
    end
    if SupressedWarnings["all"] then return end

    --Build the warnings.
    local Warnings = {
        {
            Key = "MissingNexusVRBackpackEnabled",
            Message = "The configuration entry Extra.NexusVRBackpackEnabled is missing (defaults to true).",
            Condition = function()
               return Configuration.Extra == nil or Configuration.Extra.NexusVRBackpackEnabled == nil
            end
        },
        {
            Key = "MissingAllowClientToOutputLoadedMessage",
            Message = "The configuration entry Extra.AllowClientToOutputLoadedMessage is missing (defaults to true).",
            Condition = function()
               return Configuration.Output == nil or Configuration.Output.AllowClientToOutputLoadedMessage == nil
            end
        },
    }

    --Output the warnings.
    for _, Warning in Warnings do
        if not SupressedWarnings[string.lower(Warning.Key)] and Warning.Condition() then
            warn(Warning.Message)
            warn("\tThis warning can be disabled by adding \""..Warning.Key.."\" or \"All\" to Output.SuppressWarnings in the configuration of Nexus VR Character Model.")
        end
    end
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="43">
        <Properties>
          <string name="Name">NexusButton</string>
          <string name="Source">--[[
TheNexusAvenger

Main module representing the button class. This button
is meant to provide an easy way to make "good looking",
cross platform buttons.
--]]
--!strict

local HOVER_COLOR_MULTIPLIER = 0.7
local PRESS_COLOR_MULTIPLIER = 1 / 0.7
local CONTROLLER_SECTION_COLOR = Color3.new(50 / 255, 50 / 255, 50 / 255)
local DEFAULT_THEMES = {
    CutCorners = {
        MainButton = {
            Image = "rbxassetid://9708818802",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    CutTopLeftCorner = {
        MainButton = {
            Image = "rbxassetid://9708819815",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708825225",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    CutBottomRightCorner = {
        MainButton = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9708824372",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
    RoundedCorners = {
        MainButton = {
            Image = "rbxassetid://9704725601",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://9704725809",
            SliceCenter = Rect.new(500, 500, 524, 524),
            SliceScaleMultiplier = 0.2 / 500,
        },
    },
}



local GuiService = game:GetService("GuiService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local ControllerIcon = require(script:WaitForChild("ControllerIcon"))
local NexusWrappedInstance = require(script:WaitForChild("NexusWrappedInstance"))

local NexusButton = NexusWrappedInstance:Extend()
NexusButton.Themes = DEFAULT_THEMES
NexusButton:SetClassName("NexusButton")

export type NexusButtonTheme = {
    MainButton: {
        Image: string,
        SliceCenter: Rect,
        SliceScaleMultiplier: number,
    },
    GamepadIconBackground: {
        Image: string,
        SliceCenter: Rect,
        SliceScaleMultiplier: number,
    },
}
export type NexusButton = {
    new: () -> NexusButton,
    Extend: (self: NexusButton) -> NexusButton,

    BorderSizeScale: number,
    TweenDuration: number,
    Theme: string,
    OverrideButtonProperty: (self: NexusButton, PropertyName: string, SetFunction: (any) -> ()) -> (),
    GetAdornFrame: (self: NexusButton) -> Frame,
    SetControllerIcon: (self: NexusButton, KeyCode: Enum.KeyCode | string) -> (),
    MapKey: (self: NexusButton, KeyCode: Enum.KeyCode | string, MouseInput: Enum.UserInputType | string) -> (),
    UnmapKey: (KeyCode: Enum.KeyCode | string) -> (),
} &amp; NexusWrappedInstance.NexusWrappedInstance &amp; TextButton



--[[
Multiplies a Color3.
--]]
local function MultiplyColor3(Color: Color3, Multiplier: number): Color3
    return Color3.new(math.clamp(Color.R * Multiplier, 0, 1), math.clamp(Color.G * Multiplier, 0, 1), math.clamp(Color.B * Multiplier, 0, 1))
end

--[[
Creates a Nexus Button object.
--]]
function NexusButton:__new(): ()
    NexusWrappedInstance.__new(self, "TextButton")

    --Create the frames.
    local BaseButton = self:GetWrappedInstance()
    BaseButton.BackgroundTransparency = 1
    BaseButton.Text = ""

    local BorderFrame = Instance.new("ImageLabel")
    BorderFrame.BackgroundTransparency = 1
    BorderFrame.ScaleType = Enum.ScaleType.Slice
    BorderFrame.Parent = BaseButton
    self:DisableChangeReplication("BorderFrame")
    self.BorderFrame = BorderFrame

    local BackgroundFrame = Instance.new("ImageLabel")
    BackgroundFrame.BackgroundTransparency = 1
    BackgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    BackgroundFrame.ZIndex = 2
    BackgroundFrame.ScaleType = Enum.ScaleType.Slice
    BackgroundFrame.Parent = BaseButton
    self:DisableChangeReplication("BackgroundFrame")
    self.BackgroundFrame = BackgroundFrame

    BackgroundFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateSliceScale()
        self:UpdateBorder(false)
    end)

    local ContentsAdorn = Instance.new("Frame")
    ContentsAdorn.BackgroundTransparency = 1
    ContentsAdorn.Size = UDim2.new(1, 0, 1, 0)
    ContentsAdorn.ZIndex = 3
    ContentsAdorn.Parent = BaseButton
    self:DisableChangeReplication("ContentsAdorn")
    self.ContentsAdorn = ContentsAdorn

    local GamepadIcon = ControllerIcon.new()
    GamepadIcon.AdornFrame.ImageColor3 = CONTROLLER_SECTION_COLOR
    GamepadIcon.AdornFrame.Size = UDim2.new(1, 0, 1, 0)
    GamepadIcon.AdornFrame.Position = UDim2.new(1, 0, 0, 0)
    GamepadIcon.AdornFrame.SizeConstraint = Enum.SizeConstraint.RelativeYY
    GamepadIcon.AdornFrame.AnchorPoint = Vector2.new(1, 0)
    GamepadIcon.AdornFrame.ZIndex = 4
    GamepadIcon.AdornFrame.ScaleType = Enum.ScaleType.Slice
    GamepadIcon.AdornFrame.Parent = BaseButton
    self:DisableChangeReplication("GamepadIcon")
    self.GamepadIcon = GamepadIcon

    --Connect replicating values.
    local ButtonPropertyOverrides = {}
    self:DisableChangeReplication("ButtonPropertyOverrides")
    self.ButtonPropertyOverrides = ButtonPropertyOverrides
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any)
        if not ButtonPropertyOverrides[PropertyName] then
            return
        end
        ButtonPropertyOverrides[PropertyName](Value)
    end)

    --Set the replication overrides.
    self:DisableChangeReplication("TweenDuration")
    self:OverrideButtonProperty("BackgroundColor3", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BackgroundTransparency", function(NewBackgroundTransparency: number)
        BackgroundFrame.ImageTransparency = NewBackgroundTransparency
    end)
    self:OverrideButtonProperty("BorderSize", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BorderSizePixel", function(NewBorderSizePixel: number)
        self.BorderSize = UDim.new(0, NewBorderSizePixel)
    end)
    self:OverrideButtonProperty("BorderSizeScale", function(NewBorderSizeScale: number)
        self.BorderSize = UDim.new(NewBorderSizeScale, 0)
    end)
    self:OverrideButtonProperty("BorderColor3", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("AutoButtonColor", function()
        self:UpdateBorder(false)
    end)
    self:OverrideButtonProperty("BorderTransparency", function(NewBorderTransparency: number)
        BorderFrame.ImageTransparency = NewBorderTransparency
    end)
    self:OverrideButtonProperty("Hovering", function()
        self:UpdateBorder(true)
    end)
    self:OverrideButtonProperty("Pressed", function()
        self:UpdateBorder(true)
    end)
    self:OverrideButtonProperty("Theme", function(NewTheme: string)
        local Theme = NexusButton.Themes[NewTheme]
        if not Theme then
            error("Unknown theme: "..tostring(NewTheme))
        end
        BackgroundFrame.Image = Theme.MainButton.Image
        BackgroundFrame.SliceCenter = Theme.MainButton.SliceCenter
        BorderFrame.Image = Theme.MainButton.Image
        BorderFrame.SliceCenter = Theme.MainButton.SliceCenter
        GamepadIcon.AdornFrame.Image = Theme.GamepadIconBackground.Image
        GamepadIcon.AdornFrame.SliceCenter = Theme.GamepadIconBackground.SliceCenter
        self:UpdateSliceScale()
    end)

    --Connect the events.
    self:DisableChangeReplication("MappedInputs")
    self.MappedInputs = {}
    self:DisableChangeReplication("Events")
    self.Events = {}
    self.MouseEnter:Connect(function()
        self.Hovering = true
    end)
    self.MouseLeave:Connect(function()
        self.Hovering = false
    end)
    self.MouseButton1Down:Connect(function()
        self.Pressed = true
    end)
    self.MouseButton1Up:Connect(function()
        self.Pressed = false
    end)
    table.insert(self.Events, GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(function()
        self:UpdateBorder(true)
    end))
    table.insert(self.Events, UserInputService.InputBegan:Connect(function(Input, Processed)
        if Processed and (GuiService.SelectedObject ~= self:GetWrappedInstance() or Input.KeyCode == Enum.KeyCode.ButtonA) then return end
        if self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Down:Fire()
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Down:Fire()
        end
    end))
    table.insert(self.Events, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Up:Fire()
            self.MouseButton1Click:Fire()
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Up:Fire()
            self.MouseButton2Click:Fire()
        end
    end))
    table.insert(self.Events, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        self.Pressed = false
    end))

    --Set the defaults.
    self.Size = UDim2.new(0, 200, 0, 50)
    self.BackgroundColor3 = Color3.new(0.8, 0.8, 0.8)
    self.BackgroundTransparency = 0
    self.BorderSize = UDim.new(0.15, 0)
    self.BorderColor3 = Color3.new(0, 0, 0)
    self.BorderTransparency = 0
    self.AutoButtonColor = true
    self.Hovering = false
    self.Pressed = false
    self.TweenDuration = 0.1
    self.Theme = "CutCorners"
end

--[[
Overrides the replication of a property for the button.
--]]
function NexusButton:OverrideButtonProperty(PropertyName: string, SetFunction: (any) -> ()): ()
    self:DisableChangeReplication(PropertyName)
    self.ButtonPropertyOverrides[PropertyName] = SetFunction
end

--[[
Updates the slice scales of the background and border.
--]]
function NexusButton:UpdateSliceScale(): ()
    local Theme = NexusButton.Themes[self.Theme]
    local ButtonSize = math.min(self.AbsoluteSize.X, self.AbsoluteSize.Y)
    local SliceScale = ButtonSize * Theme.MainButton.SliceScaleMultiplier
    self.BackgroundFrame.SliceScale = SliceScale
    self.BorderFrame.SliceScale = SliceScale
    self.GamepadIcon.AdornFrame.SliceScale = SliceScale
end

--[[
Updates the background and border properties.
--]]
function NexusButton:UpdateBorder(Tween: boolean?): ()
    --Get the border size.
    if not self.BorderSize then return end
    if not self.Theme then return end
    local ButtonSizeY = self.BackgroundFrame.AbsoluteSize.Y
    local BorderSize = (ButtonSizeY * self.BorderSize.Scale) + self.BorderSize.Offset
    local BackgroundColor3 = self.BackgroundColor3
    local BorderColor3 = self.BorderColor3

    --Modify the properties.
    if self.AutoButtonColor ~= false then
        if self.Pressed then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, PRESS_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, PRESS_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.25
        elseif self.Hovering or GuiService.SelectedObject == self:GetWrappedInstance() then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, HOVER_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, HOVER_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.75
        end
    end

    --Apply the properties.
    if Tween and self.TweenDuration and self.TweenDuration > 0 then
        TweenService:Create(self.BackgroundFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BackgroundColor3,
        }):Play()
        TweenService:Create(self.BorderFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BorderColor3,
            Size = UDim2.new(1, 0, 1, BorderSize),
        }):Play()
    else
        self.BackgroundFrame.ImageColor3 = BackgroundColor3
        self.BorderFrame.ImageColor3 = BorderColor3
        self.BorderFrame.Size = UDim2.new(1, 0, 1, BorderSize)
    end
end

--[[
Returns the adorn frame to parent frames to the button.
--]]
function NexusButton:GetAdornFrame(): Frame
    return self.ContentsAdorn:GetWrappedInstance()
end

--[[
Sets the controller icon for the button.
--]]
function NexusButton:SetControllerIcon(KeyCode: Enum.KeyCode | string): ()
    self.GamepadIcon:SetIcon(KeyCode)
end

--[[
Maps a key input to a mouse input for clicking.
--]]
function NexusButton:MapKey(KeyCode: Enum.KeyCode | string, MouseInput: Enum.UserInputType | string): ()
    --Correct the inputs.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end
    if typeof(MouseInput) == "string" then
        MouseInput = (Enum.UserInputType :: any)[MouseInput]
    end

    --Throw an error if the mouse input is invalid.
    if MouseInput ~= Enum.UserInputType.MouseButton1 and MouseInput ~= Enum.UserInputType.MouseButton2 then
        error("Mouse input must be either MouseButton1 or MouseButton2.")
    end

    --Store the mapped input.
    self.MappedInputs[KeyCode] = MouseInput
end

--[[
Unmaps a key input to a mouse input for clicking.
--]]
function NexusButton:UnmapKey(KeyCode: Enum.KeyCode | string): ()
    --Correct the input.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Remove the mapped input.
    self.MappedInputs[KeyCode] = nil
end

--[[
Destroys the button and disconnects the events.
--]]
function NexusButton:Destroy(): ()
    NexusWrappedInstance.Destroy(self)
    self.GamepadIcon:Destroy()

    --Disconnect the events.
    for _, Event in self.Events do
        Event:Disconnect()
    end
    self.Events = {}
end



return NexusButton :: NexusButton</string>
        </Properties>
        <Item class="ModuleScript" referent="44">
          <Properties>
            <string name="Name">ControllerIcon</string>
            <string name="Source">--[[
TheNexusAvenger

Class representing a controller icon.
--]]
--!nocheck

local BASE_ICON_SIZE_RELATIVE = 0.9
local CUSTOM_MULTIPLIERS = {
    [Enum.KeyCode.ButtonL1] = {1, 0.5},
    [Enum.KeyCode.ButtonR1] = {1, 0.5},
}



local UserInputService = game:GetService("UserInputService")

local ControllerIconCreator = require(script:WaitForChild("ControllerIconCreator"))
local NexusInstance = require(script.Parent:WaitForChild("NexusWrappedInstance"):WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))

local ControllerIcon = NexusInstance:Extend()
ControllerIcon:SetClassName("ControllerIcon")

export type ControllerIcon = {
    new: () -> ControllerIcon,
    Extend: (self: ControllerIcon) -> ControllerIcon,

    SetIcon: (self: ControllerIcon, KeyCode: Enum.KeyCode | string) -> (),
    SetScale: (self: ControllerIcon, NewScale: number) -> (),
} &amp; NexusInstance.NexusInstance



--[[
Constructor of the Controller Icon class.
--]]
function ControllerIcon:__new()
    NexusInstance.__new(self)

    --Create the adorn frame.
    local AdornFrame = Instance.new("ImageLabel")
    AdornFrame.BackgroundTransparency = 1
    self.AdornFrame = AdornFrame
    self.IconScale = BASE_ICON_SIZE_RELATIVE

    --Connect the events.
    self.Events = {}
    table.insert(self.Events, UserInputService.GamepadConnected:Connect(function()
        self:UpdateVisibility()
    end))
    table.insert(self.Events, UserInputService.GamepadDisconnected:Connect(function()
        self:UpdateVisibility()
    end))

    --Update the visibility.
    self:UpdateVisibility()
end

--[[
Updates the visibility of the icon.
--]]
function ControllerIcon:UpdateVisibility(): ()
    --Set the visibility to false if there is no icon.
    if not self.Icon then
        self.AdornFrame.Visible = false
        self.IconVisible = false
        return
    end

    --Determine if a controller is connected.
    local ControllerConnected = (#UserInputService:GetConnectedGamepads() ~= 0)

    --Set the visibility.
    self.AdornFrame.Visible = ControllerConnected
    self.IconVisible = ControllerConnected
end

--[[
Sets the icon.
--]]
function ControllerIcon:SetIcon(KeyCode: Enum.KeyCode | string): ()
    --Return if the KeyCode is nil.
    if KeyCode == nil then
        self.KeyCode = nil
        self.Icon:Destroy()
        self.Icon = nil
        self:UpdateVisibility()
        return
    end

    --Covert the KeyCode from a string.
    if type(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Destroy the existing icon.
    if self.Icon then
        self.Icon:Destroy()
    end

    --Create the new icon.
    local Icon = ControllerIconCreator:GetImageLabel(KeyCode, "Dark", "XboxOne")
    Icon.Position = UDim2.new(0.5, 0, 0.5, 0)
    Icon.AnchorPoint = Vector2.new(0.5, 0.5)
    Icon.ZIndex = self.AdornFrame.ZIndex
    Icon.Parent = self.AdornFrame
    self.Icon = Icon
    self.KeyCode = KeyCode
    self:UpdateVisibility()
    self:SetScale(self.IconScale)
end

--[[
Sets the scale of the icon.
--]]
function ControllerIcon:SetScale(NewScale: number): ()
    self.IconScale = NewScale

    --Set the size.
    if self.KeyCode and self.Icon then
        local ScaleMultipliers = CUSTOM_MULTIPLIERS[self.KeyCode] or {1, 1}
        self.Icon.Size = UDim2.new(self.IconScale * ScaleMultipliers[1], 0, self.IconScale * ScaleMultipliers[2], 0)
    end
end

--[[
Destroys the frame.
--]]
function ControllerIcon:Destroy(): ()
    NexusInstance.Destroy(self)

    --Disconnect the events.
    for _,Event in self.Events do
        Event:Disconnect()
    end
    self.Events = {}

    --Destroy the adorn frame.
    self.AdornFrame:Destroy()
end



return ControllerIcon :: ControllerIcon</string>
          </Properties>
          <Item class="ModuleScript" referent="45">
            <Properties>
              <string name="Name">ControllerIconCreator</string>
              <string name="Source"><![CDATA[local ControllerImageLibrary = {}

local spritesheets = {}
for _, platform in pairs(script.Spritesheets:GetChildren()) do
    spritesheets[platform.Name] = {}
    for _, style in pairs(platform:GetChildren()) do
        spritesheets[platform.Name][style.Name] = require(style).new()
    end
end

local function getImageInstance(instanceType, index, style, platform)
    local platform = "XboxOne"
    if type(index)== "userdata" then
        index = string.sub(tostring(index), 14)
    end
    local sheet = spritesheets[platform][style]
    if not sheet then
        warn("Could not find style: " .. style)
        return
    end
    local element = sheet:GetSprite(instanceType, index)
    return element
end

function ControllerImageLibrary:GetImageLabel(index, style, platform)
    return getImageInstance("ImageLabel", index, style, platform)
end

function ControllerImageLibrary:GetImageButton(index, style, platform)
    return getImageInstance("ImageButton", index, style, platform)
end

return ControllerImageLibrary
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="46">
              <Properties>
                <string name="Name">Spritesheet</string>
                <string name="Source"><![CDATA[local Spritesheet = {}
Spritesheet.__index = Spritesheet

function Spritesheet.new(texture)
    local newSpritesheet = {}
    setmetatable(newSpritesheet, Spritesheet)
    
    newSpritesheet.Texture = texture
    newSpritesheet.Sprites = {}    
    
    return newSpritesheet
end

function Spritesheet:AddSprite(index, position, size)
    local Sprite = {Position=position,Size=size}
    self.Sprites[index] = Sprite
end

function Spritesheet:GetSprite(instanceType, index)
    if not index then
        warn("Image name cannot be nil")
        return false
    end
    local sprite = self.Sprites[index]
    if not sprite then 
        warn("Could not find sprite for: " .. index) 
        return false
    end
    local element = Instance.new(instanceType)
    element.BackgroundTransparency = 1
    element.BorderSizePixel = 1
    element.Image = self.Texture
    element.Size = UDim2.new(0, sprite.Size.X, 0, sprite.Size.Y)
    element.ImageRectOffset = sprite.Position
    element.ImageRectSize = sprite.Size
    
    return element
end

return Spritesheet
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="47">
              <Properties>
                <string name="Name">Spritesheets</string>
              </Properties>
              <Item class="Folder" referent="48">
                <Properties>
                  <string name="Name">XboxOne</string>
                </Properties>
                <Item class="ModuleScript" referent="49">
                  <Properties>
                    <string name="Name">Dark</string>
                    <string name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Dark = {}
Dark.__index = Dark
setmetatable(Dark, Spritesheet)

local darkTexture = "rbxassetid://408444495"

function Dark.new()
    local newDark = Spritesheet.new(darkTexture)
    setmetatable(newDark, Dark)
    
    newDark:AddSprite("ButtonX", Vector2.new(510, 416), Vector2.new(95, 95))    
    newDark:AddSprite("ButtonY", Vector2.new(616, 318), Vector2.new(95, 95))
    newDark:AddSprite("ButtonA", Vector2.new(318, 416), Vector2.new(95, 95))
    newDark:AddSprite("ButtonB", Vector2.new(520, 522), Vector2.new(95, 95))
    newDark:AddSprite("ButtonR1", Vector2.new(0, 628), Vector2.new(115, 64))
    newDark:AddSprite("ButtonL1", Vector2.new(116, 628), Vector2.new(115, 64))
    newDark:AddSprite("ButtonR2", Vector2.new(616, 414), Vector2.new(105, 115))
    newDark:AddSprite("ButtonL2", Vector2.new(616, 0), Vector2.new(105, 115))
    newDark:AddSprite("ButtonR3", Vector2.new(0, 416), Vector2.new(105, 105))
    newDark:AddSprite("ButtonL3", Vector2.new(0, 522), Vector2.new(105, 105))
    newDark:AddSprite("ButtonSelect", Vector2.new(424, 522), Vector2.new(95, 95))
    newDark:AddSprite("DPadLeft", Vector2.new(318, 522), Vector2.new(105, 105))
    newDark:AddSprite("DPadRight", Vector2.new(212, 416), Vector2.new(105, 105))
    newDark:AddSprite("DPadUp", Vector2.new(616, 530), Vector2.new(105, 105))
    newDark:AddSprite("DPadDown", Vector2.new(212, 522), Vector2.new(105, 105))
    newDark:AddSprite("Thumbstick1", Vector2.new(616, 116), Vector2.new(105, 105))    
    newDark:AddSprite("Thumbstick2", Vector2.new(106, 522), Vector2.new(105, 105))
    newDark:AddSprite("DPad", Vector2.new(106, 416), Vector2.new(105, 105))
    newDark:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
    newDark:AddSprite("RotateThumbstick1", Vector2.new(414, 416), Vector2.new(95, 95))
    newDark:AddSprite("RotateThumbstick2", Vector2.new(616, 222), Vector2.new(95, 95))
    
    return newDark
end

return Dark
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="50">
                  <Properties>
                    <string name="Name">Light</string>
                    <string name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Light = {}
Light.__index = Light
setmetatable(Light, Spritesheet)

local lightTexture = "rbxassetid://408462759"

function Light.new()
    local newLight = Spritesheet.new(lightTexture)
    setmetatable(newLight, Light)
    
    newLight:AddSprite("ButtonX", Vector2.new(318, 481), Vector2.new(95, 95))    
    newLight:AddSprite("ButtonY", Vector2.new(500, 587), Vector2.new(95, 95))
    newLight:AddSprite("ButtonA", Vector2.new(308, 587), Vector2.new(95, 95))
    newLight:AddSprite("ButtonB", Vector2.new(510, 481), Vector2.new(95, 95))
    newLight:AddSprite("ButtonR1", Vector2.new(0, 416), Vector2.new(115, 64))
    newLight:AddSprite("ButtonL1", Vector2.new(116, 416), Vector2.new(115, 64))
    newLight:AddSprite("ButtonR2", Vector2.new(616, 0), Vector2.new(105, 115))
    newLight:AddSprite("ButtonL2", Vector2.new(616, 328), Vector2.new(105, 115))
    newLight:AddSprite("ButtonR3", Vector2.new(616, 550), Vector2.new(105, 105))
    newLight:AddSprite("ButtonL3", Vector2.new(616, 116), Vector2.new(105, 105))
    newLight:AddSprite("ButtonSelect", Vector2.new(404, 587), Vector2.new(95, 95))
    newLight:AddSprite("DPadLeft", Vector2.new(616, 444), Vector2.new(105, 105))
    newLight:AddSprite("DPadRight", Vector2.new(0, 587), Vector2.new(105, 105))
    newLight:AddSprite("DPadUp", Vector2.new(616, 222), Vector2.new(105, 105))
    newLight:AddSprite("DPadDown", Vector2.new(212, 481), Vector2.new(105, 105))
    newLight:AddSprite("Thumbstick1", Vector2.new(0, 481), Vector2.new(105, 105))    
    newLight:AddSprite("Thumbstick2", Vector2.new(106, 587), Vector2.new(105, 105))
    newLight:AddSprite("DPad", Vector2.new(106, 481), Vector2.new(105, 105))
    newLight:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
    newLight:AddSprite("RotateThumbstick1", Vector2.new(414, 481), Vector2.new(95, 95))
    newLight:AddSprite("RotateThumbstick2", Vector2.new(212, 587), Vector2.new(95, 95))
    
    return newLight
end

return Light
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="51">
          <Properties>
            <string name="Name">Factory</string>
          </Properties>
          <Item class="ModuleScript" referent="52">
            <Properties>
              <string name="Name">ButtonFactory</string>
              <string name="Source">--[[
TheNexusAvenger

"Factory" for creating buttons. Used to be able
to set defaults once.
--]]
--!strict

local BORDER_COLOR_OFFSET = Color3.new(-30 / 255, -30 / 255, -30 / 255)



local RootModule = script.Parent.Parent

local NexusObject = require(RootModule:WaitForChild("NexusWrappedInstance"):WaitForChild("NexusInstance"):WaitForChild("NexusObject"))
local NexusButton = require(RootModule)

local ButtonFactory = NexusObject:Extend()
ButtonFactory:SetClassName("ButtonFactory")

export type ButtonFactory = {
    new: () -> ButtonFactory,
    Extend: (self: ButtonFactory) -> ButtonFactory,
    CreateDefault: (Color: Color3) -> ButtonFactory,

    Create: (self: ButtonFactory) -> NexusButton.NexusButton,
    SetDefault: (self: ButtonFactory, PropertyName: string, Property: any) -> (),
    UnsetDefault: (self: ButtonFactory, PropertyName: string) -> (),
} &amp; NexusObject.NexusObject



--[[
Adds two Color3s.
--]]
local function AddColor3(Color1: Color3, Color2: Color3): Color3
    return Color3.new(math.clamp(Color1.R + Color2.R, 0, 1), math.clamp(Color1.G + Color2.G, 0, 1), math.clamp(Color1.B + Color2.B, 0, 1))
end



--[[
Creates a button factory with the default style.
This is used by Nexus Development projects.
--]]
function ButtonFactory.CreateDefault(Color: Color3)
    --Create the factory.
    local Factory = ButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)

    --Return the factory.
    return Factory
end

--[[
Creates a button factory.
--]]
function ButtonFactory:__new()
    NexusObject.__new(self)
    self.Defaults = {}
end

--[[
Creates a button instance.
--]]
function ButtonFactory:Create(): NexusButton.NexusButton
    --Create the button.
    local Button = NexusButton.new()

    --Set the defaults.
    for PropertyName,PropertyValue in self.Defaults do
        (Button :: any)[PropertyName] = PropertyValue
    end

    --Return the button.
    return Button
end

--[[
Sets a default property.
--]]
function ButtonFactory:SetDefault(PropertyName: string, Property: any): ()
    self.Defaults[PropertyName] = Property
end

--[[
Unsets a default property.
--]]
function ButtonFactory:UnsetDefault(PropertyName: string): ()
    self.Defaults[PropertyName] = nil
end



return ButtonFactory :: ButtonFactory</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="53">
            <Properties>
              <string name="Name">TextButtonFactory</string>
              <string name="Source">--[[
TheNexusAvenger

"Factory" for creating text buttons. Used to be
able to set defaults once.
--]]
--!strict

local BORDER_COLOR_OFFSET = Color3.new(-30 / 255, -30 / 255, -30 / 255)



local RootModule = script.Parent.Parent

local NexusButton = require(RootModule)
local ButtonFactory = require(RootModule:WaitForChild("Factory"):WaitForChild("ButtonFactory"))

local TextButtonFactory = ButtonFactory:Extend()
TextButtonFactory:SetClassName("TextButtonFactory")

export type TextButtonFactory = {
    new: () -> TextButtonFactory,
    Extend: (self: TextButtonFactory) -> TextButtonFactory,
    CreateDefault: (Color: Color3) -> TextButtonFactory,

    Create: (self: TextButtonFactory) -> (NexusButton.NexusButton, TextLabel),
    SetTextDefault: (self: TextButtonFactory, PropertyName: string, Property: any) -> (),
    UnsetTextDefault: (self: TextButtonFactory, PropertyName: string) -> (),
} &amp; ButtonFactory.ButtonFactory



--[[
Adds two Color3s.
--]]
local function AddColor3(Color1: Color3, Color2: Color3): Color3
    return Color3.new(math.clamp(Color1.R + Color2.R, 0, 1), math.clamp(Color1.G + Color2.G, 0, 1), math.clamp(Color1.B + Color2.B, 0, 1))
end



--[[
Creates a text button factory with the default
style. This is used by Nexus Development projects.
--]]
function TextButtonFactory.CreateDefault(Color: Color3)
    --Create the factory.
    local Factory = TextButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)
    Factory:SetTextDefault("Font", Enum.Font.SourceSans)
    Factory:SetTextDefault("TextColor3", Color3.new(1,1,1))
    Factory:SetTextDefault("TextStrokeColor3", Color3.new(0,0,0))
    Factory:SetTextDefault("TextStrokeTransparency", 0)
    Factory:SetTextDefault("TextScaled", true)

    --Return the factory.
    return Factory
end

--[[
Creates a text button factory.
--]]
function TextButtonFactory:__new()
    ButtonFactory.__new(self)
    self.TextDefaults = {}
end

--[[
Creates a text button instance.
--]]
function TextButtonFactory:Create()
    --Create the button.
    local Button = ButtonFactory.Create(self)

    --Add a text label.
    local TextLabel = Instance.new("TextLabel")
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    TextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    TextLabel.BackgroundTransparency = 1
    TextLabel.ZIndex = 5
    TextLabel.Parent = Button:GetAdornFrame()

    --Set the text defaults.
    for PropertyName,PropertyValue in self.TextDefaults do
        (TextLabel :: any)[PropertyName] = PropertyValue
    end

    --Return the button and textlabel.
    return Button, TextLabel
end

--[[
Sets a default text property.
--]]
function ButtonFactory:SetTextDefault(PropertyName: string, Property: any): ()
    self.TextDefaults[PropertyName] = Property
end

--[[
Unsets a default text property.
--]]
function ButtonFactory:UnsetTextDefault(PropertyName: string): ()
    self.TextDefaults[PropertyName] = nil
end



return TextButtonFactory :: TextButtonFactory</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="54">
          <Properties>
            <string name="Name">ThemedFrame</string>
            <string name="Source">--[[
TheNexusAvenger

Frame that has the same theming for the buttons.
--]]

local NexusButton = require(script.Parent)
local NexusWrappedInstance = require(script.Parent:WaitForChild("NexusWrappedInstance"))

local ThemedFrame = NexusWrappedInstance:Extend()
ThemedFrame:SetClassName("ThemedFrame")

export type ThemedFrame = {
    new: () -> ThemedFrame,
    Extend: (self: ThemedFrame) -> ThemedFrame,

    Theme: NexusButton.NexusButtonTheme,
} &amp; "ImageLabel"



--[[
Creates the themed frame.
--]]
function ThemedFrame:__new()
    NexusWrappedInstance.__new(self, "ImageLabel")
    self.BackgroundTransparency = 1

    --Connect replicating values.
    local ButtonPropertyOverrides = {}
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any)
        if not ButtonPropertyOverrides[PropertyName] then
            return
        end
        ButtonPropertyOverrides[PropertyName](Value)
    end)

    --Set the replication overrides.
    self:DisableChangeReplication("BackgroundColor3")
    ButtonPropertyOverrides["BackgroundColor3"] = function(NewBackgroundColor3: Color3)
        self.ImageColor3 = NewBackgroundColor3
    end
    self:DisableChangeReplication("BackgroundTransparency")
    ButtonPropertyOverrides["BackgroundTransparency"] = function(NewBackgroundTransparency: Color3)
        self.ImageTransparency = NewBackgroundTransparency
    end
    self:DisableChangeReplication("SliceScaleMultiplier")
    ButtonPropertyOverrides["SliceScaleMultiplier"] = function()
        self:UpdateSliceScale()
    end
    self:DisableChangeReplication("Theme")
    ButtonPropertyOverrides["Theme"] = function(NewTheme: string)
        local Theme = NexusButton.Themes[self.Theme]
        if not Theme then
            error("Unknown theme: "..tostring(NewTheme))
        end
        self.Image = Theme.MainButton.Image
        self.SliceCenter = Theme.MainButton.SliceCenter
        self:UpdateSliceScale()
    end
    self:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateSliceScale()
    end)

    --Set the defaults.
    self.BackgroundColor3 = Color3.new(1, 1, 1)
    self.ScaleType = Enum.ScaleType.Slice
    self.SliceScaleMultiplier = 0.5
    self.Size = UDim2.new(0, 100, 0, 100)
    self.Theme = "CutCorners"
end

--[[
Updates the slice scale of the frame.
--]]
function ThemedFrame:UpdateSliceScale(): ()
    if not self.Theme then return end
    local Theme = NexusButton.Themes[self.Theme]
    self.SliceScale = math.min(self.AbsoluteSize.X, self.AbsoluteSize.Y) * Theme.MainButton.SliceScaleMultiplier * (self.SliceScaleMultiplier or 1)
end




return ThemedFrame :: ThemedFrame</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="55">
          <Properties>
            <string name="Name">NexusWrappedInstance</string>
            <string name="Source">--[[
TheNexusAvenger

Wraps a Roblox Instance to add additional
functionality.
--]]
--!strict

--Certain versions of Nexus Wrapped Instance have incompatibilities
--with other versions. Increment this number if a breaking change
--is made, such as Nexus Instance V.2.X.X to V.3.X.X.
local SINGLETON_COMPATIBILITY_VERSION = 2

local RunService = game:GetService("RunService")

local NexusInstance = require(script:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))
local NexusEvent = require(script:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusWrappedInstance = NexusInstance:Extend()
NexusWrappedInstance:SetClassName("NexusWrappedInstance")
NexusWrappedInstance.CachedInstances = {}
setmetatable(NexusWrappedInstance.CachedInstances, {__mode = "v"})

export type NexusWrappedInstance = {
    new: (InstanceType: string | Instance) -> NexusWrappedInstance,
    Extend: (self: NexusWrappedInstance) -> NexusWrappedInstance,
    CreateGetInstance: (Class: NexusWrappedInstance) -> (),

    GetWrappedInstance: (self: NexusWrappedInstance) -> Instance,
    IgnoreWrapping: (self: NexusWrappedInstance, PropertyName: string) -> (),
    DisableChangeReplication: (self: NexusWrappedInstance, PropertyName: string) -> (),
    EnableChangeReplication: (self: NexusWrappedInstance, PropertyName: string) -> (),
    ConvertProperty: (self: NexusWrappedInstance, PropertyName: string, PropertyValue: any) -> any,
} &amp; NexusInstance.NexusInstance &amp; Instance



--[[
Wraps the instance or table.
--]]
local function WrapData(InstanceOrTable: any): any
    --Return the wrapped object.
    if typeof(InstanceOrTable) == "Instance" then
        return NexusWrappedInstance.GetInstance(InstanceOrTable)
    end

    --Change the table entries.
    if typeof(InstanceOrTable) == "table" and not InstanceOrTable.IsA then
        for Key,Value in InstanceOrTable do
            if typeof(Value) == "Instance" or typeof(Value) == "table" then
                InstanceOrTable[Key] = WrapData(Value)
            end
        end
    end

    --Return the base value.
    return InstanceOrTable
end

--[[
Unwraps the instance or table.
--]]
local function UnwrapData(InstanceOrTable: any): any
    --Unwrap the table.
    if typeof(InstanceOrTable) == "table" then
        if InstanceOrTable.WrappedInstance then
            --Unwrap the instance.
            return InstanceOrTable.WrappedInstance
        else
            --Change the table entries.
            for Key,Value in InstanceOrTable do
                if typeof(Value) == "table" then
                    InstanceOrTable[Key] = UnwrapData(Value)
                end
            end
        end
    end

    --Return the base value.
    return InstanceOrTable
end



--[[
Creates a GetInstance method for the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusWrappedInstance:CreateGetInstance(Class: NexusWrappedInstance)
    Class = Class or self
    Class.GetInstance = function(ExistingInstance: string | Instance): NexusWrappedInstance
        --Create the string instance or create the cached instance if needed.
        local CachedInstance = NexusWrappedInstance.CachedInstances[ExistingInstance]
        if typeof(ExistingInstance) == "string" then
            CachedInstance = Class.new(ExistingInstance)
        else
            if not CachedInstance then
                CachedInstance = Class.new(ExistingInstance)
            end
        end
        
        --Return the cached entry.
        return CachedInstance
    end
end
NexusWrappedInstance:CreateGetInstance(NexusWrappedInstance)

--[[
Creates a Nexus Wrapped Instance object.
--]]
function NexusWrappedInstance:__new(InstanceOrStringToWrap: string | Instance)
    if self.WrappedInstance then return end
    NexusInstance.__new(self)

    --Convert the instance to wrap if it is a string.
    local InstanceToWrap: Instance = nil
    if typeof(InstanceOrStringToWrap) == "string" then
        InstanceToWrap = Instance.new(InstanceOrStringToWrap :: any)
    else
        InstanceToWrap = InstanceOrStringToWrap :: Instance
    end
    
    --Store the value in the cache.
    local UnwrappedProperties = {
        WrappedInstance = true,
    }
    self.CachedInstances[InstanceToWrap] = self
    self.DisabledChangesReplication = {}
    self.EventsToDisconnect = {}
    self.UnwrappedProperties = UnwrappedProperties
    self.WrappedInstance = InstanceToWrap
    self:DisableChangeReplication("EventsToDisconnect")

    --Modify indexing to get instance properties.
    local OriginalIndexFunction = getmetatable(self).__index
    getmetatable(self).__index = function(MethodObject: any, Index: string): any
        --Return the object value if it exists.
        local BaseReturn = OriginalIndexFunction(MethodObject, Index)
        if UnwrappedProperties[Index] then
            return BaseReturn
        end
        if BaseReturn ~= nil or Index == "DisabledChangesReplication" or Index == "EventsToDisconnect" then
            return WrapData(BaseReturn)
        end

        --Return nil if the replication is disabled.
        local DisabledChangesReplication = self.DisabledChangesReplication
        if DisabledChangesReplication and DisabledChangesReplication[Index] then
            return nil
        end

        --Return the wrapped object's value.
        local WrappedInstance = self.WrappedInstance
        if WrappedInstance then
            local Value = WrappedInstance[Index]

            --Wrap the event.
            if typeof(Value) == "RBXScriptSignal" then
                --Create and store the event.
                local Event = NexusEvent.new()
                self:DisableChangeReplication(Index)
                self[Index] = Event
                table.insert(self.EventsToDisconnect, Event)

                --Connect the event.
                Value:Connect(function(...)
                    local TotalArguments = select("#", ...)
                    Event:Fire(table.unpack(WrapData({...}), 1, TotalArguments))
                end)

                --Return the event.
                return Event
            end

            --Wrap the function.
            if typeof(Value) == "function" then
                --Wrap the function.
                local function WrappedFunction(...)
                    --Unwrap the parameters for the call.
                    local TotalArguments = select("#", ...)
                    local UnwrappedArguments = UnwrapData(table.pack(...))

                    --Call and return the wrapped parameters.
                    return WrapData(Value(table.unpack(UnwrappedArguments, 1, TotalArguments)))
                end

                --Store and return the function.
                self:DisableChangeReplication(Index)
                self[Index] = WrappedFunction
                return WrappedFunction
            end

            --Return the wrapped data.
            return WrapData(Value)
        end

        --Return nil (default case for typing).
        return nil
    end

    --Set up the cyclic property changing blocking.
    --Done internally to reduce overhead.
    local PreviousChanges = {}
    local PreviousChangesClearQueued = false

    --[[
    Queues clearing the previous changes.
    --]]
    local function QueueClearingChanges(): ()
        --Return if clearing is already queued.
        if PreviousChangesClearQueued then
            return
        end

        --Clear the previous changes after the next step.
        --Done to prevent storing extra data in memory that would prevent garbage collection.
        PreviousChangesClearQueued = true
        task.spawn(function()
            RunService.Heartbeat:Wait()
            PreviousChanges = {}
            PreviousChangesClearQueued = false
        end)
    end

    --Connect replicating properties.
    self:AddGenericPropertyFinalizer(function(PropertyName: string, Value: any): ()
        --Return if the replication is disabled.
        if self.DisabledChangesReplication[PropertyName] then
            return
        end

        --Return if the value is the same as the previous change in the last step.
        if PreviousChanges[PropertyName] == Value then
            return
        end

        --Add the property to the list of changed values and queue clearing the list.
        --This prevents converted values from affecting the previous set, leading to a stack overflow from the events.
        local ConvertedValue = self:ConvertProperty(PropertyName,Value)
        PreviousChanges[PropertyName] = ConvertedValue
        QueueClearingChanges();

        --Replicate the change.
        (InstanceToWrap :: any)[PropertyName] = ConvertedValue
    end)
    InstanceToWrap.Changed:Connect(function(PropertyName: string): ()
        pcall(function()
            --Return if the replication is disabled.
            if self.DisabledChangesReplication[PropertyName] then
                return
            end

            --Read the new value.
            local NewValue = (InstanceToWrap :: any)[PropertyName]

            --Return if the value is the same as the previous change in the last step.
            if PreviousChanges[PropertyName] == NewValue then
                return
            end

            --Add the property to the list of changed values and queue clearing the list.
            --This prevents converted values from affecting the previous set, leading to a stack overflow from the events.
            PreviousChanges[PropertyName] = NewValue
            QueueClearingChanges()

            --Change the property.
            local ExistingValue = self[PropertyName]
            if ExistingValue ~= nil and ExistingValue ~= NewValue then
                self[PropertyName] = NewValue
            else
                self.Changed:Fire(PropertyName)
                self:GetPropertyChangedSignal(PropertyName):Fire()
            end
        end)
    end)

    --Connect the instance being destroyed.
    --Mainly used if ClearAllChildren is called and Destroy isn't explicitly called.
    --Workaround by Corecii.
    local AncestryChangedConnection
    AncestryChangedConnection = InstanceToWrap.AncestryChanged:Connect(function()
        RunService.Heartbeat:Wait()
        if not AncestryChangedConnection.Connected then
            self:Destroy()
        end
    end)
    table.insert(self.EventsToDisconnect, AncestryChangedConnection)
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusWrappedInstance:IsA(ClassName: string): boolean
    return self:GetWrappedInstance():IsA(ClassName) or NexusInstance.IsA(self, ClassName)
end

--[[
Sets the Parent property to nil, locks the Parent
property, and calls Destroy on all children.
--]]
function NexusWrappedInstance:Destroy(): ()
    NexusInstance.Destroy(self)

    --Destroy the wrapped instance.
    local WrappedInstance = self:GetWrappedInstance()
    if WrappedInstance then
        WrappedInstance:Destroy()
    end

    --Disconnect the events.
    for _,Event in self.EventsToDisconnect do
        Event:Disconnect()
    end
    self.EventsToDisconnect = {}
end

--[[
Returns the wrapped instance.
--]]
function NexusWrappedInstance:GetWrappedInstance()
    return self.WrappedInstance
end

--[[
Makes it so a property is never wrapped.
--]]
function NexusWrappedInstance:IgnoreWrapping(PropertYName: string): ()
    self.UnwrappedProperties[PropertYName] = true
end

--[[
Disables changes being replicated to the wrapped
instance for a specific property.
--]]
function NexusWrappedInstance:DisableChangeReplication(PropertyName: string): ()
    self.DisabledChangesReplication[PropertyName] = true
end

--[[
Enables changes being replicated to the wrapped
instance for a specific property.
--]]
function NexusWrappedInstance:EnableChangeReplication(PropertyName: string): ()
    self.DisabledChangesReplication[PropertyName] = nil
end

--[[
Converts a property for replicating to the
wrapped instance.
--]]
function NexusWrappedInstance:ConvertProperty(PropertyName: string, PropertyValue: any): any
    return UnwrapData(PropertyValue)
end



--In non-test environemnts, return a singleton version of the module.
--Multiple instances of Nexus Wrapped Instance can have unintended consequences with the state being distributed and inconsistent.
if _G.EnsureNexusWrappedInstanceSingleton ~= false then
    if not _G.NexusWrappedInstanceSingletonVersions then
        _G.NexusWrappedInstanceSingletonVersions = {}
    end
    if not _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION] then
        _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION] = NexusWrappedInstance
    end
    return _G.NexusWrappedInstanceSingletonVersions[SINGLETON_COMPATIBILITY_VERSION]
end
return (NexusWrappedInstance :: any) :: NexusWrappedInstance</string>
          </Properties>
          <Item class="Folder" referent="56">
            <Properties>
              <string name="Name">NexusInstance</string>
            </Properties>
            <Item class="Folder" referent="57">
              <Properties>
                <string name="Name">Event</string>
              </Properties>
              <Item class="ModuleScript" referent="58">
                <Properties>
                  <string name="Name">NexusConnection</string>
                  <string name="Source">--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent&lt;T...> = {
    Disconnected: (NexusConnectionEvent&lt;T...>) -> (),
    [string]: any,
}
export type NexusConnection&lt;T...> = {
    new: (Event: NexusConnectionEvent&lt;T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection&lt;T...>),
    Extend: (self: NexusConnection&lt;T...>) -> (NexusConnection&lt;T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent&lt;T...>, T...) -> (),
    Disconnect: () -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new&lt;T...>(Event: NexusConnectionEvent&lt;T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire&lt;T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection&lt;></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="59">
                <Properties>
                  <string name="Name">NexusEvent</string>
                  <string name="Source">--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent&lt;T...> = {
    new: () -> (NexusEvent&lt;T...>),
    Extend: (self: NexusEvent&lt;T...>) -> (NexusEvent&lt;T...>),

    Connect: (self: NexusEvent&lt;T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection&lt;T...>),
    Fire: (self: NexusEvent&lt;T...>, T...) -> (),
    Disconnect: (self: NexusEvent&lt;T...>) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected&lt;T...>(Connection: NexusConnection.NexusConnection&lt;T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect&lt;T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection&lt;T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire&lt;T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits &lt;= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait&lt;T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent&lt;></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="60">
              <Properties>
                <string name="Name">NexusInstance</string>
                <string name="Source">--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent&lt;string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent&lt;>),
    Destroy: (self: NexusInstance) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent&lt;>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="61">
              <Properties>
                <string name="Name">NexusObject</string>
                <string name="Source">--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="62">
              <Properties>
                <string name="Name">PropertyValidator</string>
              </Properties>
              <Item class="ModuleScript" referent="63">
                <Properties>
                  <string name="Name">TypePropertyValidator</string>
                  <string name="Source">--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} &amp; NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="64">
        <Properties>
          <string name="Name">NexusInstance</string>
        </Properties>
        <Item class="Folder" referent="65">
          <Properties>
            <string name="Name">Event</string>
          </Properties>
          <Item class="ModuleScript" referent="66">
            <Properties>
              <string name="Name">NexusConnection</string>
              <string name="Source">--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent&lt;T...> = {
    Disconnected: (NexusConnectionEvent&lt;T...>) -> (),
    [string]: any,
}
export type NexusConnection&lt;T...> = {
    new: (Event: NexusConnectionEvent&lt;T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection&lt;T...>),
    Extend: (self: NexusConnection&lt;T...>) -> (NexusConnection&lt;T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent&lt;T...>, T...) -> (),
    Disconnect: () -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new&lt;T...>(Event: NexusConnectionEvent&lt;T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire&lt;T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection&lt;></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="67">
            <Properties>
              <string name="Name">NexusEvent</string>
              <string name="Source">--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent&lt;T...> = {
    new: () -> (NexusEvent&lt;T...>),
    Extend: (self: NexusEvent&lt;T...>) -> (NexusEvent&lt;T...>),

    Connect: (self: NexusEvent&lt;T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection&lt;T...>),
    Fire: (self: NexusEvent&lt;T...>, T...) -> (),
    Disconnect: (self: NexusEvent&lt;T...>) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected&lt;T...>(Connection: NexusConnection.NexusConnection&lt;T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect&lt;T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection&lt;T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire&lt;T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits &lt;= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait&lt;T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent&lt;></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="68">
          <Properties>
            <string name="Name">NexusInstance</string>
            <string name="Source">--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent&lt;string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent&lt;>),
    Destroy: (self: NexusInstance) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent&lt;>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="69">
          <Properties>
            <string name="Name">NexusObject</string>
            <string name="Source">--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="70">
          <Properties>
            <string name="Name">PropertyValidator</string>
          </Properties>
          <Item class="ModuleScript" referent="71">
            <Properties>
              <string name="Name">TypePropertyValidator</string>
              <string name="Source">--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} &amp; NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator</string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="72">
        <Properties>
          <string name="Name">NexusVRCore</string>
          <string name="Source">--[[
TheNexusAvenger

Project for fetching resources of Nexus VR Core.
--]]

local NexusProject = {}



--[[
Returns a resource in Nexus VR Core.
Legacy from Nexus Project.
--]]
function NexusProject:GetResource(Path: string): any
    local Module = script
    for _, PathPart in string.split(Path, ".") do
        Module = (Module :: any)[PathPart]
    end
    return require(Module :: ModuleScript)
end



return NexusProject</string>
        </Properties>
        <Item class="Folder" referent="73">
          <Properties>
            <string name="Name">Container</string>
          </Properties>
          <Item class="ModuleScript" referent="74">
            <Properties>
              <string name="Name">BaseScreenGui</string>
              <string name="Source">--[[
TheNexusAvenger

Base ScreenGui instance.
--]]
--!strict

local NexusInstance = require(script.Parent.Parent:WaitForChild("NexusInstance"):WaitForChild("NexusInstance"))

local BaseScreenGui = NexusInstance:Extend()
BaseScreenGui:SetClassName("BaseScreenGui")

export type BaseScreenGui = {
    new: (Container: LayerCollector) -> BaseScreenGui,
    Extend: (self: BaseScreenGui) -> BaseScreenGui,

    RotationOffset: CFrame,
    Depth: number,
    FieldOfView: number,
    CanvasSize: Vector2,
    Easing: number,
    PointingEnabled: boolean,
    GetContainer: (self: BaseScreenGui) -> (LayerCollector),
    DisableChangeReplication: (self: BaseScreenGui, Name: string) -> (),
    Destroy: (self: BaseScreenGui) -> (),
} &amp; NexusInstance.NexusInstance &amp; LayerCollector



--[[
Creates the Base ScreenGui.
--]]
function BaseScreenGui:__new(Container: LayerCollector): ()
    NexusInstance.__new(self)
    self.Container = Container

    --Set the metatables.
    local NonReplicatedProperties = {} :: {[string]: boolean}
    self.NonReplicatedProperties = NonReplicatedProperties
    local Metatable = getmetatable(self)
    local BaseIndex, BaseNewIndex = Metatable.__index, Metatable.__newindex
    Metatable.__index = function(self, Index: string): any
        local BaseReturn = BaseIndex(self, Index)
        if BaseReturn ~= nil or NonReplicatedProperties[Index] then
            return BaseReturn
        end
        return (Container :: any)[Index]
    end
    Metatable.__newindex = function(self, Index: string, Value): ()
        BaseNewIndex(self, Index, Value)
        if not NonReplicatedProperties[Index] then
            (Container :: any)[Index] = Value
        end
    end

    --Set the properties.
    self:DisableChangeReplication("RotationOffset")
    self.RotationOffset = CFrame.new()
    self:DisableChangeReplication("Depth")
    self.Depth = 5
    self:DisableChangeReplication("FieldOfView")
    self.FieldOfView = math.rad(50)
    if not Container:IsA("SurfaceGui") then
        self:DisableChangeReplication("CanvasSize")
    end
    self.CanvasSize = Vector2.new(1000, 1000)
    self:DisableChangeReplication("Easing")
    self.Easing = 0
    self:DisableChangeReplication("PointingEnabled")
    self.PointingEnabled = true
end

--[[
Disables a change to replicate to the container.
--]]
function BaseScreenGui:DisableChangeReplication(Name: string)
    self.NonReplicatedProperties[Name] = true
end

--[[
Returns the container of the ScreenGui.
--]]
function BaseScreenGui:GetContainer(): LayerCollector
    return self.Container
end

--[[
Destroys the ScreenGui.
--]]
function BaseScreenGui:Destroy(): ()
    NexusInstance.Destroy(self)
    self.Container:Destroy()
end



return (BaseScreenGui :: any) :: BaseScreenGui</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="75">
            <Properties>
              <string name="Name">ScreenGui</string>
              <string name="Source">--[[
TheNexusAvenger

Contains user interface components.
--]]
--!strict

local UserInputService = game:GetService("UserInputService")

local ScreenGui3D = require(script.Parent:WaitForChild("ScreenGui3D"))
local ScreenGui2D = require(script.Parent:WaitForChild("ScreenGui2D"))



--Return the class depending on if VR is enabled or not.
if UserInputService.VREnabled then
    return ScreenGui3D
else
    return ScreenGui2D
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="76">
            <Properties>
              <string name="Name">ScreenGui2D</string>
              <string name="Source">--[[
TheNexusAvenger

Implementation of a ScreenGui for 2D players.
--]]
--!strict

local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui2D = BaseScreenGui:Extend()
ScreenGui2D:SetClassName("ScreenGui2D")

export type ScreenGui2D = {
    new: () -> ScreenGui2D,
    Extend: (self: ScreenGui2D) -> ScreenGui2D,
} &amp; BaseScreenGui.BaseScreenGui



--[[
Creates a 2D ScreenGui.
--]]
function ScreenGui2D:__new(): ()
    BaseScreenGui.__new(self, Instance.new("ScreenGui"))
end



return ScreenGui2D</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="77">
            <Properties>
              <string name="Name">ScreenGui3D</string>
              <string name="Source">--[[
TheNexusAvenger

Contains user interface components for a 3D user interface.
--]]
--!nocheck

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui3D = BaseScreenGui:Extend()
ScreenGui3D:SetClassName("ScreenGui3D")

export type ScreenGui3D = {
    new: () -> ScreenGui3D,
    Extend: (self: ScreenGui3D) -> ScreenGui3D,
} &amp; BaseScreenGui.BaseScreenGui



--[[
Creates a 3D ScreenGui.
--]]
function ScreenGui3D:__new()
    BaseScreenGui.__new(self, Instance.new("SurfaceGui"))

    --Create the Adornee.
    local NexusVRCoreContainer = Workspace.CurrentCamera:FindFirstChild("NexusVRCoreContainer")
    if not NexusVRCoreContainer then
        NexusVRCoreContainer = Instance.new("Folder")
        NexusVRCoreContainer.Name = "NexusVRCoreContainer"
        NexusVRCoreContainer.Parent = Workspace.CurrentCamera
    end
    local Adornee = Instance.new("Part")
    Adornee.Transparency = 1
    Adornee.Anchored = true
    Adornee.CanCollide = false
    Adornee.Parent = NexusVRCoreContainer
    self.Adornee = Adornee
    self.Face = Enum.NormalId.Back

    --Set the properties.
    self.AlwaysOnTop = true
    self:AddPropertyFinalizer("PointingEnabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)
    self:AddPropertyFinalizer("Enabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)

    --Disable replication of ScreenGui properties.
    self:DisableChangeReplication("DisplayOrder")
    self:DisableChangeReplication("IgnoreGuiInset")
    self:DisableChangeReplication("LastRotation")
    self.LastRotation = CFrame.new(Workspace.CurrentCamera:GetRenderCFrame().Position):Inverse() * Workspace.CurrentCamera:GetRenderCFrame()

    --Connect updating the size.
    self:AddPropertyFinalizer("Depth", function()
        self:UpdateSize()
    end)
    self:AddPropertyFinalizer("FieldOfView", function()
        self:UpdateSize()
    end)
    self:AddPropertyFinalizer("CanvasSize", function(Value)
        self:UpdateSize()
    end)

    --Update the size and position.
    self:UpdateSize()
    self:DisableChangeReplication("UpdateEvent")
    self.UpdateEvent = RunService.RenderStepped:Connect(function(DeltaTime: number)
        if self.Enabled then
            self:UpdateCFrame(DeltaTime)
        end
    end)
end

--[[
Updates the size of the part.
--]]
function ScreenGui3D:UpdateSize(): ()
    local Width = 2 * math.tan(self.FieldOfView/2) * self.Depth
    if self.CanvasSize.Y &lt;= self.CanvasSize.X then
        self.Adornee.Size = Vector3.new(Width, Width * (self.CanvasSize.Y / self.CanvasSize.X), 0)
    else
        self.Adornee.Size = Vector3.new(Width * (self.CanvasSize.X / self.CanvasSize.Y), Width, 0)
    end
    self.CanvasSize = self.CanvasSize
end

--[[
Updates the CFrame of the part.
--]]
function ScreenGui3D:UpdateCFrame(DeltaTime: number): ()
    DeltaTime = DeltaTime or self.Easing

    --Update the rotation.
    local CameraCFrame = Workspace.CurrentCamera:GetRenderCFrame()
    local TargetCFrame = CFrame.new(CameraCFrame.Position):Inverse() * CameraCFrame
    if self.Easing == 0 then
        self.LastRotation = TargetCFrame
    else
        self.LastRotation = self.LastRotation:Lerp(TargetCFrame, DeltaTime / self.Easing)
    end

    --Set the CFrame.
    self.Adornee.CFrame = CFrame.new(CameraCFrame.Position) * self.LastRotation * self.RotationOffset * CFrame.new(0,0,-self.Depth)
end

--[[
Destroys the ScreenGui.
--]]
function ScreenGui3D:Destroy(): ()
    BaseScreenGui.Destroy(self)
    self.UpdateEvent:Disconnect()
    self.Adornee:Destroy()
end



return ScreenGui3D</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="78">
          <Properties>
            <string name="Name">Utility</string>
          </Properties>
          <Item class="ModuleScript" referent="79">
            <Properties>
              <string name="Name">PartUtility</string>
              <string name="Source">--[[
TheNexusAvenger

Utility for parts.
--]]

local PartUtility = {}



--[[
Helper function for ray casting.
--]]
function PartUtility.RaycastToFront(AimingCFrame: CFrame, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)

    --Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * AimingCFrame
	local LocalTarget = LocalTargetCFrame.LookVector
	
	--Determine the angle away from the normal and cast the ray to the plane.
	local LookAngle = math.atan2(((LocalTarget.X ^ 2) + (LocalTarget.Y ^ 2)) ^ 0.5, LocalTarget.Z)
	local DistanceToScreen = LocalTargetCFrame.Z / math.cos(LookAngle)
	local LocalHitPosition = (LocalTargetCFrame * CFrame.new(0, 0, DistanceToScreen)).Position
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalHitPosition.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalHitPosition.Y / Size.Y))
    local Depth = -LocalTargetCFrame.Z * (1 / LocalTarget.Z)
	return RelativeX, RelativeY, Depth
end

--[[
Helper function for projecting.
--]]
function PartUtility.ProjectToFront(Position: Vector3, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)
	
	--Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * CFrame.new(Position)
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalTargetCFrame.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalTargetCFrame.Y / Size.Y))
	local Depth = -LocalTargetCFrame.Z
	return RelativeX, RelativeY, Depth
end

--[[
Ray casts to a surface. Returns the relative X and Y position
of the face, and the Z for the direction (>0 is facing, &lt;0
is not facing).
--]]
function PartUtility.Raycast(Part: BasePart, AimingCFrame: CFrame, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end

--[[
Returns the relative position that is projected onto the
plane. Returns the relative X and Y position of the face,
and the Z for the direction (>0 is before the plane, &lt;0
is after the plane).
--]]
function PartUtility.Project(Part: BasePart, HandPosition: Vector3, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end



return PartUtility</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="80">
          <Properties>
            <string name="Name">NexusInstance</string>
          </Properties>
          <Item class="Folder" referent="81">
            <Properties>
              <string name="Name">Event</string>
            </Properties>
            <Item class="ModuleScript" referent="82">
              <Properties>
                <string name="Name">NexusConnection</string>
                <string name="Source">--[[
TheNexusAvenger

Represents an event connection.
--]]
--!strict

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = NexusObject:Extend()
NexusConnection:SetClassName("NexusConnection")

export type NexusConnectionEvent&lt;T...> = {
    Disconnected: (NexusConnectionEvent&lt;T...>) -> (),
    [string]: any,
}
export type NexusConnection&lt;T...> = {
    new: (Event: NexusConnectionEvent&lt;T...>, ConnectionFunction: (T...) -> ()) -> (NexusConnection&lt;T...>),
    Extend: (self: NexusConnection&lt;T...>) -> (NexusConnection&lt;T...>),

    Connected: boolean,
    Fire: (NexusConnectionEvent&lt;T...>, T...) -> (),
    Disconnect: () -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of the connection.
--]]
function NexusConnection:__new&lt;T...>(Event: NexusConnectionEvent&lt;T...>, ConnectionFunction): ()
    NexusObject.__new(self)
    self.Event = Event
    self.ConnectionFunction = ConnectionFunction
    self.Connected = true
end

--[[
Fires the connection.
--]]
function NexusConnection:Fire&lt;T>(...: T): ()
    if self.Connected then
        self.ConnectionFunction(...)
    end
end

--[[
Disconnects the connection from the event.
--]]
function NexusConnection:Disconnect(): ()
    if self.Connected then
        self.Connected = false
        if self.Event then
            self.Event:Disconnected(self)
        end
    end
end



return NexusConnection :: NexusConnection&lt;></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="83">
              <Properties>
                <string name="Name">NexusEvent</string>
                <string name="Source">--[[
TheNexusAvenger

Sends and listens to events.
--]]
--!strict

local HttpService = game:GetService("HttpService")

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))
local NexusConnection = require(script.Parent:WaitForChild("NexusConnection"))

local NexusEvent = NexusObject:Extend()
NexusEvent:SetClassName("NexusEvent")

export type NexusEvent&lt;T...> = {
    new: () -> (NexusEvent&lt;T...>),
    Extend: (self: NexusEvent&lt;T...>) -> (NexusEvent&lt;T...>),

    Connect: (self: NexusEvent&lt;T...>, Callback: (T...) -> ()) -> (NexusConnection.NexusConnection&lt;T...>),
    Fire: (self: NexusEvent&lt;T...>, T...) -> (),
    Disconnect: (self: NexusEvent&lt;T...>) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an event.
--]]
function NexusEvent:__new(): ()
    NexusObject.__new(self)
    self.Connections = {}
    self.BindableEvent = Instance.new("BindableEvent")
    self.CurrentWaits = 0

    --For deferred events, the arguments need to be stored.
    --LastArgumentsStrong will keep the reference around and prevent
    --it from being garbage collected until only LastArguments references it.
    --Ideally, they will be used at the same time if both :Connect() and
    --:Wait() are used.
    self.LastArgumentsStrong = {}
    self.LastArguments = {}
    setmetatable(self.LastArguments, {__mode="v"})
end

--[[
Invoked when a connection is disconnected.
--]]
function NexusEvent:Disconnected&lt;T...>(Connection: NexusConnection.NexusConnection&lt;T...>): ()
    --Remove the bindable event connection.
    local BindableEventConnection = self.Connections[Connection]
    if BindableEventConnection then
        BindableEventConnection:Disconnect()
    end
    
    --Remove the connection.
    self.Connections[Connection] = nil
end

--[[
Disconnects all connected events.
--]]
function NexusEvent:Disconnect(): ()
    --Get the connections to disconnect.
    local ConnectionsToDisconnect = {}
    for Connection, _ in self.Connections do
        table.insert(ConnectionsToDisconnect, Connection)
    end
    
    --Disconnect the events.
    for _, Connection in ConnectionsToDisconnect do
        Connection:Disconnect()
    end
end

--[[
Establishes a function to be called whenever
the event is raised.
--]]
function NexusEvent:Connect&lt;T...>(Callback: (T...) -> ()): NexusConnection.NexusConnection&lt;T...>
    --Create the connection.
    local Connection = NexusConnection.new(self, Callback :: any)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Fires the event.
--]]
function NexusEvent:Fire&lt;T>(...: T): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits &lt;= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Yields the current thread until this signal
is fired. Returns what was fired to the signal.
--]]
function NexusEvent:Wait&lt;T>(): (T)
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end



return NexusEvent :: NexusEvent&lt;></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="84">
            <Properties>
              <string name="Name">NexusInstance</string>
              <string name="Source">--[[
TheNexusAvenger

Extends NexusObject to allow for changed singalling
and locking of properties.
--]]
--!strict

local NexusObject = require(script.Parent:WaitForChild("NexusObject"))
local NexusEvent = require(script.Parent:WaitForChild("Event"):WaitForChild("NexusEvent"))

local NexusInstance = NexusObject:Extend()
NexusInstance:SetClassName("NexusInstance")

export type LegacyPropertyValidator = {
    ValidateChange: (self: LegacyPropertyValidator, Object: NexusInstance, Index: string, Value: any) -> (any),
}
export type NexusInstance = {
    new: () -> (NexusInstance),
    Extend: (self: NexusInstance) -> (NexusInstance),

    Changed: NexusEvent.NexusEvent&lt;string>,
    AddGenericPropertyValidator: (self: NexusInstance, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddPropertyValidator: (self: NexusInstance, PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator) -> (),
    AddGenericPropertyFinalizer: (self: NexusInstance, Finalizer: (string, any) -> ()) -> (),
    AddPropertyFinalizer: (self: NexusInstance, PropertyName: string, Finalizer: (string, any) -> ()) -> (),
    LockProperty: (self: NexusInstance, PropertyName: string) -> (),
    HidePropertyChanges: (self: NexusInstance, PropertyName: string) -> (),
    HideNextPropertyChange: (self: NexusInstance, PropertyName: string) -> (),
    GetPropertyChangedSignal: (self: NexusInstance, PropertyName: string) -> (NexusEvent.NexusEvent&lt;>),
    Destroy: (self: NexusInstance) -> (),
} &amp; NexusObject.NexusObject



--[[
Creates an instance of a Nexus Instance.
--]]
function NexusInstance:__new(): ()
    --Set up the base object.
    NexusObject.__new(self)

    --Set up the internal properties.
    self:__InitInternalProperties()
    self:__InitMetaMethods()
end

--[[
Sets up the internal properties.
--]]
function NexusInstance:__InitInternalProperties(): ()
    --Set up the properties.
    self.__InternalProperties = {}
    self.__GenericPropertyValidators = {}
    self.__PropertyValidators = {}
    self.__GenericPropertyFinalizers = {}
    self.__PropertyFinalizers = {}
    self.__HiddenProperties = {}
    self.__LockedProperties = {}
    self.__BlockNextChangedSignals = {}
    self.__PropertyChanged = {}
    self.__ChangedEvent = NexusEvent.new()
    self.Changed = self.__ChangedEvent

    --Lock the internal states.
    self:LockProperty("__GenericPropertyValidators")
    self:LockProperty("__PropertyValidators")
    self:LockProperty("__GenericPropertyFinalizers")
    self:LockProperty("__PropertyFinalizers")
    self:LockProperty("__HiddenProperties")
    self:LockProperty("__LockedProperties")
    self:LockProperty("__BlockNextChangedSignals")
    self:LockProperty("__PropertyChanged")
    self:LockProperty("__ChangedEvent")
    self:LockProperty("Changed")
    self:LockProperty("ClassName")
end

--[[
Sets up the meta methods.
--]]
function NexusInstance:__InitMetaMethods(): ()
    --Set up the internal state.
    local InternalProperties = self.__InternalProperties
    local GenericPropertyValidators = self.__GenericPropertyValidators
    local PropertyFinalizers = self.__PropertyFinalizers
    local GenericPropertyFinalizers = self.__GenericPropertyFinalizers
    local PropertyValidators = self.__PropertyValidators
    local HiddenProperties = self.__HiddenProperties
    local LockedProperties = self.__LockedProperties
    local BlockNextChangedSignals = self.__BlockNextChangedSignals
    local PropertyChanged = self.__PropertyChanged
    local ChangedBindableEvent = self.__ChangedEvent

    --Set up custom indexing.
    local Metatable = {}
    local OriginalIndexTable = getmetatable(self).__index
    setmetatable(self, Metatable)
    Metatable.__index = function(_, Index: string): any
        --Return the internal property.
        local InternalPropertyValue = InternalProperties[Index]
        if InternalPropertyValue ~= nil then
            return InternalPropertyValue
        end

        --Return the base return.
        return OriginalIndexTable[Index]
    end

    --Set up changes.
    Metatable.__newindex = function(_, Index: string, Value: any): ()
        --Throw an error if the property is locked.
        if LockedProperties[Index] then
            error(tostring(Index).." is read-only.")
        end

        --Return if the new and old values are the same.
        if self[Index] == Value then
            return
        end

        --Validate the value.
        for _,Validator in GenericPropertyValidators do
            Value = Validator(Index, Value)
        end
        local Validators = PropertyValidators[Index]
        if Validators then
            for _, Validator in Validators do
                Value = Validator(Index, Value)
            end
        end

        --Change the property.
        InternalProperties[Index] = Value

        --Invoke the finalizers.
        --Will prevent sending changed signals if there is a problem.
        for _, Finalizer in GenericPropertyFinalizers do
            Finalizer(Index, Value)
        end
        local Finalizers = PropertyFinalizers[Index]
        if Finalizers then
            for _, Finalizer in Finalizers do
                Finalizer(Index, Value)
            end
        end

        --Return if the event is hidden.
        if BlockNextChangedSignals[Index] then
            BlockNextChangedSignals[Index] = nil
            return
        end

        --Invoke the property changed event.
        local PropertyChangedEvent = PropertyChanged[Index]
        if PropertyChangedEvent then
            PropertyChangedEvent:Fire()
        end

        --Invoke the Changed event.
        if HiddenProperties[Index] then
            return
        end
        ChangedBindableEvent:Fire(Index)
    end
end

--[[
Adds a validator that is called for all values.
These are called before any property-specific validators.
--]]
function NexusInstance:AddGenericPropertyValidator(Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddGenericPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddGenericPropertyValidator(function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    table.insert(self.__GenericPropertyValidators, Validator)
end

--[[
Adds a validator for a given property.
--]]
function NexusInstance:AddPropertyValidator(PropertyName: string, Validator: (string, any) -> (any) | LegacyPropertyValidator): ()
    if typeof(Validator) == "table" then
        warn("AddPropertyValidator with an object validator is deprecated. Use a validation function instead.")
        self:AddPropertyValidator(PropertyName, function(Name, Value)
            return Validator:ValidateChange(self, Name, Value)
        end)
        return
    end
    if not self.__PropertyValidators[PropertyName] then
        self.__PropertyValidators[PropertyName] = {}
    end
    table.insert(self.__PropertyValidators[PropertyName], Validator)
end

--[[
Adds a finalizer for when a property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddGenericPropertyFinalizer(Finalizer: (string, any) -> ()): ()
    table.insert(self.__GenericPropertyFinalizers, Finalizer)
end

--[[
Adds a finalizer for when a given property is set.
This is intended to prevent invoking changed events
if there is a problem.
--]]
function NexusInstance:AddPropertyFinalizer(PropertyName: string, Finalizer: (string, any) -> ())
    if not self.__PropertyFinalizers[PropertyName] then
        self.__PropertyFinalizers[PropertyName] = {}
    end
    table.insert(self.__PropertyFinalizers[PropertyName], Finalizer)
end

--[[
Prevents a property from being overriden.
--]]
function NexusInstance:LockProperty(PropertyName: string): ()
    self.__LockedProperties[PropertyName] = true
end

--[[
Prevents a property being changed from registering the Changed property.
--]]
function NexusInstance:HidePropertyChanges(PropertyName: string): ()
    self.__HiddenProperties[PropertyName] = true
end

--[[
Prevents all changed signals being fired for a property change 1 time.
Does not stack with multiple calls.
--]]
function NexusInstance:HideNextPropertyChange(PropertyName: string): ()
    self.__BlockNextChangedSignals[PropertyName] = true
end

--[[
Returns a changed signal specific to the property.
--]]
function NexusInstance:GetPropertyChangedSignal(PropertyName: string): NexusEvent.NexusEvent&lt;>
    --If there is no event created, create a bindable event.
    if not self.__PropertyChanged[PropertyName] then
        self.__PropertyChanged[PropertyName] = NexusEvent.new()
    end

    --Return the event.
    return self.__PropertyChanged[PropertyName]
end

--[[
Disconnects the events of the instance.
--]]
function NexusInstance:Destroy()
    --Disconnect the changed event.
    self.Changed:Disconnect()

    --Disconnect the changed signal events.
    for _,Event in self.__PropertyChanged do
        Event:Disconnect()
    end
    self.__PropertyChanged = {}
end



return NexusInstance :: NexusInstance</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="85">
            <Properties>
              <string name="Name">NexusObject</string>
              <string name="Source">--[[
TheNexusAvenger

Helper class for creating objects in Lua.
--]]
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
}



--[[
Returns the raw tostring of a table.
See: https://stackoverflow.com/questions/43285679/is-it-possible-to-bypass-tostring-the-way-rawget-set-bypasses-index-newind
--]]
local function RawToString(Table: any): string
    local Metatable = getmetatable(Table)
    local BaseFunction = Metatable.__tostring
    Metatable.__tostring = nil

    local String = tostring(Table)
    Metatable.__tostring = BaseFunction
    return String
end

--[[
Extends a class.
--]]
local function ExtendClass(SuperClass: {[string]: any}?) : NexusObject
    --Create the class.
    local Class = {}
    Class.super = SuperClass
    Class.__index = Class
    setmetatable(Class :: any, SuperClass)

    --[[
    Creates an object.
    --]]
    function Class.new(...)
        --Create the base object.
        local self = {} :: NexusObject
        self.__index = self
        self.class = Class
        setmetatable(self :: any, Class)

        --Run the constructor.
        self:__new(...)

        --Return the object.
        return self
    end

    --[[
    Constructor run for the class.
    --]]    
    function Class:__new(...)
        if not SuperClass then return end
        (SuperClass :: NexusObject).__new(self, ...)
    end

    --Add the metamethod passthrough.
    if SuperClass then
        for _, MetatableName in METATABLE_METHODS do
            Class[MetatableName] = SuperClass[MetatableName]
        end
    end

    --Call the callback for the class being extended.
    if SuperClass then
        SuperClass:__classextended(Class)
    end

    --Return the created class.
    return (Class :: any) :: NexusObject
end



--Set up the base Nexus Object class.
local NexusObject = ExtendClass() :: NexusObject
NexusObject.ClassName = "NexusObject"

export type NexusObject = {
    --Properties.
    class: {[string]: any},
    super: NexusObject,
    ClassName: string,
    [string]: any,

    --Static methods.
    new: () -> (NexusObject),
    Extend: (self: NexusObject) -> (NexusObject),
    SetClassName: (self: NexusObject, ClassName: string) -> (NexusObject),

    --Methods.
    IsA: (self: NexusObject, ClassName: string) -> (boolean),
}



--[[
Called after extending when another class extends
the class. The purpose of this is to add attributes
to the class.
--]]
function NexusObject:__classextended(OtherClass: NexusObject): ()
    if not self.super then return end
    self.super:__classextended(OtherClass)
end

--[[
Returns the object as a string.
--]]
function NexusObject:__tostring(): string
    local MemoryAddress = string.sub(RawToString(self), 8)
    return tostring(self.ClassName)..": "..tostring(MemoryAddress)
end

--[[
Returns if the object is equal to another object.
--]]
function NexusObject:__eq(OtherObject: any): boolean
    return rawequal(self, OtherObject)
end

--[[
Sets the class name of the class. Should be
called staticly (right after NexusObject::Extend).
--]]
function NexusObject:SetClassName(ClassName: string): NexusObject
    self.ClassName = ClassName
    return self
end

--[[
Extends a class to allow for implementing properties and
functions while inheriting the super class's behavior.
--]]
function NexusObject:Extend(): NexusObject
    return (ExtendClass(self) :: any) :: NexusObject
end

--[[
Returns if the instance is or inherits from a class of that name.
--]]
function NexusObject:IsA(ClassName: string): boolean
    --If the class name matches the class name, return true.
    local CurrentClass = self
    while CurrentClass do
        if CurrentClass.ClassName == ClassName then
            return true
        end
        CurrentClass = CurrentClass.super
    end

    --Return false (no match).
    return false
end



return NexusObject</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="86">
            <Properties>
              <string name="Name">PropertyValidator</string>
            </Properties>
            <Item class="ModuleScript" referent="87">
              <Properties>
                <string name="Name">TypePropertyValidator</string>
                <string name="Source">--[[
TheNexusAvenger

Implements the NexusPropertyValidator by
checking if the type or class is the same.
--]]

local NexusObjectFolder = script.Parent.Parent
local NexusObject = require(NexusObjectFolder:WaitForChild("NexusObject"))

local TypePropertyValidator = NexusObject:Extend()
TypePropertyValidator:SetClassName("TypePropertyValidator")

export type TypePropertyValidator = {
    CreateTypeValidator: (Type: string) -> ((string, any) -> (any)),
    new: (Type: string) -> (TypePropertyValidator),
    Extend: (self: TypePropertyValidator) -> (TypePropertyValidator),

    ValidateChange: (self: TypePropertyValidator, Object: any, ValueName: string, Value: any) -> (any),
} &amp; NexusObject.NexusObject



--[[
Creates a type validator for a type.
--]]
function TypePropertyValidator.CreateTypeValidator(Type: string): (string, any) -> (any)
    return function(ValueName: string, Value: any): any
        --Determine the type.
        local TypeMatches, ClassMatches = false, false
        local ValueType = typeof(Value)

        --Determine if the type matchs.
        if ValueType == Type then
            TypeMatches = true
        end

        --Determine if the class name matches.
        if not TypeMatches and (ValueType == "Instance" or (ValueType == "table" and typeof(Value.IsA) == "function")) then
            ValueType = Value.ClassName
            if Value:IsA(Type) then
                ClassMatches = true
            end
        end

        --Throw an error if the type is invalid.
        if not TypeMatches and not ClassMatches then
            error("Bad value for \""..tostring(ValueName).."\" ("..tostring(Type).." expected, got "..ValueType..")")
        end

        --Return the original value.
        return Value
    end
end

--[[
Creates a type validator.
--]]
function TypePropertyValidator:__new(Type: string): ()
    warn("TypePropertyValidator.new() is deprecated with object-based validators. Use CreateTypeValidator(Type) instead.")
    NexusObject.__new(self)
    self.Validator = TypePropertyValidator.CreateTypeValidator(Type)
end

--[[
Validates a change to the property of a NexusObject.
The new value must be returned. If the input is invalid,
an error should be thrown.
--]]
function TypePropertyValidator:ValidateChange(Object: any, ValueName: string, Value: any)
    return self.Validator(ValueName, Value)
end



return TypePropertyValidator :: TypePropertyValidator</string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>